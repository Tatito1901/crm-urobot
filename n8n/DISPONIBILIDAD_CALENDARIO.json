{
  "name": "DISPONIBILIDAD_CALENDARIO",
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"dateIntent\": \"today\",\n  \"specificDate\": \"\",\n  \"sedePreferida\": \"\",\n  \"onlyMorning\": false,\n  \"onlyAfternoon\": false\n}"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -2096,
        608
      ],
      "id": "c2799c91-4c27-4fd6-8bef-8bb038b22af0",
      "name": "When Executed by Another Workflow",
      "retryOnFail": true
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "mmartinezuro@gmail.com",
          "mode": "list",
          "cachedResultName": "mmartinezuro@gmail.com"
        },
        "timeMin": "={{$('SET_DEFAULTS1').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS1').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "75cf2ef6-2505-4782-83f9-fef7571f226e",
      "name": "Availability - POLANCO",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -976,
        416
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "retryOnFail": false,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "RzMlWUma86JGl9rZ",
          "name": "Google Calendar account"
        }
      },
      "notes": "v2.0: continueOnFail activo pero Normalize detecta errores"
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "a4e37c8238807fefa735fceee8af99fc4fc04131129ce2c1d729653ab16c8f15@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Hospital San Angel Inn \"Satelite\""
        },
        "timeMin": "={{$('SET_DEFAULTS1').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS1').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "fd412a51-9508-41bf-8751-91f596965136",
      "name": "Availability - SATELITE",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -976,
        608
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "RzMlWUma86JGl9rZ",
          "name": "Google Calendar account"
        }
      },
      "notes": "v2.0: continueOnFail activo pero Normalize detecta errores"
    },
    {
      "parameters": {
        "mode": "append",
        "numberInputs": 3
      },
      "id": "e556965b-7355-4a46-a1b0-eafc01090212",
      "name": "Merge Busy (append)1",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -528,
        608
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * COMBINE_BUSY v6.0.0 â€” ROBUST ERROR HANDLING\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * \n * CAMBIOS v6.0:\n * âœ… FIX #1: Detecta errores de API en inputs y propaga el estado\n * âœ… FIX #2: No asume \"calendario libre\" si hubo error de API\n * âœ… FIX #3: Mejor logging para debugging\n * âœ… FIX #4: ValidaciÃ³n estricta de slots antes de filtrar\n * \n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n */\n\nconst VERSION = '6.0.0-ROBUST';\nconst DEBUG = true;\n\nconst LIMITS = Object.freeze({\n  MAX_SLOTS_PER_DAY: 25,\n  MAX_TOTAL_SLOTS: 150,\n});\n\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = { \n    timestamp: new Date().toISOString(), \n    level: level.toUpperCase(), \n    component: 'COMBINE_BUSY', \n    version: VERSION, \n    message, \n    ...data \n  };\n  LOGS.push(entry);\n  if (DEBUG) console.log(`[${level.toUpperCase()}] ${message}`, JSON.stringify(data));\n}\n\nconst _formattersCache = new Map();\nfunction getCachedFormatter(options, tz) {\n  const key = JSON.stringify({ ...options, tz });\n  let formatter = _formattersCache.get(key);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat('es-MX', { timeZone: tz, ...options });\n    _formattersCache.set(key, formatter);\n  }\n  return formatter;\n}\n\nfunction formatLocal(iso, tz) {\n  try {\n    const formatter = getCachedFormatter({ \n      hour12: false, \n      year: 'numeric', \n      month: '2-digit', \n      day: '2-digit', \n      hour: '2-digit', \n      minute: '2-digit' \n    }, tz);\n    return formatter.format(new Date(iso));\n  } catch {\n    return iso;\n  }\n}\n\nfunction cropToWindow(interval, startISO, endISO) {\n  try {\n    const s = (startISO && interval.start < startISO) ? startISO : interval.start;\n    const e = (endISO && interval.end > endISO) ? endISO : interval.end;\n    return (s < e) ? { start: s, end: e } : null;\n  } catch {\n    return null;\n  }\n}\n\nfunction mergeExclusive(list) {\n  if (!list || !list.length) return [];\n  try {\n    const sorted = [...list].sort((a, b) => a.start.localeCompare(b.start));\n    const merged = [{ start: sorted[0].start, end: sorted[0].end }];\n    \n    for (let i = 1; i < sorted.length; i++) {\n      const last = merged[merged.length - 1];\n      const current = sorted[i];\n      if (current.start < last.end) {\n        if (current.end > last.end) last.end = current.end;\n      } else {\n        merged.push({ start: current.start, end: current.end });\n      }\n    }\n    return merged;\n  } catch {\n    return [];\n  }\n}\n\nfunction filterBusySlots(slots, busyBySede) {\n  if (!slots || !Array.isArray(slots)) return [];\n  \n  return slots.filter(slot => {\n    try {\n      if (!slot || !slot.sede || !slot.start || !slot.end) return false;\n      \n      const busyList = busyBySede[slot.sede];\n      if (!busyList || !busyList.length) return true;\n\n      for (const busy of busyList) {\n        // Overlap check: slot.start < busy.end AND slot.end > busy.start\n        if (slot.start < busy.end && slot.end > busy.start) {\n          return false;\n        }\n      }\n      return true;\n    } catch {\n      return false; // En caso de error, NO permitir el slot (mÃ¡s seguro)\n    }\n  });\n}\n\nfunction loadContext() {\n  let ctx = {}, requestId = `combine-${Date.now()}`;\n  \n  try {\n    const setDefaultsItems = $('SET_DEFAULTS1').all();\n    if (setDefaultsItems.length > 0) {\n      ctx = setDefaultsItems[0].json || {};\n      if (ctx.requestId) requestId = ctx.requestId;\n      return { ctx, requestId, source: 'SET_DEFAULTS' };\n    }\n  } catch (err) {\n    log('WARN', 'No se pudo cargar SET_DEFAULTS', { error: err.message });\n  }\n  \n  try {\n    const items = $input.all();\n    for (const item of items) {\n      if (item.json?.kind === 'context') {\n        ctx = item.json;\n        if (ctx.requestId) requestId = ctx.requestId;\n        return { ctx, requestId, source: 'input_context' };\n      }\n    }\n  } catch {}\n  \n  return { \n    ctx: { \n      tz: 'America/Mexico_City',\n      windowStart: new Date().toISOString(),\n      windowEnd: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString()\n    }, \n    requestId, \n    source: 'fallback' \n  };\n}\n\nfunction loadSedes() {\n  try {\n    const store = $getWorkflowStaticData('global');\n    if (store?.SCHEDULE?.sedes) return Object.keys(store.SCHEDULE.sedes);\n  } catch {}\n  return ['POLANCO', 'SATELITE'];\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// MAIN\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ntry {\n  const startTime = Date.now();\n  \n  const rawItems = $input.all().map(x => x.json);\n  const { ctx, requestId, source: ctxSource } = loadContext();\n  const SEDES = loadSedes();\n  const TZ = ctx.tz || 'America/Mexico_City';\n  const windowStartISO = ctx.windowStart || null;\n  const windowEndISO = ctx.windowEnd || null;\n\n  // â•â•â• DETECCIÃ“N DE ERRORES DE API â•â•â•\n  const apiErrors = [];\n  const sedesConError = new Set();\n  \n  for (const item of rawItems) {\n    if (!item) continue;\n    \n    // Detectar errores de API propagados desde Normalize\n    if (item.sourceStatus === 'API_ERROR' || item.error === true) {\n      const sede = item.sede || 'UNKNOWN';\n      sedesConError.add(sede);\n      apiErrors.push({\n        sede,\n        error: item.errorMessage || item.error || 'API_ERROR',\n        timestamp: new Date().toISOString()\n      });\n      log('ERROR', `API error detectado para sede ${sede}`, { error: item.errorMessage });\n    }\n  }\n  \n  // Si TODAS las sedes tienen error, NO podemos dar horarios confiables\n  if (sedesConError.size >= SEDES.length) {\n    log('CRITICAL', 'TODAS las sedes tienen error de API - no se pueden mostrar horarios');\n    return [{\n      json: {\n        kind: 'busy_combined',\n        build: { version: VERSION, generatedAt: new Date().toISOString() },\n        requestId,\n        ctx,\n        scheduleGate: { allowedSlots: [] },\n        busyBySede: {},\n        metrics: {\n          apiErrors: apiErrors.length,\n          sedesConError: [...sedesConError],\n          allSedesFailed: true\n        },\n        error: 'ALL_CALENDARS_FAILED',\n        errorMessage: 'No se pudo conectar con los calendarios. Por favor intenta de nuevo.',\n        _logs: LOGS\n      }\n    }];\n  }\n\n  // Extraer Busy Intervals (solo de sedes SIN error)\n  const groups = Object.fromEntries(SEDES.map(s => [s, []]));\n  \n  for (const item of rawItems) {\n    if (!item || item.kind !== 'busy') continue;\n    if (item.sourceStatus === 'API_ERROR' || item.error === true) continue; // Saltar errores\n    \n    if (item.sede && groups[item.sede]) {\n      (item.busy || []).forEach(slot => {\n        const clipped = cropToWindow(slot, windowStartISO, windowEndISO);\n        if (clipped) groups[item.sede].push(clipped);\n      });\n    }\n    else if (item.busyBySede) {\n      for (const [s, list] of Object.entries(item.busyBySede)) {\n        if (groups[s] && Array.isArray(list)) {\n          list.forEach(slot => {\n            const clipped = cropToWindow(slot, windowStartISO, windowEndISO);\n            if (clipped) groups[s].push(clipped);\n          });\n        }\n      }\n    }\n  }\n\n  const busyBySede = Object.fromEntries(SEDES.map(s => [s, mergeExclusive(groups[s])]));\n  \n  // Obtener Allowed Slots desde SCHEDULE_GATE\n  let allowedSlots = [];\n  let scheduleGateError = null;\n  \n  try {\n    const gate = $('SCHEDULE_GATE').first()?.json;\n    if (gate?.allowedSlots && Array.isArray(gate.allowedSlots)) {\n      allowedSlots = gate.allowedSlots;\n    } else if (gate?.error) {\n      scheduleGateError = gate.error;\n    }\n  } catch (err) {\n    scheduleGateError = err.message;\n    log('WARN', 'Error cargando SCHEDULE_GATE', { error: err.message });\n  }\n\n  const preFilterCount = allowedSlots.length;\n  \n  // Filtrar solo sedes vÃ¡lidas Y sin error de API\n  allowedSlots = allowedSlots.filter(s => {\n    if (!s || !SEDES.includes(s.sede)) return false;\n    if (sedesConError.has(s.sede)) return false; // No mostrar horarios de sedes con error\n    return true;\n  });\n\n  // Aplicar filtro de ocupaciÃ³n\n  let finalSlots = filterBusySlots(allowedSlots, busyBySede);\n\n  // Aplicar lÃ­mite\n  const maxResults = ctx.maxResults || LIMITS.MAX_TOTAL_SLOTS;\n  const wasLimited = finalSlots.length > maxResults;\n  finalSlots = finalSlots.slice(0, maxResults);\n\n  const busyBySedeLocal = Object.fromEntries(\n    SEDES.map(s => [s, (busyBySede[s] || []).map(iv => ({ \n      ...iv, \n      startLocal: formatLocal(iv.start, TZ), \n      endLocal: formatLocal(iv.end, TZ) \n    }))])\n  );\n  \n  const result = {\n    kind: 'busy_combined',\n    build: { version: VERSION, generatedAt: new Date().toISOString() },\n    requestId,\n    ctx,\n    \n    scheduleGate: {\n      allowedSlots: finalSlots \n    },\n    \n    busyBySede,\n    busyBySedeLocal,\n    \n    // â•â•â• WARNINGS PARA BUILD_RESPONSE â•â•â•\n    warnings: {\n      sedesConError: [...sedesConError],\n      apiErrors: apiErrors.length > 0 ? apiErrors : null,\n      wasLimited,\n      scheduleGateError\n    },\n    \n    metrics: {\n      totalInputSlots: preFilterCount,\n      totalBusyBlocks: Object.values(busyBySede).flat().length,\n      filteredByBusy: allowedSlots.length - finalSlots.length,\n      filteredByApiError: preFilterCount - allowedSlots.length,\n      finalOutput: finalSlots.length,\n      ctxSource,\n      executionMs: Date.now() - startTime\n    },\n    \n    debugLocal: { tz: TZ, sedes: SEDES },\n    _logs: DEBUG ? LOGS : undefined\n  };\n  \n  log('SUCCESS', `Finalizado. Slots entregados: ${finalSlots.length}`, { \n    sedesConError: [...sedesConError],\n    warnings: result.warnings \n  });\n  \n  return [{\n    json: result,\n    pairedItem: $input.all().map((_, i) => ({ item: i }))\n  }];\n\n} catch (err) {\n  log('ERROR', err.message, { stack: err.stack });\n  return [{ \n    json: { \n      kind: 'busy_combined',\n      build: { version: VERSION },\n      scheduleGate: { allowedSlots: [] },\n      busyBySede: {},\n      metrics: { error: err.message },\n      error: 'COMBINE_FAIL', \n      errorMessage: 'Error interno al procesar disponibilidad. Por favor intenta de nuevo.',\n      _logs: LOGS\n    } \n  }];\n}"
      },
      "id": "edc86fe0-ef7e-4d88-8c11-ccad3135ff9d",
      "name": "Combine Busy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        608
      ],
      "notes": "v6.0: Detecta errores de API y NO asume calendario libre"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n/**\n * CALC_AVAILABILITY v14.0.0 â€” n8n-skills Optimized\n * \n * Changes:\n *   âœ… P3: Uses Luxon DateTime for all date/time formatting\n *   âœ… P5: console.log debugging throughout\n *   âœ… Cleaner code following n8n-skills patterns\n */\n\nconst VERSION = '14.0.0-SKILLS-OPTIMIZED';\nconst DEFAULT_TZ = 'America/Mexico_City';\nconst DEFAULT_LIMIT = 100;\n\n/* ===================== P3: LUXON HELPERS ===================== */\nfunction getLocalTime(iso, tz) {\n  try {\n    return DateTime.fromISO(iso).setZone(tz).toFormat('HH:mm');\n  } catch {\n    return iso?.split('T')[1]?.substring(0, 5) || '00:00';\n  }\n}\n\nfunction getLocalHour(iso, tz) {\n  try {\n    return DateTime.fromISO(iso).setZone(tz).hour;\n  } catch {\n    return 12;\n  }\n}\n\nfunction getDateKey(iso) {\n  return iso?.split('T')[0] || '';\n}\n\nfunction getWeekdayName(iso, tz) {\n  try {\n    return DateTime.fromISO(iso).setZone(tz).setLocale('es-MX').toFormat('cccc');\n  } catch {\n    return '';\n  }\n}\n\nfunction formatDateSpanish(iso, tz) {\n  try {\n    const dt = DateTime.fromISO(iso).setZone(tz).setLocale('es-MX');\n    const weekday = dt.toFormat('cccc');\n    const dayMonth = dt.toFormat(\"d 'de' LLLL\");\n    return `${weekday.charAt(0).toUpperCase() + weekday.slice(1)}, ${dayMonth}`;\n  } catch {\n    return iso?.split('T')[0] || '';\n  }\n}\n\n/* ===================== MAIN ===================== */\ntry {\n  const startTime = Date.now();\n  const items = $input.all();\n  const inputData = items[0]?.json || {};\n\n  // â•â•â• LOAD CONTEXT â•â•â•\n  let rawSlots = [];\n  let requestId = inputData.requestId || `calc-${Date.now()}`;\n  let TZ = DEFAULT_TZ;\n  let ctx = {};\n  let warnings = {};\n\n  if (inputData.kind === 'busy_combined') {\n    rawSlots = inputData.scheduleGate?.allowedSlots || [];\n    TZ = inputData.ctx?.tz || inputData.debugLocal?.tz || DEFAULT_TZ;\n    ctx = inputData.ctx || {};\n    warnings = inputData.warnings || {};\n  } else if (inputData.allowedSlots) {\n    rawSlots = inputData.allowedSlots;\n    TZ = inputData.tz || DEFAULT_TZ;\n    ctx = inputData;\n  } else if (inputData.scheduleGate?.allowedSlots) {\n    rawSlots = inputData.scheduleGate.allowedSlots;\n    TZ = inputData.tz || DEFAULT_TZ;\n    ctx = inputData;\n  } else if (Array.isArray(inputData)) {\n    rawSlots = inputData;\n  }\n\n  console.log(`[Calc Availability] Input: ${rawSlots.length} raw slots, tz=${TZ}`);\n\n  // â•â•â• PROPAGATE ERRORS â•â•â•\n  if (inputData.error) {\n    console.log(`[Calc Availability] Propagating error: ${inputData.errorMessage}`);\n    return [{\n      json: {\n        kind: 'avail', version: VERSION, requestId, tz: TZ,\n        allowedSlots: [],\n        summary: { totalAvailable: 0, returned: 0, daysWithSlots: 0 },\n        error: inputData.error, errorMessage: inputData.errorMessage || 'Calendar error',\n        warnings, timestamp: new Date().toISOString()\n      }\n    }];\n  }\n\n  // â•â•â• NO SLOTS â•â•â•\n  if (!rawSlots || rawSlots.length === 0) {\n    console.log('[Calc Availability] No slots received from previous node');\n    return [{\n      json: {\n        kind: 'avail', version: VERSION, requestId, tz: TZ, ctx,\n        allowedSlots: [],\n        summary: { totalAvailable: 0, returned: 0, daysWithSlots: 0 },\n        warnings, timestamp: new Date().toISOString()\n      }\n    }];\n  }\n\n  // â•â•â• TIME FILTERS (MORNING/AFTERNOON) â•â•â•\n  const onlyMorning = ctx.onlyMorning === true;\n  const onlyAfternoon = ctx.onlyAfternoon === true;\n\n  let filteredSlots = rawSlots;\n  if (onlyMorning || onlyAfternoon) {\n    filteredSlots = rawSlots.filter(slot => {\n      if (!slot?.start) return false;\n      const hour = getLocalHour(slot.start, TZ);\n      if (onlyMorning) return hour < 14;\n      if (onlyAfternoon) return hour >= 14;\n      return true;\n    });\n    console.log(`[Calc Availability] Time filter: ${rawSlots.length} â†’ ${filteredSlots.length} (morning=${onlyMorning}, afternoon=${onlyAfternoon})`);\n  }\n\n  // â•â•â• ENRICH SLOTS â•â•â•\n  const enrichedSlots = filteredSlots.map(slot => {\n    if (!slot?.start) return null;\n\n    const localTime = getLocalTime(slot.start, TZ);\n    const hour = parseInt(localTime.split(':')[0]) || 0;\n\n    return {\n      ...slot,\n      startHM: localTime,\n      shiftLabel: hour < 14 ? 'MaÃ±ana' : 'Tarde',\n      dayKey: getDateKey(slot.start),\n      weekday: getWeekdayName(slot.start, TZ),\n      dateFormatted: formatDateSpanish(slot.start, TZ),\n      _sortKey: DateTime.fromISO(slot.start).toMillis()\n    };\n  }).filter(Boolean);\n\n  // â•â•â• SORT CHRONOLOGICALLY â•â•â•\n  enrichedSlots.sort((a, b) => a._sortKey - b._sortKey);\n\n  // â•â•â• APPLY LIMIT â•â•â•\n  const limit = ctx.maxResults || DEFAULT_LIMIT;\n  const wasLimited = enrichedSlots.length > limit;\n  const limitedSlots = enrichedSlots.slice(0, limit);\n  limitedSlots.forEach(s => delete s._sortKey);\n\n  // â•â•â• DAY ANALYSIS â•â•â•\n  const slotsByDay = {};\n  for (const slot of limitedSlots) {\n    if (!slotsByDay[slot.dayKey]) {\n      slotsByDay[slot.dayKey] = {\n        date: slot.dayKey, dateFormatted: slot.dateFormatted,\n        weekday: slot.weekday, slots: [], sedes: new Set()\n      };\n    }\n    slotsByDay[slot.dayKey].slots.push(slot);\n    slotsByDay[slot.dayKey].sedes.add(slot.sede);\n  }\n\n  const dayAnalysis = Object.values(slotsByDay).map(day => ({\n    date: day.date, dateFormatted: day.dateFormatted, weekday: day.weekday,\n    slotsCount: day.slots.length, sedes: [...day.sedes],\n    times: day.slots.map(s => s.startHM)\n  }));\n\n  const summary = {\n    totalAvailable: rawSlots.length,\n    afterTimeFilter: filteredSlots.length,\n    returned: limitedSlots.length,\n    wasLimited,\n    firstSlot: limitedSlots[0]?.start || null,\n    lastSlot: limitedSlots[limitedSlots.length - 1]?.start || null,\n    daysWithSlots: Object.keys(slotsByDay).length,\n    filtersApplied: { onlyMorning, onlyAfternoon }\n  };\n\n  if (warnings.sedesConError?.length > 0) {\n    summary.sedesConError = warnings.sedesConError;\n  }\n\n  console.log(`[Calc Availability] Done: ${limitedSlots.length} slots across ${summary.daysWithSlots} days (${Date.now() - startTime}ms)`);\n\n  return [{\n    json: {\n      kind: 'avail', version: VERSION, requestId, tz: TZ, ctx,\n      allowedSlots: limitedSlots,\n      summary, dayAnalysis,\n      warnings: Object.keys(warnings).length > 0 ? warnings : undefined,\n      timestamp: new Date().toISOString(),\n      executionMs: Date.now() - startTime\n    }\n  }];\n\n} catch (error) {\n  console.log(`[Calc Availability] Exception: ${error.message}`);\n  return [{\n    json: {\n      kind: 'avail', version: VERSION, status: 'error',\n      error: error.message, allowedSlots: [],\n      summary: { totalAvailable: 0 },\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "id": "2978102e-cefb-43d7-a61d-fa11846d9948",
      "name": "Calc Availability",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        608
      ],
      "notes": "v13.0: Soporte onlyMorning/onlyAfternoon, lÃ­mite configurable"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * SCHEDULE_GATE v17.0.0 â€” WEEK A/B VALIDATION + ROBUST\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * CAMBIOS v17.0:\n * \n * âœ… FIX #1: ValidaciÃ³n estricta de anchor_date para semanas A/B\n * âœ… FIX #2: Si anchor_date es NULL, usa horarios sin alternancia (warning)\n * âœ… FIX #3: Mejor normalizaciÃ³n de sede\n * âœ… FIX #4: Logging detallado para debugging\n * âœ… FIX #5: Soporte para onlyMorning/onlyAfternoon\n * \n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n */\n\nconst VERSION = '17.0.0-WEEK-VALIDATION';\nconst DEBUG = true;\n\n// ==================== LOGGING ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'SCHEDULE_GATE',\n    version: VERSION,\n    message,\n    ...data,\n  };\n  LOGS.push(entry);\n  if (DEBUG) {\n    const emoji = {\n      INFO: 'â„¹ï¸',\n      WARN: 'âš ï¸',\n      ERROR: 'âŒ',\n      DEBUG: 'ğŸ”',\n      SUCCESS: 'âœ…',\n    }[level.toUpperCase()] || 'ğŸ“';\n    console.log(`${emoji} [${level.toUpperCase()}] ${message}`, JSON.stringify(data));\n  }\n}\n\n// ==================== TIMEZONE / DATE HELPERS ====================\nlet _formattersCache = {};\nfunction getFormatters(tz) {\n  if (!_formattersCache[tz]) {\n    _formattersCache[tz] = {\n      tz,\n      DTF_FULL: new Intl.DateTimeFormat('en-CA', {\n        timeZone: tz,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false,\n      }),\n      DTF_DISPLAY: new Intl.DateTimeFormat('es-MX', {\n        timeZone: tz,\n        weekday: 'long',\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      }),\n      DTF_HM: new Intl.DateTimeFormat('en-US', {\n        timeZone: tz,\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      }),\n    };\n  }\n  return _formattersCache[tz];\n}\n\nfunction getLocalParts(date, DTF_FULL) {\n  const parts = DTF_FULL.formatToParts(date);\n  const obj = {};\n  for (const p of parts) obj[p.type] = p.value;\n  return {\n    y: +obj.year,\n    m: +obj.month,\n    d: +obj.day,\n    hh: +obj.hour,\n    mm: +obj.minute,\n    ss: +obj.second,\n  };\n}\n\nfunction localToUTC(y, m, d, hh = 0, mm = 0, ss = 0, DTF_FULL) {\n  const naive = Date.UTC(y, m - 1, d, hh, mm, ss);\n  const asLocal = getLocalParts(new Date(naive), DTF_FULL);\n  const localEpoch = Date.UTC(\n    asLocal.y,\n    asLocal.m - 1,\n    asLocal.d,\n    asLocal.hh,\n    asLocal.mm,\n    asLocal.ss,\n  );\n  return naive - (localEpoch - naive);\n}\n\nfunction timeAtDay(date, hhmm, DTF_FULL) {\n  const [hh, mm] = hhmm.split(':').map(Number);\n  const parts = getLocalParts(date, DTF_FULL);\n  return localToUTC(parts.y, parts.m, parts.d, hh, mm, 0, DTF_FULL);\n}\n\nfunction getDOW(date, DTF_FULL) {\n  const parts = getLocalParts(date, DTF_FULL);\n  const d = new Date(Date.UTC(parts.y, parts.m - 1, parts.d, 12));\n  return d.getUTCDay();\n}\n\n// ==================== WEEK A/B LOGIC ====================\nfunction getWeekType(currentDate, anchorDate, anchorWeekType, DTF_FULL) {\n  if (!anchorDate || !anchorWeekType) {\n    return null; // Sin alternancia\n  }\n  \n  try {\n    const anchor = new Date(anchorDate);\n    const current = new Date(currentDate);\n    \n    // Calcular diferencia en semanas\n    const msPerWeek = 7 * 24 * 60 * 60 * 1000;\n    const diffMs = current.getTime() - anchor.getTime();\n    const diffWeeks = Math.floor(diffMs / msPerWeek);\n    \n    // Si diffWeeks es par, misma semana que anchor\n    // Si diffWeeks es impar, semana opuesta\n    const isEven = diffWeeks % 2 === 0;\n    \n    if (isEven) {\n      return anchorWeekType; // 'A' o 'B'\n    } else {\n      return anchorWeekType === 'A' ? 'B' : 'A';\n    }\n  } catch (err) {\n    log('WARN', 'Error calculando weekType', { error: err.message });\n    return null;\n  }\n}\n\n// ==================== MAIN ====================\ntry {\n  const startTime = Date.now();\n  \n  // Cargar contexto\n  let ctx = {};\n  try {\n    ctx = $('SET_DEFAULTS1').first()?.json || {};\n  } catch {\n    log('WARN', 'No se pudo cargar SET_DEFAULTS');\n  }\n  \n  const TZ = ctx.tz || 'America/Mexico_City';\n  const { DTF_FULL } = getFormatters(TZ);\n  \n  // Cargar SCHEDULE desde static data o CARGAR_HORARIOS\n  let SCHEDULE = null;\n  try {\n    const store = $getWorkflowStaticData('global');\n    if (store?.SCHEDULE) {\n      SCHEDULE = store.SCHEDULE;\n    }\n  } catch {}\n  \n  if (!SCHEDULE) {\n    try {\n      const horarios = $('CARGAR_HORARIOS1').first()?.json;\n      if (horarios?.SCHEDULE) {\n        SCHEDULE = horarios.SCHEDULE;\n        $getWorkflowStaticData('global').SCHEDULE = SCHEDULE;\n      }\n    } catch {}\n  }\n  \n  if (!SCHEDULE || !SCHEDULE.sedes) {\n    log('ERROR', 'No se pudo cargar SCHEDULE');\n    return [{ json: { error: 'NO_SCHEDULE', allowedSlots: [], _logs: LOGS } }];\n  }\n  \n  const SEDES = Object.keys(SCHEDULE.sedes);\n  \n  // Filtrar sedes si hay preferencia\n  let targetSedes = SEDES;\n  if (ctx.sedePreferida && SEDES.includes(ctx.sedePreferida)) {\n    targetSedes = [ctx.sedePreferida];\n    log('INFO', `Filtrando por sede preferida: ${ctx.sedePreferida}`);\n  }\n  \n  // Validar anchor_date para semanas A/B\n  const weekValidation = {};\n  for (const sede of SEDES) {\n    const meta = SCHEDULE.meta?.[sede] || {};\n    if (meta.hasWeekAlternation) {\n      if (!meta.anchorDate || !meta.anchorWeekType) {\n        weekValidation[sede] = {\n          valid: false,\n          warning: `Sede ${sede} tiene alternancia A/B pero anchor_date no estÃ¡ configurado`\n        };\n        log('WARN', weekValidation[sede].warning);\n      } else {\n        weekValidation[sede] = { valid: true };\n      }\n    }\n  }\n  \n  // Generar slots\n  const allowedSlots = [];\n  const windowStart = new Date(ctx.windowStart);\n  const windowEnd = new Date(ctx.windowEnd);\n  const slotMinutes = ctx.slotMinutes || 30;\n  const shortNoticeMs = (ctx.shortNoticeMin || 120) * 60 * 1000;\n  const now = new Date();\n  const minBookableTime = now.getTime() + shortNoticeMs;\n  \n  let currentDate = new Date(windowStart);\n  let daysProcessed = 0;\n  const maxDays = 30;\n  \n  while (currentDate <= windowEnd && daysProcessed < maxDays) {\n    const dow = getDOW(currentDate, DTF_FULL);\n    \n    for (const sede of targetSedes) {\n      const sedeSchedule = SCHEDULE.sedes[sede];\n      if (!sedeSchedule) continue;\n      \n      // Determinar tipo de semana si aplica\n      let weekType = null;\n      const meta = SCHEDULE.meta?.[sede] || {};\n      \n      if (meta.hasWeekAlternation) {\n        if (meta.anchorDate && meta.anchorWeekType) {\n          weekType = getWeekType(currentDate, meta.anchorDate, meta.anchorWeekType, DTF_FULL);\n          log('DEBUG', `Semana ${weekType} para ${sede} el ${currentDate.toISOString().split('T')[0]}`);\n        } else {\n          // Sin anchor_date, usar todos los horarios (fallback)\n          log('WARN', `${sede}: usando horarios sin alternancia por falta de anchor_date`);\n        }\n      }\n      \n      // Obtener turnos del dÃ­a\n      const dayConfig = sedeSchedule[dow];\n      if (!dayConfig) continue;\n      \n      let shifts = [];\n      \n      if (Array.isArray(dayConfig)) {\n        // Formato simple: [[\"09:00\", \"14:00\", \"MaÃ±ana\"], ...]\n        shifts = dayConfig;\n      } else if (typeof dayConfig === 'object') {\n        // Formato con semanas: { A: [...], B: [...] }\n        if (weekType && dayConfig[weekType]) {\n          shifts = dayConfig[weekType];\n        } else {\n          // Sin weekType definido, tomar todos (fallback)\n          shifts = [...(dayConfig.A || []), ...(dayConfig.B || [])];\n        }\n      }\n      \n      // Generar slots para cada turno\n      for (const shift of shifts) {\n        if (!Array.isArray(shift) || shift.length < 2) continue;\n        \n        const [startHM, endHM, label] = shift;\n        \n        // Filtro por maÃ±ana/tarde si estÃ¡ activo\n        if (ctx.onlyMorning) {\n          const startHour = parseInt(startHM.split(':')[0]);\n          if (startHour >= 14) continue; // Saltar turnos de tarde\n        }\n        if (ctx.onlyAfternoon) {\n          const startHour = parseInt(startHM.split(':')[0]);\n          if (startHour < 14) continue; // Saltar turnos de maÃ±ana\n        }\n        \n        const shiftStartMs = timeAtDay(currentDate, startHM, DTF_FULL);\n        const shiftEndMs = timeAtDay(currentDate, endHM, DTF_FULL);\n        \n        let slotStartMs = shiftStartMs;\n        const slotDurationMs = slotMinutes * 60 * 1000;\n        \n        while (slotStartMs + slotDurationMs <= shiftEndMs) {\n          // Verificar que no sea muy pronto (short notice)\n          if (slotStartMs >= minBookableTime) {\n            const slotEndMs = slotStartMs + slotDurationMs;\n            \n            allowedSlots.push({\n              id: `${sede}-${slotStartMs}`,\n              sede,\n              start: new Date(slotStartMs).toISOString(),\n              end: new Date(slotEndMs).toISOString(),\n              shiftLabel: label || (parseInt(startHM.split(':')[0]) < 14 ? 'MaÃ±ana' : 'Tarde'),\n              weekType: weekType || undefined\n            });\n          }\n          \n          slotStartMs += slotDurationMs;\n        }\n      }\n    }\n    \n    // Avanzar al siguiente dÃ­a\n    currentDate.setDate(currentDate.getDate() + 1);\n    daysProcessed++;\n  }\n  \n  log('SUCCESS', `Generados ${allowedSlots.length} slots`, {\n    sedes: targetSedes,\n    daysProcessed\n  });\n  \n  return [{\n    json: {\n      kind: 'schedule_gate',\n      version: VERSION,\n      allowedSlots,\n      weekValidation,\n      ctx: {\n        sedePreferida: ctx.sedePreferida,\n        onlyMorning: ctx.onlyMorning,\n        onlyAfternoon: ctx.onlyAfternoon,\n        shortNoticeMin: ctx.shortNoticeMin\n      },\n      metrics: {\n        totalSlots: allowedSlots.length,\n        daysProcessed,\n        sedes: targetSedes,\n        executionMs: Date.now() - startTime\n      },\n      _logs: DEBUG ? LOGS : undefined\n    }\n  }];\n  \n} catch (err) {\n  log('ERROR', err.message, { stack: err.stack });\n  return [{\n    json: {\n      error: 'SCHEDULE_GATE_FAIL',\n      errorMessage: err.message,\n      allowedSlots: [],\n      _logs: LOGS\n    }\n  }];\n}"
      },
      "id": "314b0f07-de04-4516-8c67-52060bed8eb7",
      "name": "SCHEDULE_GATE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1200,
        608
      ],
      "notes": "v17.0: ValidaciÃ³n de semanas A/B, soporte onlyMorning/Afternoon"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n/**\n * NORMALIZE_BUSY v4.0.0 â€” Unified & Clean\n * Sede: POLANCO\n * \n * Parses Google Calendar FreeBusy API response into standardized busy intervals.\n * Follows n8n-skills best practices:\n *   âœ… try/catch with error propagation\n *   âœ… Proper [{json:{}}] return format\n *   âœ… Null checks with optional chaining\n *   âœ… console.log debugging\n *   âœ… No merge logic (delegated to Combine Busy)\n */\n\nconst SEDE = 'POLANCO';\nconst VERSION = '4.0.0-UNIFIED';\n\ntry {\n  const items = $input.all();\n  const busySlots = [];\n  let apiError = null;\n\n  for (const item of items) {\n    const json = item.json;\n    if (!json) continue;\n\n    // â•â•â• API ERROR DETECTION â•â•â•\n    if (json.error) {\n      apiError = {\n        type: 'GOOGLE_API_ERROR',\n        message: json.error?.message || String(json.error),\n        code: json.error?.code || json.code\n      };\n      console.log(`[Normalize ${SEDE}] Google API error detected: ${apiError.message}`);\n      continue;\n    }\n\n    if (json.code && json.code >= 400) {\n      apiError = { type: 'HTTP_ERROR', message: `HTTP ${json.code}`, code: json.code };\n      continue;\n    }\n\n    if (Object.keys(json).length === 0) {\n      console.log(`[Normalize ${SEDE}] Empty object received (possible silent error)`);\n    }\n\n    // â•â•â• PARSE BUSY SLOTS â•â•â•\n\n    // Format 1: Google Calendar FreeBusy raw response\n    if (json.calendars) {\n      for (const calId of Object.keys(json.calendars)) {\n        const calData = json.calendars[calId];\n\n        if (calData.errors?.length) {\n          apiError = {\n            type: 'CALENDAR_ERROR',\n            message: calData.errors[0]?.reason || 'Calendar error',\n            calendarId: calId\n          };\n          continue;\n        }\n\n        for (const slot of calData?.busy || []) {\n          if (slot.start && slot.end) {\n            const s = new Date(slot.start).getTime();\n            const e = new Date(slot.end).getTime();\n            if (s > 0 && e > s) {\n              busySlots.push({ start: slot.start, end: slot.end });\n            }\n          }\n        }\n      }\n    }\n    // Format 2: Simple busy array\n    else if (Array.isArray(json.busy)) {\n      for (const slot of json.busy) {\n        if (slot.start && slot.end) {\n          const s = new Date(slot.start).getTime();\n          const e = new Date(slot.end).getTime();\n          if (s > 0 && e > s) {\n            busySlots.push({ start: slot.start, end: slot.end });\n          }\n        }\n      }\n    }\n    // Format 3: FreeBusy empty response (calendar is genuinely free)\n    else if (json.timeMin && json.timeMax && !json.error) {\n      // OK â€” no busy slots, calendar is free\n    }\n  }\n\n  // â•â•â• PROPAGATE API ERRORS â•â•â•\n  if (apiError) {\n    console.log(`[Normalize ${SEDE}] Propagating API error â€” NOT assuming calendar is free`);\n    return [{\n      json: {\n        kind: 'busy',\n        sede: SEDE,\n        busy: [],\n        sourceStatus: 'API_ERROR',\n        error: true,\n        errorMessage: apiError.message,\n        errorDetails: apiError,\n        version: VERSION,\n        timestamp: new Date().toISOString()\n      }\n    }];\n  }\n\n  // â•â•â• SUCCESS OUTPUT â•â•â•\n  // Note: No merge logic here â€” Combine Busy handles interval merging\n  console.log(`[Normalize ${SEDE}] OK â€” ${busySlots.length} busy intervals`);\n\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE,\n      busy: busySlots,\n      sourceStatus: 'OK',\n      version: VERSION,\n      metrics: { intervals: busySlots.length },\n      timestamp: new Date().toISOString()\n    }\n  }];\n\n} catch (err) {\n  console.log(`[Normalize ${SEDE}] Exception: ${err.message}`);\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE,\n      busy: [],\n      sourceStatus: 'API_ERROR',\n      error: true,\n      errorMessage: `Exception: ${err.message}`,\n      version: VERSION,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "id": "8e1812ee-0141-46b0-97b7-1ef11a03d8a5",
      "name": "Normalize Busy POLANCO",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        416
      ],
      "notes": "v3.0: Detecta errores de API, NO asume calendario libre"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n/**\n * NORMALIZE_BUSY v4.0.0 â€” Unified & Clean\n * Sede: SATELITE\n * \n * Parses Google Calendar FreeBusy API response into standardized busy intervals.\n * Follows n8n-skills best practices:\n *   âœ… try/catch with error propagation\n *   âœ… Proper [{json:{}}] return format\n *   âœ… Null checks with optional chaining\n *   âœ… console.log debugging\n *   âœ… No merge logic (delegated to Combine Busy)\n */\n\nconst SEDE = 'SATELITE';\nconst VERSION = '4.0.0-UNIFIED';\n\ntry {\n  const items = $input.all();\n  const busySlots = [];\n  let apiError = null;\n\n  for (const item of items) {\n    const json = item.json;\n    if (!json) continue;\n\n    // â•â•â• API ERROR DETECTION â•â•â•\n    if (json.error) {\n      apiError = {\n        type: 'GOOGLE_API_ERROR',\n        message: json.error?.message || String(json.error),\n        code: json.error?.code || json.code\n      };\n      console.log(`[Normalize ${SEDE}] Google API error detected: ${apiError.message}`);\n      continue;\n    }\n\n    if (json.code && json.code >= 400) {\n      apiError = { type: 'HTTP_ERROR', message: `HTTP ${json.code}`, code: json.code };\n      continue;\n    }\n\n    if (Object.keys(json).length === 0) {\n      console.log(`[Normalize ${SEDE}] Empty object received (possible silent error)`);\n    }\n\n    // â•â•â• PARSE BUSY SLOTS â•â•â•\n\n    // Format 1: Google Calendar FreeBusy raw response\n    if (json.calendars) {\n      for (const calId of Object.keys(json.calendars)) {\n        const calData = json.calendars[calId];\n\n        if (calData.errors?.length) {\n          apiError = {\n            type: 'CALENDAR_ERROR',\n            message: calData.errors[0]?.reason || 'Calendar error',\n            calendarId: calId\n          };\n          continue;\n        }\n\n        for (const slot of calData?.busy || []) {\n          if (slot.start && slot.end) {\n            const s = new Date(slot.start).getTime();\n            const e = new Date(slot.end).getTime();\n            if (s > 0 && e > s) {\n              busySlots.push({ start: slot.start, end: slot.end });\n            }\n          }\n        }\n      }\n    }\n    // Format 2: Simple busy array\n    else if (Array.isArray(json.busy)) {\n      for (const slot of json.busy) {\n        if (slot.start && slot.end) {\n          const s = new Date(slot.start).getTime();\n          const e = new Date(slot.end).getTime();\n          if (s > 0 && e > s) {\n            busySlots.push({ start: slot.start, end: slot.end });\n          }\n        }\n      }\n    }\n    // Format 3: FreeBusy empty response (calendar is genuinely free)\n    else if (json.timeMin && json.timeMax && !json.error) {\n      // OK â€” no busy slots, calendar is free\n    }\n  }\n\n  // â•â•â• PROPAGATE API ERRORS â•â•â•\n  if (apiError) {\n    console.log(`[Normalize ${SEDE}] Propagating API error â€” NOT assuming calendar is free`);\n    return [{\n      json: {\n        kind: 'busy',\n        sede: SEDE,\n        busy: [],\n        sourceStatus: 'API_ERROR',\n        error: true,\n        errorMessage: apiError.message,\n        errorDetails: apiError,\n        version: VERSION,\n        timestamp: new Date().toISOString()\n      }\n    }];\n  }\n\n  // â•â•â• SUCCESS OUTPUT â•â•â•\n  // Note: No merge logic here â€” Combine Busy handles interval merging\n  console.log(`[Normalize ${SEDE}] OK â€” ${busySlots.length} busy intervals`);\n\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE,\n      busy: busySlots,\n      sourceStatus: 'OK',\n      version: VERSION,\n      metrics: { intervals: busySlots.length },\n      timestamp: new Date().toISOString()\n    }\n  }];\n\n} catch (err) {\n  console.log(`[Normalize ${SEDE}] Exception: ${err.message}`);\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE,\n      busy: [],\n      sourceStatus: 'API_ERROR',\n      error: true,\n      errorMessage: `Exception: ${err.message}`,\n      version: VERSION,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "id": "6b50006e-4388-4ec6-bbf3-4b750672ee87",
      "name": "Normalize Busy SATELITE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        608
      ],
      "notes": "v3.0: Detecta errores de API, NO asume calendario libre"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  sede,\n  horario_json,\n  calendar_id,\n  display_name,\n  direccion,\n  maps_url,\n  anchor_date,\n  anchor_week_type\nFROM public.sedes\nWHERE horario_json IS NOT NULL;\n",
        "options": {}
      },
      "id": "a0c54f6b-9bf8-43de-9319-7b636f4869a0",
      "name": "VERIFICAR HORARIOS DE SEDES",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        -1872,
        608
      ],
      "credentials": {
        "postgres": {
          "id": "LZyK5sbzVT7Dy3RU",
          "name": "Postgres urobot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * CARGAR_HORARIOS v4.0.0 â€” WEEK A/B VALIDATION\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * \n * CAMBIOS v4.0:\n * âœ… FIX #1: ValidaciÃ³n de anchor_date para semanas A/B\n * âœ… FIX #2: Warning si anchor_date estÃ¡ NULL pero hay alternancia\n * âœ… FIX #3: Preserva parÃ¡metros del trigger\n * âœ… FIX #4: Mejor estructura de metadatos por sede\n * \n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n */\n\nconst VERSION = '4.0.0-WEEK-VALIDATION';\nconst DEFAULT_TZ = 'America/Mexico_City';\nconst LOGS = [];\nconst DEBUG = true;\n\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'CARGAR_HORARIOS',\n    version: VERSION,\n    message,\n    ...data,\n  };\n  LOGS.push(entry);\n  if (DEBUG) {\n    console.log(`[${entry.level}] ${entry.component} :: ${entry.message}`, JSON.stringify(data));\n  }\n}\n\nconst isHHMM = (s) => {\n  if (typeof s !== 'string') return false;\n  const m = /^(\\d{2}):(\\d{2})$/.exec(s);\n  if (!m) return false;\n  const hh = +m[1];\n  const mm = +m[2];\n  return hh >= 0 && hh <= 23 && mm >= 0 && mm <= 59;\n};\n\nconst validateShift = (shift, sede, dow, ctx = {}) => {\n  if (!Array.isArray(shift) || shift.length < 2) {\n    log('error', 'Shift invÃ¡lido', { sede, dow, shift, ctx });\n    return false;\n  }\n  const [start, end, label] = shift;\n  if (!isHHMM(start) || !isHHMM(end)) return false;\n  \n  const toMin = (s) => {\n    const [h, m] = s.split(':').map(Number);\n    return h * 60 + m;\n  };\n  \n  return toMin(start) < toMin(end);\n};\n\nfunction detectWeekAlternation(horario) {\n  // Detecta si el horario usa semanas A/B\n  for (const dow of Object.keys(horario)) {\n    const dayConfig = horario[dow];\n    if (dayConfig && typeof dayConfig === 'object' && !Array.isArray(dayConfig)) {\n      if (dayConfig.A || dayConfig.B) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\ntry {\n  // Obtener parÃ¡metros del trigger\n  let triggerParams = {};\n  try {\n    const trigger = $('When Executed by Another Workflow').first();\n    if (trigger) triggerParams = trigger.json || {};\n  } catch {}\n  \n  // Obtener datos de sedes desde Postgres\n  const sedesData = $input.all().map(item => item.json);\n  \n  if (!sedesData || sedesData.length === 0) {\n    log('ERROR', 'No se encontraron sedes en la base de datos');\n    return [{\n      json: {\n        error: 'NO_SEDES_FOUND',\n        errorMessage: 'No se encontraron horarios configurados',\n        triggerParams,\n        _logs: LOGS\n      }\n    }];\n  }\n  \n  // Construir estructura SCHEDULE\n  const SCHEDULE = {\n    tz: DEFAULT_TZ,\n    version: VERSION,\n    sedes: {},\n    meta: {},\n    sedeInfo: {}\n  };\n  \n  const warnings = [];\n  \n  for (const row of sedesData) {\n    const sede = (row.sede || '').toUpperCase().trim();\n    if (!sede) continue;\n    \n    // Parsear horario_json\n    let horario = {};\n    try {\n      if (typeof row.horario_json === 'string') {\n        horario = JSON.parse(row.horario_json);\n      } else if (typeof row.horario_json === 'object') {\n        horario = row.horario_json;\n      }\n    } catch (err) {\n      log('ERROR', `Error parseando horario_json para ${sede}`, { error: err.message });\n      continue;\n    }\n    \n    SCHEDULE.sedes[sede] = horario;\n    \n    // â•â•â• VALIDACIÃ“N DE SEMANAS A/B â•â•â•\n    const hasWeekAlternation = detectWeekAlternation(horario);\n    const hasAnchorDate = !!row.anchor_date;\n    const hasAnchorWeekType = !!row.anchor_week_type;\n    \n    if (hasWeekAlternation && (!hasAnchorDate || !hasAnchorWeekType)) {\n      const warning = {\n        sede,\n        issue: 'MISSING_ANCHOR_CONFIG',\n        message: `Sede ${sede} tiene horarios A/B pero falta anchor_date (${hasAnchorDate}) o anchor_week_type (${hasAnchorWeekType})`,\n        impact: 'Se mostrarÃ¡n horarios de AMBAS semanas (fallback)'\n      };\n      warnings.push(warning);\n      log('WARN', warning.message);\n    }\n    \n    // Metadatos de la sede\n    SCHEDULE.meta[sede] = {\n      hasWeekAlternation,\n      anchorDate: row.anchor_date || null,\n      anchorWeekType: row.anchor_week_type || null,\n      anchorValid: hasWeekAlternation ? (hasAnchorDate && hasAnchorWeekType) : true,\n      calendarId: row.calendar_id,\n      workingDays: Object.keys(horario).map(k => parseInt(k)).filter(k => !isNaN(k))\n    };\n    \n    // Info de sede para respuestas\n    SCHEDULE.sedeInfo[sede] = {\n      displayName: row.display_name || sede,\n      direccion: row.direccion || '',\n      mapsUrl: row.maps_url || '',\n      calendarId: row.calendar_id\n    };\n  }\n  \n  // Guardar en static data para uso global\n  try {\n    $getWorkflowStaticData('global').SCHEDULE = SCHEDULE;\n  } catch (err) {\n    log('WARN', 'No se pudo guardar SCHEDULE en static data', { error: err.message });\n  }\n  \n  log('SUCCESS', `SCHEDULE cargado: ${Object.keys(SCHEDULE.sedes).length} sedes`, {\n    sedes: Object.keys(SCHEDULE.sedes),\n    warnings: warnings.length\n  });\n  \n  return [{\n    json: {\n      SCHEDULE,\n      triggerParams,\n      warnings: warnings.length > 0 ? warnings : undefined,\n      version: VERSION,\n      _logs: DEBUG ? LOGS : undefined\n    }\n  }];\n  \n} catch (err) {\n  log('ERROR', err.message, { stack: err.stack });\n  return [{\n    json: {\n      error: 'CARGAR_HORARIOS_FAIL',\n      errorMessage: err.message,\n      _logs: LOGS\n    }\n  }];\n}"
      },
      "id": "3e54fbe2-b24c-4752-9917-5713af13a4ed",
      "name": "CARGAR_HORARIOS1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1648,
        608
      ],
      "notes": "v4.0: ValidaciÃ³n de anchor_date para semanas A/B"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * SET_DEFAULTS v13.0.0 â€” FIX COMPLETO: ESPAÃ‘OL + LATE NIGHT + ROBUSTEZ\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * \n * CAMBIOS v13.0:\n * âœ… FIX #1: NormalizaciÃ³n espaÃ±ol â†’ inglÃ©s (maÃ±ana â†’ tomorrow)\n * âœ… FIX #2: DetecciÃ³n de horario tardÃ­o (>10 PM expande a maÃ±ana)\n * âœ… FIX #3: Soporte para \"pasado_maÃ±ana\"\n * âœ… FIX #4: Mejor manejo de dÃ­as de la semana en espaÃ±ol\n * âœ… FIX #5: Logging mejorado para debugging\n * \n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n */\n\nconst VERSION = '13.0.0-SPANISH-FIX';\n\n/* ===================== CONFIGURACIÃ“N ===================== */\nconst CONFIG = Object.freeze({\n  TZ: 'America/Mexico_City',\n  ISO_OFFSET: '-06:00',\n  DEFAULT_WINDOW_DAYS: 14,\n  VALID_SEDES: ['POLANCO', 'SATELITE'],\n  LATE_NIGHT_HOUR: 22, // Si son mÃ¡s de las 10 PM, expandir ventana\n  \n  // Mapeo de intenciones espaÃ±ol â†’ inglÃ©s\n  INTENT_ALIASES: {\n    // EspaÃ±ol directo\n    'maÃ±ana': 'tomorrow',\n    'manana': 'tomorrow',\n    'hoy': 'today',\n    'pasado maÃ±ana': 'day_after_tomorrow',\n    'pasado manana': 'day_after_tomorrow',\n    'pasado_maÃ±ana': 'day_after_tomorrow',\n    'pasado_manana': 'day_after_tomorrow',\n    'esta semana': 'this_week',\n    'esta_semana': 'this_week',\n    'proxima semana': 'next_week',\n    'prÃ³xima semana': 'next_week',\n    'la proxima semana': 'next_week',\n    'la prÃ³xima semana': 'next_week',\n    // InglÃ©s (por si llegan asÃ­)\n    'today': 'today',\n    'tomorrow': 'tomorrow',\n    'this_week': 'this_week',\n    'next_week': 'next_week',\n    'specific': 'specific'\n  },\n  \n  // Mapeo de nombres de sedes\n  SEDE_ALIASES: {\n    'POLANCO': 'POLANCO', \n    'POLNACO': 'POLANCO', \n    'ANGELES': 'POLANCO',\n    'SANTA MONICA': 'POLANCO',\n    'SANTAMONICA': 'POLANCO',\n    'SATELITE': 'SATELITE', \n    'SATELLITE': 'SATELITE', \n    'SANANGEL': 'SATELITE', \n    'SAN ANGEL': 'SATELITE',\n    'NAUCALPAN': 'SATELITE',\n    'SAMARA': 'SATELITE'\n  },\n  \n  // DÃ­as de la semana en espaÃ±ol â†’ nÃºmero (0=Dom, 6=Sab)\n  DIAS_SEMANA: {\n    'domingo': 0, 'dom': 0,\n    'lunes': 1, 'lun': 1,\n    'martes': 2, 'mar': 2,\n    'miercoles': 3, 'miÃ©rcoles': 3, 'mie': 3,\n    'jueves': 4, 'jue': 4,\n    'viernes': 5, 'vie': 5,\n    'sabado': 6, 'sÃ¡bado': 6, 'sab': 6\n  },\n  \n  TRIGGER_NODE_NAMES: [\n    'When Executed by Another Workflow', \n    'Execute Workflow Trigger', \n    'Trigger', \n    'Start', \n    'Webhook'\n  ]\n});\n\n/* ===================== UTILIDADES DE FECHA ===================== */\n\nfunction getLocalParts(date, tz) {\n  try {\n    const formatter = new Intl.DateTimeFormat('en-CA', {\n      timeZone: tz,\n      year: 'numeric', month: '2-digit', day: '2-digit',\n      hour: '2-digit', minute: '2-digit', hour12: false\n    });\n    const parts = formatter.formatToParts(date);\n    const obj = {};\n    for (const p of parts) obj[p.type] = p.value;\n    return { y: +obj.year, m: +obj.month, d: +obj.day, hh: +obj.hour, mm: +obj.minute };\n  } catch (e) {\n    const d = new Date(date);\n    return { y: d.getFullYear(), m: d.getMonth() + 1, d: d.getDate(), hh: d.getHours(), mm: d.getMinutes() };\n  }\n}\n\nfunction getTodayYMD(tz) {\n  const p = getLocalParts(new Date(), tz);\n  return `${p.y}-${String(p.m).padStart(2, '0')}-${String(p.d).padStart(2, '0')}`;\n}\n\nfunction getLocalHour(tz) {\n  const p = getLocalParts(new Date(), tz);\n  return p.hh;\n}\n\nfunction addDaysToYMD(ymd, days) {\n  const [y, m, d] = ymd.split('-').map(Number);\n  const date = new Date(Date.UTC(y, m - 1, d, 12, 0, 0));\n  date.setUTCDate(date.getUTCDate() + days);\n  return `${date.getUTCFullYear()}-${String(date.getUTCMonth() + 1).padStart(2, '0')}-${String(date.getUTCDate()).padStart(2, '0')}`;\n}\n\nfunction getLocalDOW(tz) {\n  const p = getLocalParts(new Date(), tz);\n  const d = new Date(p.y, p.m - 1, p.d);\n  return d.getDay(); // 0=Dom, 6=Sab\n}\n\n/* ===================== NORMALIZACIÃ“N ===================== */\n\nfunction normalizeIntent(rawIntent) {\n  if (!rawIntent || typeof rawIntent !== 'string') return 'today';\n  \n  let intent = rawIntent.toLowerCase().trim();\n  \n  // Quitar caracteres extraÃ±os\n  intent = intent.replace(/[\\n\\r\\t]/g, '').trim();\n  \n  // Buscar en aliases directos\n  if (CONFIG.INTENT_ALIASES[intent]) {\n    return CONFIG.INTENT_ALIASES[intent];\n  }\n  \n  // Buscar dÃ­a de la semana\n  for (const [dia, dow] of Object.entries(CONFIG.DIAS_SEMANA)) {\n    if (intent.includes(dia)) {\n      return dia; // Retornar el dÃ­a encontrado\n    }\n  }\n  \n  // Si no se reconoce, retornar como estÃ¡ (puede ser \"specific\" u otro)\n  return intent;\n}\n\nfunction normalizeSede(input) {\n  if (!input || typeof input !== 'string') return null;\n  \n  // Limpiar: quitar acentos, espacios extras, caracteres raros\n  let cleaned = input\n    .toUpperCase()\n    .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') // Quitar acentos\n    .replace(/[\\n\\r\\t]/g, '')\n    .replace(/[^A-Z\\s]/g, '')\n    .trim();\n  \n  // Buscar en aliases\n  if (CONFIG.SEDE_ALIASES[cleaned]) return CONFIG.SEDE_ALIASES[cleaned];\n  \n  // Buscar coincidencia parcial\n  for (const [alias, sede] of Object.entries(CONFIG.SEDE_ALIASES)) {\n    if (cleaned.includes(alias) || alias.includes(cleaned)) {\n      return sede;\n    }\n  }\n  \n  return CONFIG.VALID_SEDES.includes(cleaned) ? cleaned : null;\n}\n\n/* ===================== LÃ“GICA PRINCIPAL ===================== */\n\ntry {\n  const TZ = CONFIG.TZ;\n  const LOGS = [];\n  \n  // 1. Recopilar Inputs\n  let params = {};\n  \n  for (const nodeName of CONFIG.TRIGGER_NODE_NAMES) {\n    try {\n      const triggerNode = $(nodeName).first();\n      if (triggerNode?.json) params = { ...params, ...triggerNode.json };\n    } catch {}\n  }\n  \n  try {\n    const input = $input.first()?.json;\n    if (input) params = { ...params, ...input };\n  } catch {}\n  \n  // 2. Extraer y normalizar variables\n  const rawDateIntent = params.dateIntent || 'today';\n  const dateIntent = normalizeIntent(rawDateIntent);\n  const specificDate = (params.specificDate || '').trim();\n  const rawSede = params.sedePreferida || '';\n  const sedePreferida = normalizeSede(rawSede);\n  \n  // Booleanos robustos\n  const onlyMorning = params.onlyMorning === true || params.onlyMorning === 'true';\n  const onlyAfternoon = params.onlyAfternoon === true || params.onlyAfternoon === 'true';\n  \n  LOGS.push(`Raw dateIntent: \"${rawDateIntent}\" â†’ Normalized: \"${dateIntent}\"`);\n  LOGS.push(`Raw sede: \"${rawSede}\" â†’ Normalized: \"${sedePreferida}\"`);\n  \n  // 3. Calcular Ventana de Tiempo\n  const todayYMD = getTodayYMD(TZ);\n  const currentHour = getLocalHour(TZ);\n  const currentDOW = getLocalDOW(TZ);\n  \n  let startYMD = todayYMD;\n  let endYMD = todayYMD;\n  let isToday = false;\n  let isTomorrow = false;\n  let expandedDueToLateNight = false;\n\n  switch (dateIntent) {\n    case 'tomorrow':\n      startYMD = addDaysToYMD(todayYMD, 1);\n      endYMD = startYMD;\n      isTomorrow = true;\n      break;\n\n    case 'day_after_tomorrow':\n      startYMD = addDaysToYMD(todayYMD, 2);\n      endYMD = startYMD;\n      break;\n\n    case 'today':\n      startYMD = todayYMD;\n      endYMD = todayYMD;\n      isToday = true;\n      \n      // ğŸ”¥ FIX: Si es muy tarde (despuÃ©s de las 10 PM), expandir a maÃ±ana\n      if (currentHour >= CONFIG.LATE_NIGHT_HOUR) {\n        endYMD = addDaysToYMD(todayYMD, 1);\n        expandedDueToLateNight = true;\n        LOGS.push(`âš ï¸ Late night (${currentHour}h) - expandiendo ventana a maÃ±ana`);\n      }\n      break;\n\n    case 'specific':\n      if (specificDate && /^\\d{4}-\\d{2}-\\d{2}$/.test(specificDate)) {\n        startYMD = specificDate;\n        endYMD = specificDate;\n        isToday = (specificDate === todayYMD);\n        isTomorrow = (specificDate === addDaysToYMD(todayYMD, 1));\n      } else {\n        // Fecha invÃ¡lida, usar hoy\n        LOGS.push(`âš ï¸ specificDate invÃ¡lido: \"${specificDate}\", usando hoy`);\n      }\n      break;\n      \n    case 'this_week':\n      // Desde hoy hasta el domingo\n      const daysToSunday = (7 - currentDOW) % 7 || 7;\n      endYMD = addDaysToYMD(todayYMD, daysToSunday);\n      break;\n\n    case 'next_week':\n      // PrÃ³ximo lunes a domingo\n      const daysToNextMon = (8 - currentDOW) % 7 || 7;\n      startYMD = addDaysToYMD(todayYMD, daysToNextMon);\n      endYMD = addDaysToYMD(startYMD, 6);\n      break;\n\n    default:\n      // Buscar si es un dÃ­a de la semana\n      let targetDOW = CONFIG.DIAS_SEMANA[dateIntent];\n      \n      if (targetDOW !== undefined) {\n        // Calcular dÃ­as hasta ese dÃ­a\n        let daysAdd = (targetDOW - currentDOW + 7) % 7;\n        \n        // Si es hoy y ya es tarde, o si daysAdd=0, ir al prÃ³ximo\n        if (daysAdd === 0) {\n          if (currentHour >= CONFIG.LATE_NIGHT_HOUR) {\n            daysAdd = 7; // PrÃ³xima semana\n          }\n          // Si no es tarde, daysAdd=0 significa hoy (el mismo dÃ­a)\n        }\n        \n        startYMD = addDaysToYMD(todayYMD, daysAdd);\n        endYMD = startYMD;\n        isToday = (daysAdd === 0);\n        LOGS.push(`DÃ­a \"${dateIntent}\" â†’ DOW ${targetDOW} â†’ +${daysAdd} dÃ­as â†’ ${startYMD}`);\n      } else {\n        // No reconocido, usar prÃ³ximos 14 dÃ­as\n        LOGS.push(`âš ï¸ dateIntent no reconocido: \"${dateIntent}\", usando 14 dÃ­as`);\n        endYMD = addDaysToYMD(todayYMD, CONFIG.DEFAULT_WINDOW_DAYS);\n      }\n  }\n\n  // 4. Construir ISO con Offset Fijo de CDMX\n  const isoStart = `${startYMD}T00:00:00.000${CONFIG.ISO_OFFSET}`;\n  const isoEnd = `${endYMD}T23:59:59.999${CONFIG.ISO_OFFSET}`;\n\n  // Log final\n  LOGS.push(`Window: ${isoStart} â†’ ${isoEnd}`);\n  console.log(`[SET_DEFAULTS v${VERSION}]\\n${LOGS.join('\\n')}`);\n\n  return [{\n    json: {\n      requestId: `disp-${Date.now()}`,\n      version: VERSION,\n      tz: TZ,\n      \n      // Fechas corregidas\n      windowStart: isoStart,\n      windowEnd: isoEnd,\n      \n      // Metadatos\n      dateIntent: dateIntent,\n      dateIntentOriginal: rawDateIntent,\n      specificDate: specificDate || null,\n      isToday,\n      isTomorrow,\n      expandedDueToLateNight,\n      \n      // Filtros\n      sedePreferida,\n      sedes: sedePreferida ? [sedePreferida] : CONFIG.VALID_SEDES,\n      onlyMorning,\n      onlyAfternoon,\n      \n      // ConfiguraciÃ³n\n      slotMinutes: 30,\n      shortNoticeMin: 120,\n      maxResults: 50,\n      \n      // Debug\n      _debug: {\n        currentHour,\n        currentDOW,\n        todayYMD,\n        logs: LOGS\n      },\n      \n      timestamp: new Date().toISOString()\n    }\n  }];\n\n} catch (err) {\n  console.error(`[SET_DEFAULTS ERROR] ${err.message}`);\n  return [{\n    json: {\n      error: 'SET_DEFAULTS_CRITICAL_FAIL',\n      errorMessage: err.message,\n      version: VERSION,\n      windowStart: new Date().toISOString(),\n      windowEnd: new Date(Date.now() + 86400000 * 7).toISOString(),\n      tz: 'America/Mexico_City',\n      sedes: ['POLANCO', 'SATELITE'],\n      slotMinutes: 30,\n      shortNoticeMin: 120,\n      maxResults: 50\n    }\n  }];\n}"
      },
      "id": "f50dfea6-01de-43be-ad2e-6142138976a3",
      "name": "SET_DEFAULTS1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1424,
        608
      ],
      "notes": "v11.0: Mejor normalizaciÃ³n de sede, soporte onlyMorning/Afternoon"
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "9d46a1bfb10a8ffd429f8e8671c16bdb57104073ccccea2a31117354df51ff67@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Agenda Dr. Mario Martinez Thomas"
        },
        "timeMin": "={{$('SET_DEFAULTS1').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS1').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "f59dbcfe-4858-478c-8bb0-f66c09c5c204",
      "name": "Availability - SATELITE1",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -976,
        800
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "RzMlWUma86JGl9rZ",
          "name": "Google Calendar account"
        }
      },
      "notes": "v2.0: continueOnFail activo pero Normalize detecta errores"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n/**\n * NORMALIZE_BUSY v4.0.0 â€” Unified & Clean\n * Sede: PERSONAL\n * \n * Parses Google Calendar FreeBusy API response into standardized busy intervals.\n * Follows n8n-skills best practices:\n *   âœ… try/catch with error propagation\n *   âœ… Proper [{json:{}}] return format\n *   âœ… Null checks with optional chaining\n *   âœ… console.log debugging\n *   âœ… No merge logic (delegated to Combine Busy)\n */\n\nconst SEDE = 'PERSONAL';\nconst VERSION = '4.0.0-UNIFIED';\n\ntry {\n  const items = $input.all();\n  const busySlots = [];\n  let apiError = null;\n\n  for (const item of items) {\n    const json = item.json;\n    if (!json) continue;\n\n    // â•â•â• API ERROR DETECTION â•â•â•\n    if (json.error) {\n      apiError = {\n        type: 'GOOGLE_API_ERROR',\n        message: json.error?.message || String(json.error),\n        code: json.error?.code || json.code\n      };\n      console.log(`[Normalize ${SEDE}] Google API error detected: ${apiError.message}`);\n      continue;\n    }\n\n    if (json.code && json.code >= 400) {\n      apiError = { type: 'HTTP_ERROR', message: `HTTP ${json.code}`, code: json.code };\n      continue;\n    }\n\n    if (Object.keys(json).length === 0) {\n      console.log(`[Normalize ${SEDE}] Empty object received (possible silent error)`);\n    }\n\n    // â•â•â• PARSE BUSY SLOTS â•â•â•\n\n    // Format 1: Google Calendar FreeBusy raw response\n    if (json.calendars) {\n      for (const calId of Object.keys(json.calendars)) {\n        const calData = json.calendars[calId];\n\n        if (calData.errors?.length) {\n          apiError = {\n            type: 'CALENDAR_ERROR',\n            message: calData.errors[0]?.reason || 'Calendar error',\n            calendarId: calId\n          };\n          continue;\n        }\n\n        for (const slot of calData?.busy || []) {\n          if (slot.start && slot.end) {\n            const s = new Date(slot.start).getTime();\n            const e = new Date(slot.end).getTime();\n            if (s > 0 && e > s) {\n              busySlots.push({ start: slot.start, end: slot.end });\n            }\n          }\n        }\n      }\n    }\n    // Format 2: Simple busy array\n    else if (Array.isArray(json.busy)) {\n      for (const slot of json.busy) {\n        if (slot.start && slot.end) {\n          const s = new Date(slot.start).getTime();\n          const e = new Date(slot.end).getTime();\n          if (s > 0 && e > s) {\n            busySlots.push({ start: slot.start, end: slot.end });\n          }\n        }\n      }\n    }\n    // Format 3: FreeBusy empty response (calendar is genuinely free)\n    else if (json.timeMin && json.timeMax && !json.error) {\n      // OK â€” no busy slots, calendar is free\n    }\n  }\n\n  // â•â•â• PROPAGATE API ERRORS â•â•â•\n  if (apiError) {\n    console.log(`[Normalize ${SEDE}] Propagating API error â€” NOT assuming calendar is free`);\n    return [{\n      json: {\n        kind: 'busy',\n        sede: SEDE,\n        busy: [],\n        sourceStatus: 'API_ERROR',\n        error: true,\n        errorMessage: apiError.message,\n        errorDetails: apiError,\n        version: VERSION,\n        timestamp: new Date().toISOString()\n      }\n    }];\n  }\n\n  // â•â•â• SUCCESS OUTPUT â•â•â•\n  // Note: No merge logic here â€” Combine Busy handles interval merging\n  console.log(`[Normalize ${SEDE}] OK â€” ${busySlots.length} busy intervals`);\n\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE,\n      busy: busySlots,\n      sourceStatus: 'OK',\n      version: VERSION,\n      metrics: { intervals: busySlots.length },\n      timestamp: new Date().toISOString()\n    }\n  }];\n\n} catch (err) {\n  console.log(`[Normalize ${SEDE}] Exception: ${err.message}`);\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE,\n      busy: [],\n      sourceStatus: 'API_ERROR',\n      error: true,\n      errorMessage: `Exception: ${err.message}`,\n      version: VERSION,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "id": "edc77cf3-8faa-4f1f-969c-288ef2fc284a",
      "name": "Normalize Busy PERSONAL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -752,
        800
      ],
      "notes": "v3.0: Detecta errores de API, NO asume calendario libre"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n/**\n * BUILD_RESPONSE v33.0.0 â€” n8n-skills Optimized\n * \n * Changes:\n *   âœ… P2: WORKING_DAYS derived from $getWorkflowStaticData (no hardcoding)\n *   âœ… P3: Uses Luxon DateTime for all date formatting\n *   âœ… P5: console.log debugging throughout\n */\n\nconst VERSION = '33.0.0-SKILLS-OPTIMIZED';\n\n/* ===================== CONFIG ===================== */\nconst CONFIG = {\n  MAX_SLOTS_TO_SHOW: 30,\n  MAX_DAYS_TO_SHOW: 5,\n  TZ_DEFAULT: 'America/Mexico_City',\n\n  MESSAGES: {\n    API_ERROR: \"Tuve un pequeÃ±o problema tÃ©cnico consultando la agenda. Â¿Me permites intentarlo de nuevo?\",\n    SUNDAY_OFF: \"Hoy domingo descansamos en ambas sedes. ğŸ˜Š Pero puedo buscarte los horarios mÃ¡s prÃ³ximos para iniciar la semana. Â¿Te parece bien?\",\n    WRONG_DAY_SEDE: \"En *{sede}* las consultas son los *{dias}*. Para hoy no hay servicio ahÃ­, pero Â¿te gustarÃ­a ver disponibilidad para el prÃ³ximo dÃ­a abierto?\",\n    NO_SLOTS_TODAY: \"Para hoy la agenda en *{sede}* ya estÃ¡ llena (o requerimos un poco mÃ¡s de anticipaciÃ³n). Â¿Te busco algo para maÃ±ana?\",\n    GENERIC_NO_SLOTS: \"No encontrÃ© espacios disponibles para hoy. Recuerda que Polanco atiende Lun/Mar/Vie y SatÃ©lite MiÃ©/Jue/SÃ¡b. Â¿Busco opciones para maÃ±ana?\",\n    INTRO: [\"AquÃ­ tienes los horarios disponibles:\", \"EncontrÃ© estas opciones para ti:\"],\n    ASK: [\"Â¿CuÃ¡l te acomoda mejor?\", \"Â¿Te gustarÃ­a reservar alguno?\"]\n  }\n};\n\n/* ===================== P2: DYNAMIC WORKING DAYS ===================== */\nfunction getWorkingDays() {\n  // Try to read from workflow static data (populated by CARGAR_HORARIOS)\n  try {\n    const store = $getWorkflowStaticData('global');\n    if (store?.SCHEDULE?.sedes) {\n      const result = {};\n      for (const [sede, schedule] of Object.entries(store.SCHEDULE.sedes)) {\n        const days = Object.keys(schedule)\n          .map(Number)\n          .filter(d => !isNaN(d));\n        result[sede] = days;\n      }\n      if (Object.keys(result).length > 0) {\n        console.log(`[Build Response] Working days from SCHEDULE: ${JSON.stringify(result)}`);\n        return result;\n      }\n    }\n  } catch (e) {\n    console.log(`[Build Response] Could not load SCHEDULE static data: ${e.message}`);\n  }\n\n  // Fallback: derive from allowedSlots\n  try {\n    const gate = $('SCHEDULE_GATE').first()?.json;\n    if (gate?.allowedSlots?.length) {\n      const result = {};\n      for (const slot of gate.allowedSlots) {\n        if (!slot?.sede || !slot?.start) continue;\n        const dow = DateTime.fromISO(slot.start).setZone(CONFIG.TZ_DEFAULT).weekday % 7;\n        if (!result[slot.sede]) result[slot.sede] = new Set();\n        result[slot.sede].add(dow);\n      }\n      const final = {};\n      for (const [sede, days] of Object.entries(result)) {\n        final[sede] = [...days].sort();\n      }\n      console.log(`[Build Response] Working days from slots: ${JSON.stringify(final)}`);\n      return final;\n    }\n  } catch (e) {\n    console.log(`[Build Response] Fallback slot derivation failed: ${e.message}`);\n  }\n\n  // Last resort fallback\n  console.log('[Build Response] Using hardcoded fallback for working days');\n  return { POLANCO: [1, 2, 5], SATELITE: [3, 4, 6] };\n}\n\nfunction getWorkingDaysText(sede, workingDays) {\n  const dayNames = ['domingo', 'lunes', 'martes', 'miÃ©rcoles', 'jueves', 'viernes', 'sÃ¡bado'];\n  const days = workingDays[sede];\n  if (!days || !days.length) return 'dÃ­as hÃ¡biles';\n  return days.map(d => dayNames[d] || '?').join(', ');\n}\n\n/* ===================== P3: LUXON HELPERS ===================== */\nfunction formatSedeName(sede) {\n  return { 'POLANCO': 'Polanco', 'SATELITE': 'SatÃ©lite' }[sede] || sede;\n}\n\nfunction randomChoice(arr) {\n  return Array.isArray(arr) ? arr[Math.floor(Math.random() * arr.length)] : arr;\n}\n\nfunction formatTime(iso, tz) {\n  try {\n    return DateTime.fromISO(iso).setZone(tz)\n      .toFormat(\"h:mm a\").toLowerCase().replace(' ', '');\n  } catch {\n    return iso?.substring(11, 16) || '??:??';\n  }\n}\n\nfunction formatDate(iso, tz) {\n  try {\n    const dt = DateTime.fromISO(iso).setZone(tz).setLocale('es-MX');\n    const weekday = dt.toFormat('cccc');\n    const dayMonth = dt.toFormat(\"d 'de' LLLL\");\n    return `${weekday.charAt(0).toUpperCase() + weekday.slice(1)}, ${dayMonth}`;\n  } catch {\n    return iso?.split('T')[0] || '';\n  }\n}\n\n/* ===================== MAIN ===================== */\ntry {\n  const startTime = Date.now();\n  const items = $input.all();\n  const inputData = items[0]?.json || {};\n  let ctx = {};\n  try { ctx = $('SET_DEFAULTS1').first()?.json || {}; } catch {}\n\n  const TZ = ctx.tz || CONFIG.TZ_DEFAULT;\n  const isToday = ctx.isToday !== undefined ? ctx.isToday : false;\n\n  console.log(`[Build Response] Input kind: ${inputData.kind}, slots: ${inputData.allowedSlots?.length || 0}, isToday: ${isToday}`);\n\n  // â•â•â• ERROR PROPAGATION â•â•â•\n  if (inputData.error) {\n    console.log(`[Build Response] Error propagated: ${inputData.errorMessage}`);\n    return [{ json: { status: 'error', suggestedResponse: CONFIG.MESSAGES.API_ERROR, error: inputData.errorMessage } }];\n  }\n\n  let slots = inputData.allowedSlots || inputData.scheduleGate?.allowedSlots || [];\n  if (inputData.kind === 'avail' && inputData.allowedSlots) slots = inputData.allowedSlots;\n\n  // â•â•â• NO SLOTS RESPONSE â•â•â•\n  if (!slots.length) {\n    const WORKING_DAYS = getWorkingDays();\n    let msg = CONFIG.MESSAGES.GENERIC_NO_SLOTS;\n\n    if (isToday) {\n      const now = DateTime.now().setZone(TZ);\n      const currentDOW = now.weekday % 7; // 0=Sun for compat\n\n      if (currentDOW === 0) {\n        msg = CONFIG.MESSAGES.SUNDAY_OFF;\n      } else {\n        const sedeKey = (ctx.sedePreferida || '').toUpperCase();\n        if (sedeKey && WORKING_DAYS[sedeKey]) {\n          const opensToday = WORKING_DAYS[sedeKey].includes(currentDOW);\n          if (!opensToday) {\n            msg = CONFIG.MESSAGES.WRONG_DAY_SEDE\n              .replace('{sede}', formatSedeName(sedeKey))\n              .replace('{dias}', getWorkingDaysText(sedeKey, WORKING_DAYS));\n          } else {\n            msg = CONFIG.MESSAGES.NO_SLOTS_TODAY.replace('{sede}', formatSedeName(sedeKey));\n          }\n        }\n      }\n    } else {\n      msg = \"No encontrÃ© horarios disponibles para esa fecha en particular. Â¿Te gustarÃ­a ver opciones cercanas?\";\n    }\n\n    console.log(`[Build Response] No slots â€” response type: ${isToday ? 'today' : 'future'}`);\n    return [{ json: { status: 'no_availability', suggestedResponse: msg, ctx } }];\n  }\n\n  // â•â•â• FORMAT SLOTS INTO RESPONSE â•â•â•\n  const grouped = {};\n  const order = [];\n\n  slots.forEach(slot => {\n    const dateVisual = slot.dateFormatted || formatDate(slot.start, TZ);\n    const key = `${dateVisual}|${slot.sede}`;\n\n    if (!grouped[key]) {\n      grouped[key] = { dateFmt: dateVisual, sede: slot.sede, slots: [] };\n      order.push(key);\n    }\n    grouped[key].slots.push(slot);\n  });\n\n  let responseText = randomChoice(CONFIG.MESSAGES.INTRO) + '\\n';\n  let slotsForBooking = [];\n  let shownCount = 0;\n\n  const keysToShow = order.slice(0, CONFIG.MAX_DAYS_TO_SHOW);\n\n  keysToShow.forEach(key => {\n    const group = grouped[key];\n    responseText += `\\nğŸ“… *${group.dateFmt}* | ğŸ“ ${formatSedeName(group.sede)}\\n`;\n\n    group.slots.forEach(slot => {\n      if (shownCount >= CONFIG.MAX_SLOTS_TO_SHOW) return;\n      const timeStr = formatTime(slot.start, TZ);\n      responseText += `â€¢ ${timeStr}\\n`;\n      slotsForBooking.push({\n        id: slot.id,\n        displayTime: timeStr,\n        slotData: { start: slot.start, end: slot.end, sede: slot.sede }\n      });\n      shownCount++;\n    });\n  });\n\n  if (slots.length > shownCount) responseText += '\\n(Hay mÃ¡s opciones disponibles...)';\n  responseText += '\\n' + randomChoice(CONFIG.MESSAGES.ASK);\n\n  console.log(`[Build Response] Success â€” ${shownCount} slots shown, ${order.length} groups`);\n\n  return [{\n    json: {\n      status: 'success',\n      suggestedResponse: responseText.trim(),\n      allowedSlots: slots,\n      slotsForBooking,\n      ctx,\n      version: VERSION,\n      metrics: { shownSlots: shownCount, totalSlots: slots.length, executionMs: Date.now() - startTime }\n    }\n  }];\n\n} catch (err) {\n  console.log(`[Build Response] Exception: ${err.message}`);\n  return [{ json: { status: 'error', suggestedResponse: \"Tuve un problema tÃ©cnico. Â¿Intentamos de nuevo?\", error: err.message } }];\n}"
      },
      "id": "e97e59fe-c5e7-48e0-a0d9-451a4ebaef8f",
      "name": "Build Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        608
      ],
      "notes": "v27.0: Manejo completo de errores, mensajes SHORT_NOTICE, mÃ¡s slots"
    }
  ],
  "pinData": {},
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "VERIFICAR HORARIOS DE SEDES",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - POLANCO": {
      "main": [
        [
          {
            "node": "Normalize Busy POLANCO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - SATELITE": {
      "main": [
        [
          {
            "node": "Normalize Busy SATELITE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Busy (append)1": {
      "main": [
        [
          {
            "node": "Combine Busy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Busy": {
      "main": [
        [
          {
            "node": "Calc Availability",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calc Availability": {
      "main": [
        [
          {
            "node": "Build Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SCHEDULE_GATE": {
      "main": [
        [
          {
            "node": "Availability - SATELITE1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Availability - SATELITE",
            "type": "main",
            "index": 0
          },
          {
            "node": "Availability - POLANCO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy POLANCO": {
      "main": [
        [
          {
            "node": "Merge Busy (append)1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy SATELITE": {
      "main": [
        [
          {
            "node": "Merge Busy (append)1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "VERIFICAR HORARIOS DE SEDES": {
      "main": [
        [
          {
            "node": "CARGAR_HORARIOS1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CARGAR_HORARIOS1": {
      "main": [
        [
          {
            "node": "SET_DEFAULTS1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SET_DEFAULTS1": {
      "main": [
        [
          {
            "node": "SCHEDULE_GATE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - SATELITE1": {
      "main": [
        [
          {
            "node": "Normalize Busy PERSONAL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy PERSONAL": {
      "main": [
        [
          {
            "node": "Merge Busy (append)1",
            "type": "main",
            "index": 2
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/Mexico_City",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "271aa5b7-9dd5-48a8-aeb7-0eab1a80447a",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "8c33c5b047d489bd000bdf4aabe6e4981a2da591f7a11d61031348a2fe3ef66c"
  },
  "id": "9mpErXIgA9uOnzrE",
  "tags": []
}