{
  "name": "DISPONIBILIDAD_CALENDARIO",
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"desiredStart\": \"{{ $now.setZone('America/Mexico_City').toISO() }}\",\n  \"userText\": \"\",\n  \"sedePreferida\": \"\",\n  \"timezone\": \"America/Mexico_City\",\n  \"windowDays\": 14,\n  \"maxResults\": 50,\n  \"includeWeekends\": true,\n  \"onlyMorning\": false,\n  \"onlyAfternoon\": false,\n  \"requestId\": \"{{ $now.toMillis() }}-{{ Math.random().toString(36).substr(2, 9) }}\",\n  \"source\": \"urobot_whatsapp\"\n}\n"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1616,
        2000
      ],
      "id": "e53bb710-ba5a-4a11-89db-0163cc2ab94b",
      "name": "When Executed by Another Workflow",
      "retryOnFail": true
    },
    {
      "parameters": {
        "jsCode": "/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * BUILD RESPONSE v17.0 - EDICIÃ“N DEFINITIVA ğŸ›¡ï¸âœ¨\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * \n * Combina:\n * - Robustez y validaciones exhaustivas de v16.0\n * - UX mejorada con formato 12h y ordenamiento\n * - Mensaje WhatsApp determinÃ­stico y profesional\n * - Mejores prÃ¡cticas de n8n (pairedItem)\n * \n * Autor: Sistema optimizado\n * Fecha: Octubre 2025\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n */\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// CONFIGURACIÃ“N Y CONSTANTES\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst VERSION = '17.0.0';\nconst DEBUG = true;\n\nconst LIMITS = {\n  MAX_SLOTS_PER_DAY: 20,\n  MAX_BACKUP_DAYS: 5,\n  MAX_TOTAL_SLOTS: 100,\n  MIN_SLOT_DURATION: 15,\n  MAX_SLOT_DURATION: 120\n};\n\nconst REQUIRED_SLOT_FIELDS = [\n  'sede', 'start', 'end', 'startLocal', 'endLocal', \n  'durationMinutes', 'dayKey', 'startHM'\n];\n\nconst VALID_SEDES = ['POLANCO', 'SATELITE'];\nconst SEDE_DISPLAY = { \n  POLANCO: 'Polanco', \n  SATELITE: 'SatÃ©lite' \n};\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// UTILIDADES DE FORMATO Y UX\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/**\n * Convierte formato 24h a 12h con AM/PM\n * Ejemplos: \"09:00\" â†’ \"9:00 AM\", \"15:30\" â†’ \"3:30 PM\"\n */\nfunction hm24to12(hm) {\n  if (!hm || !/^\\d{2}:\\d{2}$/.test(hm)) return hm || '';\n  \n  const [H, M] = hm.split(':').map(n => parseInt(n, 10));\n  const am = H < 12;\n  const h12 = H % 12 === 0 ? 12 : H % 12;\n  \n  return `${h12}:${String(M).padStart(2, '0')} ${am ? 'AM' : 'PM'}`;\n}\n\n/**\n * Ordena slots por hora (startHM)\n */\nfunction sortByHM(slots) {\n  return (slots || []).sort((a, b) => \n    (a.startHM || '').localeCompare(b.startHM || '')\n  );\n}\n\n/**\n * Obtiene nombre legible de sede\n */\nfunction sedeName(s) {\n  return SEDE_DISPLAY[String(s || '').toUpperCase()] || String(s || '');\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// FUNCIONES DE VALIDACIÃ“N\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nfunction isEmpty(value) {\n  if (value === null || value === undefined) return true;\n  if (typeof value === 'string' && value.trim() === '') return true;\n  if (Array.isArray(value) && value.length === 0) return true;\n  if (typeof value === 'object' && Object.keys(value).length === 0) return true;\n  return false;\n}\n\nfunction safeGet(obj, path, defaultValue = null) {\n  try {\n    const keys = path.split('.');\n    let result = obj;\n    \n    for (const key of keys) {\n      if (result === null || result === undefined) {\n        return defaultValue;\n      }\n      result = result[key];\n    }\n    \n    return result === undefined ? defaultValue : result;\n  } catch (error) {\n    console.warn(`âš ï¸ Error accessing path \"${path}\":`, error.message);\n    return defaultValue;\n  }\n}\n\n/**\n * ValidaciÃ³n mejorada con Date.parse() y regex para startHM\n */\nfunction isValidSlot(slot) {\n  if (!slot || typeof slot !== 'object') {\n    return { valid: false, reason: 'Slot es null o no es objeto' };\n  }\n\n  // Verificar campos obligatorios\n  for (const field of REQUIRED_SLOT_FIELDS) {\n    if (isEmpty(slot[field])) {\n      return { valid: false, reason: `Campo obligatorio faltante: ${field}` };\n    }\n  }\n\n  // Validar sede\n  if (!VALID_SEDES.includes(slot.sede)) {\n    return { valid: false, reason: `Sede invÃ¡lida: ${slot.sede}` };\n  }\n\n  // Validar duraciÃ³n\n  const duration = parseInt(slot.durationMinutes);\n  if (isNaN(duration) || duration < LIMITS.MIN_SLOT_DURATION || duration > LIMITS.MAX_SLOT_DURATION) {\n    return { valid: false, reason: `DuraciÃ³n invÃ¡lida: ${duration} minutos` };\n  }\n\n  // Validar formato de fecha ISO (mejorado con Date.parse)\n  const startMs = Date.parse(slot.start);\n  const endMs = Date.parse(slot.end);\n  \n  if (Number.isNaN(startMs) || Number.isNaN(endMs)) {\n    return { valid: false, reason: 'Formato de fecha invÃ¡lido' };\n  }\n\n  // Validar que end > start\n  if (endMs <= startMs) {\n    return { valid: false, reason: 'Hora de fin no es posterior a hora de inicio' };\n  }\n\n  // Validar formato de startHM (HH:MM)\n  if (!/^\\d{2}:\\d{2}$/.test(slot.startHM)) {\n    return { valid: false, reason: 'startHM invÃ¡lido (debe ser HH:MM)' };\n  }\n\n  return { valid: true };\n}\n\nfunction sanitizeSlot(slot) {\n  try {\n    return {\n      sede: String(slot.sede || '').toUpperCase().trim(),\n      start: String(slot.start || '').trim(),\n      end: String(slot.end || '').trim(),\n      durationMinutes: parseInt(slot.durationMinutes) || 30,\n      label: String(slot.label || 'Consulta').trim(),\n      weekType: String(slot.weekType || 'A').trim(),\n      startLocal: String(slot.startLocal || '').trim(),\n      endLocal: String(slot.endLocal || '').trim(),\n      startHM: String(slot.startHM || '00:00').trim(),\n      dayKey: String(slot.dayKey || '').trim(),\n      dow: parseInt(slot.dow) || 0,\n      _score: parseFloat(slot._score) || 0\n    };\n  } catch (error) {\n    console.error('âŒ Error sanitizando slot:', error);\n    return null;\n  }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// FUNCIONES DE AGRUPAMIENTO Y FORMATO\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nfunction getDayName(dayKey) {\n  try {\n    const date = new Date(dayKey + 'T12:00:00Z');\n    const days = ['domingo', 'lunes', 'martes', 'miÃ©rcoles', 'jueves', 'viernes', 'sÃ¡bado'];\n    return days[date.getUTCDay()] || 'dÃ­a';\n  } catch (error) {\n    console.warn('âš ï¸ Error obteniendo nombre de dÃ­a:', error);\n    return 'dÃ­a';\n  }\n}\n\nfunction formatDateDisplay(dayKey) {\n  try {\n    const date = new Date(dayKey + 'T12:00:00Z');\n    const day = date.getUTCDate();\n    const months = ['ene', 'feb', 'mar', 'abr', 'may', 'jun', 'jul', 'ago', 'sep', 'oct', 'nov', 'dic'];\n    const month = months[date.getUTCMonth()];\n    return `${day} ${month}`;\n  } catch (error) {\n    console.warn('âš ï¸ Error formateando fecha:', error);\n    return dayKey;\n  }\n}\n\n/**\n * Agrupa slots por dÃ­a y ORDENA por hora dentro de cada dÃ­a\n */\nfunction groupSlotsByDay(slots) {\n  try {\n    if (!Array.isArray(slots) || slots.length === 0) {\n      return [];\n    }\n\n    const grouped = {};\n\n    for (const slot of slots) {\n      const dayKey = slot.dayKey || 'unknown';\n      \n      if (!grouped[dayKey]) {\n        grouped[dayKey] = {\n          dayKey: dayKey,\n          dayLabel: getDayName(dayKey),\n          dateDisplay: formatDateDisplay(dayKey),\n          slots: []\n        };\n      }\n      \n      grouped[dayKey].slots.push(slot);\n    }\n\n    // ğŸ”¥ ORDENAR slots por hora dentro de cada dÃ­a\n    for (const g of Object.values(grouped)) {\n      sortByHM(g.slots);\n    }\n\n    // Convertir a array y ordenar por fecha\n    return Object.values(grouped).sort((a, b) => {\n      return a.dayKey.localeCompare(b.dayKey);\n    });\n\n  } catch (error) {\n    console.error('âŒ Error agrupando slots por dÃ­a:', error);\n    return [];\n  }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// CONSTRUCCIÃ“N DE MENSAJES\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/**\n * Construye mensaje DETERMINÃSTICO para WhatsApp/Chat\n * Formato consistente, profesional y listo para enviar\n */\nfunction buildWhatsAppMessage(primaryDay, backupDays) {\n  if (!primaryDay || !primaryDay.slots || primaryDay.slots.length === 0) {\n    return 'No hay disponibilidad para las fechas solicitadas. Â¿Busco otras fechas o la otra sede?';\n  }\n\n  // Agrupar por sede y limitar a 5 por sede\n  const bySede = {};\n  for (const s of primaryDay.slots) {\n    if (!bySede[s.sede]) bySede[s.sede] = [];\n    bySede[s.sede].push(s);\n  }\n\n  // Ordenar dentro de cada sede\n  for (const k of Object.keys(bySede)) {\n    sortByHM(bySede[k]);\n  }\n\n  const lines = [];\n  \n  // Encabezado con dÃ­a principal\n  lines.push(`EncontrÃ© disponibilidad para **${primaryDay.dayLabel} ${primaryDay.dateDisplay}**:`);\n\n  // Slots del dÃ­a principal por sede\n  for (const [sede, slots] of Object.entries(bySede)) {\n    const times = slots.slice(0, 5).map(s => hm24to12(s.startHM || ''));\n    const extra = slots.length > 5 ? ` â€¢ â€¦y ${slots.length - 5} mÃ¡s` : '';\n    lines.push(`\\nğŸ“ **${sedeName(sede)}**\\nâœ… ${times.join(' â€¢ ')}${extra}`);\n  }\n\n  // DÃ­as de respaldo\n  for (const b of (backupDays || [])) {\n    const bySedeB = {};\n    for (const s of b.slots) {\n      if (!bySedeB[s.sede]) bySedeB[s.sede] = [];\n      bySedeB[s.sede].push(s);\n    }\n    \n    for (const k of Object.keys(bySedeB)) {\n      sortByHM(bySedeB[k]);\n    }\n\n    for (const [sede, slots] of Object.entries(bySedeB)) {\n      const times = slots.slice(0, 5).map(s => hm24to12(s.startHM || ''));\n      lines.push(`\\nTambiÃ©n tengo en **${sedeName(sede)}** para **${b.dayLabel} ${b.dateDisplay}**:\\nâœ… ${times.join(' â€¢ ')}`);\n    }\n  }\n\n  // CTA claro\n  lines.push('\\nÂ¿CuÃ¡l te acomoda?');\n  \n  return lines.join('\\n');\n}\n\n/**\n * Resumen ejecutivo para contexto del LLM\n */\nfunction buildExecutiveSummary(primaryDay, backupDays, query) {\n  try {\n    const parts = [];\n\n    if (primaryDay && primaryDay.slots && primaryDay.slots.length > 0) {\n      const totalSlots = primaryDay.slots.length;\n      const firstSlot = primaryDay.slots[0];\n      const sede = firstSlot.sede || 'sede';\n      const dayLabel = primaryDay.dayLabel || 'dÃ­a';\n      const dateDisplay = primaryDay.dateDisplay || '';\n\n      parts.push(`Disponibilidad para ${dayLabel} ${dateDisplay} en ${sedeName(sede)}: ${totalSlots} horarios`);\n\n      // Horarios destacados (primeros 3) en formato 12h\n      const destacados = primaryDay.slots\n        .slice(0, 3)\n        .map(s => hm24to12(s.startHM))\n        .filter(Boolean);\n      \n      if (destacados.length > 0) {\n        parts.push(`Horarios: ${destacados.join(', ')}`);\n      }\n    }\n\n    if (backupDays && backupDays.length > 0) {\n      parts.push(`TambiÃ©n disponible: ${backupDays.length} dÃ­as mÃ¡s`);\n    }\n\n    if (query && query.sedePreferida) {\n      parts.push(`Sede preferida: ${sedeName(query.sedePreferida)}`);\n    }\n\n    return parts.join('. ') + '.';\n\n  } catch (error) {\n    console.error('âŒ Error construyendo resumen ejecutivo:', error);\n    return 'Disponibilidad encontrada.';\n  }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// FUNCIÃ“N PRINCIPAL\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ntry {\n  const t0 = Date.now();\n  \n  if (DEBUG) {\n    console.log('ğŸš€ BUILD_RESPONSE v17.0 - INICIANDO');\n  }\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // OBTENER Y VALIDAR INPUT\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  const inputItems = $input.all();\n  \n  if (!inputItems || inputItems.length === 0) {\n    throw new Error('No hay items de entrada');\n  }\n\n  if (DEBUG) {\n    console.log(`ğŸ“¥ Input: ${inputItems.length} items`);\n  }\n\n  const firstItem = inputItems[0];\n  const jsonData = safeGet(firstItem, 'json', {});\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // EXTRAER Y VALIDAR SLOTS\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  const allowedSlotsRaw = safeGet(jsonData, 'allowedSlots', []);\n  \n  if (!Array.isArray(allowedSlotsRaw)) {\n    throw new Error('Formato invÃ¡lido: allowedSlots debe ser un array');\n  }\n\n  if (DEBUG) {\n    console.log(`ğŸ“Š Slots recibidos (raw): ${allowedSlotsRaw.length}`);\n  }\n\n  // Validar y sanitizar cada slot\n  const validSlots = [];\n  const invalidSlots = [];\n\n  for (let i = 0; i < allowedSlotsRaw.length; i++) {\n    if (validSlots.length >= LIMITS.MAX_TOTAL_SLOTS) {\n      console.warn(`âš ï¸ LÃ­mite de slots alcanzado (${LIMITS.MAX_TOTAL_SLOTS}), ignorando resto`);\n      break;\n    }\n\n    const rawSlot = allowedSlotsRaw[i];\n    const sanitized = sanitizeSlot(rawSlot);\n    \n    if (!sanitized) {\n      invalidSlots.push({ index: i, reason: 'Error en sanitizaciÃ³n' });\n      continue;\n    }\n\n    const validation = isValidSlot(sanitized);\n    if (!validation.valid) {\n      invalidSlots.push({ index: i, reason: validation.reason, slot: sanitized });\n      if (DEBUG) {\n        console.log(`âš ï¸ Slot ${i} invÃ¡lido: ${validation.reason}`);\n      }\n      continue;\n    }\n\n    validSlots.push(sanitized);\n  }\n\n  if (DEBUG) {\n    console.log(`âœ… Slots vÃ¡lidos: ${validSlots.length}`);\n    console.log(`âŒ Slots invÃ¡lidos: ${invalidSlots.length}`);\n  }\n\n  // Si no hay slots vÃ¡lidos\n  if (validSlots.length === 0) {\n    console.warn('âš ï¸ No hay slots vÃ¡lidos despuÃ©s de validaciÃ³n');\n    \n    const noAvailMsg = 'No hay disponibilidad para las fechas solicitadas. Â¿Busco otras fechas o la otra sede?';\n    \n    return [\n      {\n        json: {\n          kind: 'llm_brief',\n          version: VERSION,\n          status: 'no_availability',\n          availableSlots: 0,\n          message: noAvailMsg,\n          humanMessage: noAvailMsg,\n          whatsappMessage: noAvailMsg,\n          timestamp: new Date().toISOString()\n        },\n        pairedItem: { item: 0 }\n      },\n      {\n        json: {\n          kind: 'audit_payload',\n          version: VERSION,\n          status: 'no_availability',\n          metrics: {\n            totalSlotsReceived: allowedSlotsRaw.length,\n            validSlots: 0,\n            invalidSlots: invalidSlots.length\n          },\n          timestamp: new Date().toISOString()\n        },\n        pairedItem: { item: 0 }\n      }\n    ];\n  }\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // AGRUPAR Y ORDENAR SLOTS\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  const dayGroups = groupSlotsByDay(validSlots);\n  \n  if (DEBUG) {\n    console.log(`ğŸ“… DÃ­as con disponibilidad: ${dayGroups.length}`);\n  }\n\n  if (dayGroups.length === 0) {\n    throw new Error('Error agrupando slots por dÃ­a');\n  }\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // IDENTIFICAR DÃA PRINCIPAL Y BACKUPS\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  const primaryDay = dayGroups[0];\n  \n  if (!primaryDay) {\n    throw new Error('No se pudo identificar dÃ­a principal');\n  }\n\n  // Limitar slots del dÃ­a principal\n  primaryDay.slots = primaryDay.slots.slice(0, LIMITS.MAX_SLOTS_PER_DAY);\n\n  // DÃ­as de respaldo\n  const backupDays = dayGroups.slice(1, LIMITS.MAX_BACKUP_DAYS + 1);\n  \n  for (const day of backupDays) {\n    if (day.slots && day.slots.length > LIMITS.MAX_SLOTS_PER_DAY) {\n      day.slots = day.slots.slice(0, LIMITS.MAX_SLOTS_PER_DAY);\n    }\n  }\n\n  if (DEBUG) {\n    console.log(`ğŸ¯ DÃ­a principal: ${primaryDay.dayLabel} ${primaryDay.dateDisplay} (${primaryDay.slots.length} slots)`);\n    console.log(`ğŸ”„ DÃ­as de respaldo: ${backupDays.length}`);\n  }\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // EXTRAER QUERY INFO\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  const query = {\n    desiredStart: safeGet(jsonData, 'desiredStart', ''),\n    userText: safeGet(jsonData, 'userText', ''),\n    sedePreferida: safeGet(jsonData, 'sedePreferida', ''),\n    timezone: safeGet(jsonData, 'timezone', 'America/Mexico_City'),\n    onlyMorning: safeGet(jsonData, 'onlyMorning', false),\n    onlyAfternoon: safeGet(jsonData, 'onlyAfternoon', false),\n    includeWeekends: safeGet(jsonData, 'includeWeekends', true)\n  };\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // CONSTRUIR MENSAJES\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  const executiveSummary = buildExecutiveSummary(primaryDay, backupDays, query);\n  const whatsappMessage = buildWhatsAppMessage(primaryDay, backupDays);\n\n  if (DEBUG) {\n    console.log(`ğŸ“ Resumen ejecutivo: ${executiveSummary.substring(0, 100)}...`);\n    console.log(`ğŸ’¬ Mensaje WhatsApp generado (${whatsappMessage.length} chars)`);\n  }\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // CONSTRUIR RESPUESTAS FINALES\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  const llmBrief = {\n    kind: 'llm_brief',\n    version: VERSION,\n    status: 'success',\n    \n    // ResÃºmenes\n    executiveSummary: executiveSummary,\n    humanMessage: whatsappMessage,      // Compatibilidad\n    whatsappMessage: whatsappMessage,   // ğŸ”¥ CANÃ“NICO para enviar\n    \n    // EstadÃ­sticas\n    availableSlots: validSlots.length,\n    availableDays: dayGroups.length,\n    \n    // DÃ­a principal\n    primaryDay: {\n      dayKey: primaryDay.dayKey,\n      dayLabel: primaryDay.dayLabel,\n      dateDisplay: primaryDay.dateDisplay,\n      totalSlots: primaryDay.slots.length,\n      slots: primaryDay.slots\n    },\n    \n    // DÃ­as de respaldo\n    backupDays: backupDays.map(day => ({\n      dayKey: day.dayKey,\n      dayLabel: day.dayLabel,\n      dateDisplay: day.dateDisplay,\n      totalSlots: day.slots.length,\n      slots: day.slots.slice(0, 5)\n    })),\n    \n    // Contexto\n    query: query,\n    timestamp: new Date().toISOString()\n  };\n\n  const auditPayload = {\n    kind: 'audit_payload',\n    version: VERSION,\n    status: 'success',\n    \n    metrics: {\n      executionTimeMs: Date.now() - t0,\n      totalSlotsReceived: allowedSlotsRaw.length,\n      validSlots: validSlots.length,\n      invalidSlots: invalidSlots.length,\n      daysWithAvailability: dayGroups.length,\n      primaryDaySlots: primaryDay.slots.length,\n      backupDaysCount: backupDays.length\n    },\n    \n    allDays: dayGroups.map(day => ({\n      dayKey: day.dayKey,\n      dayLabel: day.dayLabel,\n      totalSlots: day.slots.length\n    })),\n    \n    query: query,\n    requestId: safeGet(jsonData, 'requestId', 'unknown'),\n    timestamp: new Date().toISOString()\n  };\n\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  // LOGGING Y RETORNO\n  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  if (DEBUG) {\n    console.log('âœ… BUILD_RESPONSE v17.0 - COMPLETADO');\n    console.log(`â±ï¸  Tiempo: ${auditPayload.metrics.executionTimeMs}ms`);\n    console.log(`ğŸ“Š Procesados: ${validSlots.length}/${allowedSlotsRaw.length} slots`);\n    console.log(`ğŸ“… DÃ­as: ${dayGroups.length}`);\n    console.log(`ğŸ’¬ Mensaje preview: ${whatsappMessage.substring(0, 80)}...`);\n  }\n\n  // ğŸ”¥ Retornar con pairedItem para mejor tracking en n8n\n  return [\n    { json: llmBrief, pairedItem: { item: 0 } },\n    { json: auditPayload, pairedItem: { item: 0 } }\n  ];\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// MANEJO DE ERRORES\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n} catch (error) {\n  console.error('âŒ ERROR CRÃTICO EN BUILD_RESPONSE:', error);\n  console.error('Stack:', error.stack);\n\n  const errorMsg = 'No hay disponibilidad para las fechas solicitadas. Â¿Busco otras fechas o la otra sede?';\n\n  const errorLlmBrief = {\n    kind: 'llm_brief',\n    version: VERSION,\n    status: 'error',\n    error: true,\n    message: errorMsg,\n    humanMessage: errorMsg,\n    whatsappMessage: errorMsg,\n    errorDetails: DEBUG ? {\n      message: error.message,\n      type: error.name\n    } : undefined,\n    timestamp: new Date().toISOString()\n  };\n\n  const errorAuditPayload = {\n    kind: 'audit_payload',\n    version: VERSION,\n    status: 'error',\n    error: {\n      message: error.message,\n      type: error.name,\n      stack: DEBUG ? error.stack : undefined\n    },\n    timestamp: new Date().toISOString()\n  };\n\n  return [\n    { json: errorLlmBrief, pairedItem: { item: 0 } },\n    { json: errorAuditPayload, pairedItem: { item: 0 } }\n  ];\n}"
      },
      "id": "0a9e477c-f8a3-4d87-aaf9-4de31387a918",
      "name": "Build Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        2000
      ]
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Hospital Angeles Polanco"
        },
        "timeMin": "={{$('SET_DEFAULTS').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "25a27706-9f46-459c-9d8c-44474b75857c",
      "name": "Availability - POLANCO",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -720,
        1904
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "retryOnFail": false,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "LWCHe5J8QGKC4iFi",
          "name": "Google Calendar account - Clinicasdelcorazoncdmx@gmail.com"
        }
      },
      "notes": "Fallback: Continue On Fail activo. Si falla, Normalize generarÃ¡ sourceStatus=error."
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "San Angel Inn Satelite"
        },
        "timeMin": "={{$('SET_DEFAULTS').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "9c9d8a84-7368-4f74-a9be-c2e305111fa1",
      "name": "Availability - SATELITE",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -720,
        2096
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "LWCHe5J8QGKC4iFi",
          "name": "Google Calendar account - Clinicasdelcorazoncdmx@gmail.com"
        }
      },
      "notes": "Fallback: Continue On Fail activo."
    },
    {
      "parameters": {},
      "id": "7c93c590-18cb-49e7-a209-8d8814683bff",
      "name": "Merge Busy (append)1",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -272,
        2000
      ]
    },
    {
      "parameters": {
        "jsCode": "/**\n * COMBINE_BUSY v4.5.0 â€” Keep-all fields + Bands enrichment + Context/maxResults\n * - âœ… Preserva TODOS los campos de allowedSlots provenientes de SCHEDULE_GATE.\n * - âœ… Enriquecimiento de slots generados desde allowed (bands): startLocal, endLocal, startHM, dayKey, dow, durationMinutes.\n * - Sedes dinÃ¡micas desde SCHEDULE (static data) con fallback.\n * - Acceso consistente a SET_DEFAULTS (context) y SCHEDULE_GATE (validaciÃ³n de kind).\n * - Recorte de intervalos a la ventana + merge contiguo (touching).\n * - AplicaciÃ³n de ctx.maxResults sobre allowedSlots.\n * - Hashes por sede; whitelist y mÃ©tricas recalculadas con finalSlots.\n */\n\n'use strict';\n\nconst BUILD_VERSION = '4.5.0';\n\n// ===== Config de polÃ­tica (no rompe shape) =====\nconst POLICY_DEFAULTS = {\n  mergeTouching: true,             // combina [10:00,10:30] + [10:30,11:00]\n  filterToVerifiedSedes: false,    // si true, solo deja slots de sedes con fuente OK\n};\n\n// ===== Utils ligeros =====\nconst safeArr = a => Array.isArray(a) ? a : [];\nconst cmpISO = (a, b) => (a < b ? -1 : a > b ? 1 : 0);\nfunction djb2(str){ let h=5381; for (let i=0;i<str.length;i++) h=((h<<5)+h)+str.charCodeAt(i); return 'H'+(h>>>0).toString(36); }\n\n// ===== Intl cache =====\nconst dtfCache = new Map();\nfunction getCachedDtf(options, tz){\n  const key = JSON.stringify({ ...options, tz });\n  let v = dtfCache.get(key);\n  if (!v) { v = new Intl.DateTimeFormat('en-CA', { timeZone: tz, ...options }); dtfCache.set(key, v); }\n  return v;\n}\nfunction dtPartsInTZ(d, tz){\n  const dtf = getCachedDtf({ year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false }, tz);\n  const p = dtf.formatToParts(d).reduce((A,x)=>(A[x.type]=x.value,A),{});\n  return { y:+p.year, m:+p.month, d:+p.day, hh:+p.hour, mm:+p.minute, ss:+p.second };\n}\nfunction zonedEpochMs(y,m,d,hh=0,mm=0,ss=0, tz){\n  const dtf = getCachedDtf({ year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false }, tz);\n  const guess = Date.UTC(y, m-1, d, hh, mm, ss);\n  const seen = dtf.formatToParts(new Date(guess)).reduce((A,p)=>(A[p.type]=p.value,A),{});\n  const seenMs = Date.UTC(+seen.year, +seen.month-1, +seen.day, +seen.hour, +seen.minute, +seen.second);\n  const wantMs = Date.UTC(y, m-1, d, hh, mm, ss);\n  return guess + (wantMs - seenMs);\n}\nfunction ymdLocal(iso, tz){ const p = dtPartsInTZ(new Date(iso), tz); return `${p.y}-${String(p.m).padStart(2,'0')}-${String(p.d).padStart(2,'0')}`; }\nfunction hmLocal(iso, tz){ const p = dtPartsInTZ(new Date(iso), tz); return `${String(p.hh).padStart(2,'0')}:${String(p.mm).padStart(2,'0')}`; }\n\nfunction isAlignedLocal(iso, anchors, tz){\n  const p = dtPartsInTZ(new Date(iso), tz); return anchors.includes(p.mm);\n}\nfunction alignUpLocal(iso, anchors, tz){\n  const p = dtPartsInTZ(new Date(iso), tz);\n  const asc = [...anchors].sort((a,b)=>a-b);\n  if (asc.includes(p.mm)) return new Date(zonedEpochMs(p.y,p.m,p.d,p.hh,p.mm,0,tz)).toISOString();\n  const next = asc.find(a=>a>p.mm);\n  let hh=p.hh, mm=(next!==undefined?next:asc[0]); if (next===undefined) hh=(hh+1)%24;\n  return new Date(zonedEpochMs(p.y,p.m,p.d,hh,mm,0,tz)).toISOString();\n}\nfunction alignDownLocal(iso, anchors, tz){\n  const p = dtPartsInTZ(new Date(iso), tz);\n  const asc = [...anchors].sort((a,b)=>a-b);\n  if (asc.includes(p.mm)) return new Date(zonedEpochMs(p.y,p.m,p.d,p.hh,p.mm,0,tz)).toISOString();\n  const prev = [...asc].reverse().find(a=>a<p.mm);\n  let hh=p.hh, mm=(prev!==undefined?prev:asc[asc.length-1]); if (prev===undefined) hh=(hh+24-1)%24;\n  return new Date(zonedEpochMs(p.y,p.m,p.d,hh,mm,0,tz)).toISOString();\n}\n\n// ===== Recorte a ventana =====\nfunction cropToWindow(iv, startISO, endISO){\n  const s = (startISO && iv.start < startISO) ? startISO : iv.start;\n  const e = (endISO && iv.end   > endISO)   ? endISO   : iv.end;\n  return (s < e) ? { start:s, end:e } : null;\n}\n\n// ===== Merge exclusivo con touching opcional =====\nfunction mergeExclusive(list, mergeTouching=true){\n  if (!list || !list.length) return [];\n  const s = [...list].sort((a,b)=> cmpISO(a.start,b.start) || cmpISO(a.end,b.end));\n  const out = [{ start: s[0].start, end: s[0].end }];\n  for (let i=1;i<s.length;i++){\n    const last = out[out.length-1];\n    const overlaps = s[i].start < last.end;\n    const touches  = mergeTouching && s[i].start === last.end;\n    if (overlaps || touches){\n      if (s[i].end > last.end) last.end = s[i].end;\n    } else {\n      out.push({ start:s[i].start, end:s[i].end });\n    }\n  }\n  return out;\n}\n\n// ==================== CARGAR SEDES DESDE SCHEDULE ====================\nfunction loadSedes() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function')\n      ? $getWorkflowStaticData('global')\n      : this.getWorkflowStaticData('global');\n\n    const SCHEDULE = store.SCHEDULE;\n\n    if (SCHEDULE?.sedes) {\n      const sedes = Object.keys(SCHEDULE.sedes);\n      console.log('âœ… Sedes cargadas desde SCHEDULE', {\n        sedes,\n        version: store.SCHEDULE_VERSION\n      });\n      return {\n        sedes,\n        source: 'schedule',\n        version: store.SCHEDULE_VERSION\n      };\n    }\n    console.warn('âš ï¸ SCHEDULE.sedes no disponible, usando fallback');\n  } catch (e) {\n    console.warn('âš ï¸ Error cargando sedes desde SCHEDULE, usando fallback', { error: e.message });\n  }\n  // Fallback a valores hardcoded\n  return {\n    sedes: ['POLANCO', 'SATELITE'],\n    source: 'fallback'\n  };\n}\n\ntry {\n  const rawItems = $input.all().map(x=>x.json);\n\n  // ===== Context =====\n  let ctx = {};\n  let requestId = `combine-${Date.now()}`;\n  try {\n    const setDefaultsItems = $('SET_DEFAULTS').all();\n    if (setDefaultsItems && setDefaultsItems.length > 0) {\n      ctx = setDefaultsItems[0].json || {};\n      if (ctx?.kind !== 'context') {\n        console.warn('âš ï¸ SET_DEFAULTS no retornÃ³ context vÃ¡lido, kind:', ctx?.kind);\n        ctx = {};\n      } else {\n        if (ctx.requestId) requestId = ctx.requestId;\n        console.log('âœ… Context cargado desde SET_DEFAULTS', {\n          windowStart: ctx.windowStart, windowEnd: ctx.windowEnd,\n          requestId, tz: ctx.tz, maxResults: ctx.maxResults\n        });\n      }\n    } else {\n      console.warn('âš ï¸ No se encontrÃ³ SET_DEFAULTS');\n    }\n  } catch (err) {\n    console.warn('âš ï¸ Error obteniendo SET_DEFAULTS:', err.message);\n  }\n\n  // ===== TZ, STEP, GRID =====\n  const TZ = ctx.tz || 'America/Mexico_City';\n  const STEP = Math.max(10, Math.min(120, ctx.slotMinutes || 30));\n  const ANCHORS = (ctx.grid?.anchors && Array.isArray(ctx.grid.anchors) && ctx.grid.anchors.length)\n    ? Array.from(new Set(ctx.grid.anchors.map(Number).filter(n=>Number.isFinite(n)&&n>=0&&n<60))).sort((a,b)=>a-b)\n    : [0,30];\n  const windowStartISO = ctx.windowStart || null;\n  const windowEndISO   = ctx.windowEnd   || null;\n\n  // ===== SEDES dinÃ¡micas =====\n  const sedesData = loadSedes();\n  const SEDES = sedesData.sedes;\n\n  // ===== Gate =====\n  let gate = {};\n  try {\n    const gateItems = $('SCHEDULE_GATE').all();\n    if (gateItems && gateItems.length > 0) {\n      gate = gateItems[0].json || {};\n      if (gate?.kind !== 'scheduleGate') {\n        console.warn('âš ï¸ SCHEDULE_GATE no retornÃ³ respuesta vÃ¡lida, kind:', gate?.kind);\n        gate = {};\n      } else {\n        console.log('âœ… SCHEDULE_GATE cargado', {\n          hasAllowed: gate.allowed?.length || 0,\n          hasSlots: gate.allowedSlots?.length || 0\n        });\n      }\n    } else {\n      console.warn('âš ï¸ No se encontrÃ³ SCHEDULE_GATE');\n    }\n  } catch (err) {\n    console.warn('âš ï¸ Error obteniendo SCHEDULE_GATE:', err.message);\n  }\n\n  const allowedBandsFromGate = Array.isArray(gate.allowed) ? gate.allowed : [];\n  const allowedSlotsFromGate = Array.isArray(gate.allowedSlots) ? gate.allowedSlots : [];\n\n  // PolÃ­tica efectiva\n  const policy = Object.assign({}, POLICY_DEFAULTS, (ctx.policy || {}));\n\n  // Day whitelist\n  let dayWhitelist = null;\n  if (ctx?.filters?.dayWhitelist && Array.isArray(ctx.filters.dayWhitelist)) {\n    dayWhitelist = new Set(ctx.filters.dayWhitelist);\n  } else if ((ctx?.policyHints?.hasExplicitDate || ctx?.search?.intent === 'specific_day' || ctx?.search?.intent === 'explicit_range')\n             && Number(ctx?.windowDays) === 1 && windowStartISO) {\n    dayWhitelist = new Set([ymdLocal(windowStartISO, TZ)]);\n  }\n\n  // ===== Agrupar busy por sede con recorte a ventana =====\n  const groups  = Object.fromEntries(SEDES.map(s => [s, []]));\n  const sources = Object.fromEntries(SEDES.map(s => [s, { ok:false }]));\n  const busyInputs = rawItems.filter(j => j && j.kind === 'busy');\n\n  for (const j of busyInputs){\n    const sede = j.sede ? String(j.sede).toUpperCase() : null;\n    const apply = (se, arr=[])=>{\n      for (const iv of safeArr(arr)){\n        if (!iv?.start || !iv?.end || !(iv.start < iv.end)) continue;\n        if (windowStartISO && iv.end   <= windowStartISO) continue;\n        if (windowEndISO   && iv.start >= windowEndISO)   continue;\n        const clipped = cropToWindow(iv, windowStartISO, windowEndISO);\n        if (clipped) groups[se].push({ start: clipped.start, end: clipped.end });\n      }\n    };\n\n    if (sede && SEDES.includes(sede)){\n      if (sources[sede].ok !== true) sources[sede] = j.sourceStatus || { ok:true, reason:'present_no_status' };\n      apply(sede, j.busy);\n    }\n    // busyBySede del upstream: solo procesamos claves reconocidas en SEDES\n    if (j.busyBySede && typeof j.busyBySede === 'object'){\n      for (const se of SEDES){\n        const arr = safeArr(j.busyBySede[se]);\n        if (arr.length && sources[se].ok !== true) sources[se] = j.sourceStatus || { ok:true, reason:'present_no_status' };\n        apply(se, arr);\n      }\n    }\n  }\n\n  // ===== Merge por sede (con touching) y hashes por sede =====\n  const busyBySede = Object.fromEntries(\n    SEDES.map(s => [s, mergeExclusive(groups[s], policy.mergeTouching)])\n  );\n  const hashBusyBySede = Object.fromEntries(\n    SEDES.map(s => [s, djb2(JSON.stringify(busyBySede[s] || []))])\n  );\n  const hashBusy = djb2(JSON.stringify(hashBusyBySede));\n\n  // ===== Local pretties y off-grid =====\n  function fmtLocal(iso, tz){\n    // Mantener 24h para consistencia con SCHEDULE_GATE\n    return new Date(iso).toLocaleString('es-MX', { timeZone: tz, hour12:false, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' });\n  }\n  const busyBySedeLocal = Object.fromEntries(\n    SEDES.map(s => [s, safeArr(busyBySede[s]).map(iv => ({\n      start:iv.start, end:iv.end, startLocal:fmtLocal(iv.start,TZ), endLocal:fmtLocal(iv.end,TZ)\n    }))])\n  );\n  const offGridBusy = Object.fromEntries(\n    SEDES.map(s => [s, safeArr(busyBySede[s]).filter(iv => !isAlignedLocal(iv.start, ANCHORS, TZ) || !isAlignedLocal(iv.end, ANCHORS, TZ)).length])\n  );\n\n  // ===== Allowed slots =====\n  let allowedSlots = [];\n\n  // âœ… Ruta 1: preserved slots desde SCHEDULE_GATE (KEEP ALL FIELDS)\n  if (allowedSlotsFromGate.length){\n    allowedSlots = allowedSlotsFromGate\n      .map(s => ({\n        ...s, // â† CLAVE: conserva startLocal, endLocal, startHM, dayKey, dow, durationMinutes, etc.\n        sede: String(s.sede || '').toUpperCase(),\n        twHit: typeof s.twHit === 'boolean' ? s.twHit : undefined\n      }))\n      .filter(s => SEDES.includes(s.sede)); // filtra sedes no vÃ¡lidas\n  }\n  // Ruta 2: bands â†’ generar slots discretos enriquecidos\n  else if (allowedBandsFromGate.length){\n    const stepMs = STEP * 60000;\n    for (const band of allowedBandsFromGate){\n      const sede = String(band.sede||'').toUpperCase();\n      if (!SEDES.includes(sede) || !band.start || !band.end) continue;\n\n      // Alinear a grilla local\n      const bandStartISO = alignUpLocal(band.start, ANCHORS, TZ);\n      const bandEndISO   = alignDownLocal(band.end, ANCHORS, TZ);\n\n      let t = new Date(bandStartISO).getTime(), end = new Date(bandEndISO).getTime();\n      if (t >= end) continue;\n\n      while (t < end){\n        const next = t + stepMs;\n        const startISO = new Date(t).toISOString();\n        const endISO   = new Date(next).toISOString();\n\n        allowedSlots.push({\n          sede,\n          start: startISO,\n          end: endISO,\n          label: band.label || null,\n          weekType: band.weekType || null,\n          // âœ… Enriquecimiento como en SCHEDULE_GATE\n          startLocal: fmtLocal(startISO, TZ),\n          endLocal: fmtLocal(endISO, TZ),\n          startHM: hmLocal(startISO, TZ),\n          dayKey: ymdLocal(startISO, TZ),\n          dow: new Date(startISO).getUTCDay(),\n          durationMinutes: STEP\n        });\n        t = next;\n      }\n    }\n  }\n\n  if (allowedSlots.length){\n    const seen = new Set();\n    const inWindow = s => (!windowStartISO || s.start >= windowStartISO) && (!windowEndISO || s.end <= windowEndISO);\n    const inDayWL  = s => !dayWhitelist || dayWhitelist.has(ymdLocal(s.start, TZ));\n    const keepGrid = s =>\n      isAlignedLocal(s.start, ANCHORS, TZ) &&\n      isAlignedLocal(s.end, ANCHORS, TZ) &&\n      Math.abs((new Date(s.end)-new Date(s.start))/60000 - STEP) <= 0.5;\n\n    allowedSlots = allowedSlots\n      .filter(s => keepGrid(s) && inWindow(s) && inDayWL(s))\n      .filter(s => { const k = `${s.sede}|${s.start}|${s.end}`; if (seen.has(k)) return false; seen.add(k); return true; })\n      .sort((a,b)=> cmpISO(a.start,b.start) || a.sede.localeCompare(b.sede));\n  }\n\n  // ===== VerificaciÃ³n/coverage =====\n  const verifiedSedes = SEDES.filter(s => (busyBySede[s] && busyBySede[s].length) || sources[s]?.ok === true);\n  const skippedSedes  = SEDES.filter(s => !verifiedSedes.includes(s));\n  const degraded = skippedSedes.length > 0;\n\n  // (Opcional) filtrar slots a sedes verificadas si la polÃ­tica lo pide\n  const filteredSlots = policy.filterToVerifiedSedes\n    ? allowedSlots.filter(s => verifiedSedes.includes(s.sede))\n    : allowedSlots;\n\n  // ===== NUEVO: Aplicar maxResults del context =====\n  let finalSlots = filteredSlots;\n  if (ctx.maxResults && typeof ctx.maxResults === 'number' && ctx.maxResults > 0) {\n    const originalCount = filteredSlots.length;\n    finalSlots = filteredSlots.slice(0, ctx.maxResults);\n    if (originalCount > finalSlots.length) {\n      console.log(`âš™ï¸ maxResults aplicado: ${originalCount} â†’ ${finalSlots.length} slots`);\n    }\n  }\n\n  // Whitelist y hashes con finalSlots\n  const slotKey = s => `${s.sede}|${s.start}|${s.end}`;\n  const slotWhitelist = finalSlots.map(slotKey);\n  const hashAllowedSlots = djb2(JSON.stringify(finalSlots));\n  const hashWhitelist = djb2(slotWhitelist.join(','));\n\n  // Totales dinÃ¡micos por sede\n  const busyCountsBySede = Object.fromEntries(SEDES.map(s => [s, safeArr(busyBySede[s]).length]));\n  const totals = {\n    busyBlocks: Object.assign({ all: Object.values(busyCountsBySede).reduce((a,b)=>a+b,0) }, busyCountsBySede),\n    allowedSlots: finalSlots.length\n  };\n  const metrics = {\n    allowedBySede: finalSlots.reduce((A,s)=>{A[s.sede]=(A[s.sede]||0)+1; return A;},{}),\n    twHitCount: finalSlots.filter(s => s.twHit === true).length,\n    hashBusyBySede,\n    maxResultsApplied: !!(ctx.maxResults && filteredSlots.length > ctx.maxResults)\n  };\n\n  const result = {\n    kind: 'busy_combined',\n    build: {\n      version: BUILD_VERSION,\n      generatedAt: new Date().toISOString(),\n      // Metadata de SCHEDULE\n      scheduleVersion: sedesData.version,\n      sedesSource: sedesData.source\n    },\n\n    // Tracking\n    requestId,\n\n    ctx,\n\n    scheduleGate: {\n      decision: gate.decision || null,\n      notes: gate.notes || null,\n      meta: gate.meta || null,\n      allowed: allowedBandsFromGate,\n      allowedSlots: finalSlots  // â† slots finales preservando/enriqueciendo campos\n    },\n\n    busyBySede, busyBySedeLocal, offGridBusy, hashBusy,\n\n    coverage: { verifiedSedes, skippedSedes },\n    degraded, sources, totals, metrics,\n\n    slotWhitelist, hashAllowedSlots, hashWhitelist,\n\n    policy: {\n      strictVerification: true,\n      neverInventTimes: true,\n      mergeTouching: policy.mergeTouching,\n      filterToVerifiedSedes: policy.filterToVerifiedSedes\n    },\n\n    debugLocal: {\n      tz: TZ,\n      anchors: ANCHORS,\n      step: STEP,\n      // Info de sedes\n      sedes: SEDES,\n      sedesSource: sedesData.source\n    }\n  };\n\n  return [{ json: result, pairedItem: $input.all().map((_, i) => ({ item: i })) }];\n\n} catch (err){\n  return [{ json: { kind:'error', error:'COMBINE_FAIL', message: String(err && err.message || err) } }];\n}\n"
      },
      "id": "f2a5ea6c-43cf-4938-aec7-d112a655860f",
      "name": "Combine Busy",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        2000
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * CALC_AVAILABILITY v9.0 â€” Refactor completo (consume COMBINE_BUSY)\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * Cambios clave:\n * 1) âŒ Elimina SCHEDULE y lÃ³gica de generaciÃ³n/filtrado (ya hecho upstream)\n * 2) âœ… Lee allowedSlots ya filtrados desde COMBINE_BUSY (kind=busy_combined)\n * 3) âœ… Aplica ranking/scoring y respeta ctx.maxResults\n * 4) âœ… Enriquecimiento/summary/metrics y tracking con requestId\n */\n\nconst VERSION = '9.0.0';\nconst DEBUG = true;\n\n// ==================== OBTENER DATOS DE COMBINE_BUSY ====================\nfunction getCombineBusyData() {\n  try {\n    const items = $input.all();\n    // COMBINE_BUSY debe emitir un item con kind=busy_combined\n    const busyItem = items.find((it) => it?.json?.kind === 'busy_combined');\n\n    if (busyItem?.json) {\n      if (DEBUG) {\n        console.log('âœ… COMBINE_BUSY data encontrado', {\n          hasAllowedSlots: busyItem.json?.scheduleGate?.allowedSlots?.length || 0,\n          requestId: busyItem.json?.requestId,\n        });\n      }\n      return busyItem.json;\n    }\n\n    console.warn('âš ï¸ No se encontrÃ³ item con kind=busy_combined en $input');\n  } catch (e) {\n    console.error('âŒ Error obteniendo COMBINE_BUSY:', e.message);\n  }\n\n  // Fallback seguro\n  return {\n    kind: 'busy_combined',\n    ctx: {},\n    scheduleGate: {\n      allowedSlots: [],\n      decision: { isOpen: false, reason: 'No data from COMBINE_BUSY' },\n    },\n    requestId: `calc-${Date.now()}`,\n    build: { version: 'unknown', generatedAt: new Date().toISOString() },\n  };\n}\n\n// ==================== RANKING ====================\n// Usa startHM (local) si existe; si no, deriva de slot.start (UTC)\nfunction rankSlots(slots, ctx) {\n  if (!Array.isArray(slots) || slots.length === 0) return [];\n\n  return slots\n    .map((slot) => {\n      let score = 0;\n\n      // Extraer hora/minuto/dow de forma robusta\n      let hourLocal = null;\n      let minuteLocal = null;\n\n      if (typeof slot.startHM === 'string' && /^\\d{2}:\\d{2}$/.test(slot.startHM)) {\n        const [h, m] = slot.startHM.split(':').map(Number);\n        hourLocal = h;\n        minuteLocal = m;\n      } else if (slot.start) {\n        // Fallback: interpretar desde ISO (UTC); SCHEDULE_GATE ya dio startLocal aparte\n        const d = new Date(slot.start);\n        hourLocal = d.getUTCHours();\n        minuteLocal = d.getUTCMinutes();\n      } else {\n        // Ãšltimo recurso: 0:0 para no romper\n        hourLocal = 0;\n        minuteLocal = 0;\n      }\n\n      // DÃ­a de la semana (para penalizaciÃ³n sÃ¡bado)\n      const dow = slot.dow != null ? slot.dow : (slot.start ? new Date(slot.start).getUTCDay() : null);\n\n      // âœ… 1) Preferencia por horas\n      if (hourLocal >= 9 && hourLocal <= 11) {\n        score += 3; // maÃ±ana media\n      } else if (hourLocal >= 8 && hourLocal < 9) {\n        score += 2; // temprano\n      } else if (hourLocal >= 14 && hourLocal <= 16) {\n        score += 2; // tarde temprana\n      } else {\n        score += 1; // otros\n      }\n\n      // âœ… 2) Sede preferida\n      if (ctx?.sedePreferida && String(ctx.sedePreferida).toUpperCase() === String(slot.sede).toUpperCase()) {\n        score += 5;\n      }\n\n      // âœ… 3) TimeWindow hit (si upstream marcÃ³)\n      if (slot.twHit === true) {\n        score += 4;\n      }\n\n      // âœ… 4) Proximidad temporal\n      if (slot.start) {\n        const daysAway = Math.floor((new Date(slot.start) - Date.now()) / 86_400_000);\n        if (Number.isFinite(daysAway)) {\n          if (daysAway <= 2) score += 2;\n          else if (daysAway <= 5) score += 1;\n        }\n      }\n\n      // âœ… 5) Penalizar sÃ¡bados ligeramente\n      if (dow === 6) score -= 1;\n\n      // âœ… 6) Bonus :00\n      if (minuteLocal === 0) score += 0.5;\n\n      // âœ… 7) WeekType (bonus ligero para A)\n      if (slot.weekType === 'A') score += 0.3;\n\n      return {\n        ...slot,\n        label: slot.label || slot.shiftLabel || slot.title || null,\n        _score: Number(score.toFixed(2)),\n      };\n    })\n    .sort((a, b) => {\n      if (b._score !== a._score) return b._score - a._score;\n      return new Date(a.start) - new Date(b.start);\n    });\n}\n\n// ==================== MAIN ====================\ntry {\n  const startTime = Date.now();\n  if (DEBUG) console.log('ğŸš€ CALC_AVAILABILITY v9.0 iniciando...');\n\n  // 1) Obtener datos de COMBINE_BUSY\n  const combineBusy = getCombineBusyData();\n  const ctx = combineBusy.ctx || {};\n  const requestId = combineBusy.requestId || ctx.requestId || `calc-${Date.now()}`;\n\n  // 2) Extraer slots YA filtrados por SCHEDULE_GATE + COMBINE_BUSY\n  const allowedSlots = Array.isArray(combineBusy?.scheduleGate?.allowedSlots)\n    ? combineBusy.scheduleGate.allowedSlots\n    : [];\n\n  if (DEBUG) {\n    console.log('ğŸ“Š Input data:', {\n      requestId,\n      allowedSlots: allowedSlots.length,\n      sedes: [...new Set(allowedSlots.map((s) => s.sede))],\n      windowStart: ctx.windowStart,\n      windowEnd: ctx.windowEnd,\n    });\n  }\n\n  // 3) Si no hay slots â†’ salida temprana\n  if (allowedSlots.length === 0) {\n    const gateDecision = combineBusy.scheduleGate?.decision || null;\n\n    return [\n      {\n        json: {\n          kind: 'avail',\n          version: VERSION,\n          requestId,\n          allowedSlots: [],\n          summary: {\n            totalAvailable: 0,\n            bySede: {},\n            byDay: {},\n            firstAvailable: null,\n          },\n          message: gateDecision?.reason || 'No hay slots disponibles en la ventana solicitada',\n          gateDecision,\n          metrics: {\n            executionTimeMs: Date.now() - startTime,\n            inputSlots: 0,\n            rankedSlots: 0,\n            finalReturned: 0,\n          },\n          build: {\n            version: VERSION,\n            generatedAt: new Date().toISOString(),\n            combineBusyVersion: combineBusy.build?.version,\n            scheduleVersion: combineBusy.build?.scheduleVersion,\n          },\n          timestamp: new Date().toISOString(),\n        },\n      },\n    ];\n  }\n\n  // 4) Ranking/scoring\n  if (DEBUG) console.log('ğŸ¯ Aplicando ranking...');\n  const ranked = rankSlots(allowedSlots, ctx);\n\n  // 5) maxResults del context (fallback 50)\n  const MAX_OUTPUT_SLOTS = 50;\n  const limit = Number.isFinite(Number(ctx.maxResults)) ? Number(ctx.maxResults) : MAX_OUTPUT_SLOTS;\n  const topK = ranked.slice(0, Math.max(0, limit));\n\n  if (DEBUG) console.log(`ğŸ“‹ Resultados: ${ranked.length} rankeados, top ${topK.length} retornados`);\n\n  // 6) Summary\n  const summary = {\n    totalAvailable: ranked.length,\n    bySede: {},\n    byDay: {},\n    firstAvailable: topK[0]\n      ? {\n          start: topK[0].start,\n          startLocal: topK[0].startLocal || null,\n          sede: topK[0].sede,\n          label: topK[0].label || null,\n        }\n      : null,\n  };\n\n  for (const slot of ranked) {\n    summary.bySede[slot.sede] = (summary.bySede[slot.sede] || 0) + 1;\n    const dayKey = slot.dayKey || (slot.start ? String(slot.start).split('T')[0] : 'unknown');\n    summary.byDay[dayKey] = (summary.byDay[dayKey] || 0) + 1;\n  }\n\n  // 7) MÃ©tricas\n  const metrics = {\n    executionTimeMs: Date.now() - startTime,\n    inputSlots: allowedSlots.length,\n    rankedSlots: ranked.length,\n    finalReturned: topK.length,\n    limitApplied: limit,\n    maxResultsFromContext: !!ctx.maxResults,\n    topScore: topK[0]?._score || 0,\n    averageScore:\n      ranked.length > 0 ? Number((ranked.reduce((sum, s) => sum + s._score, 0) / ranked.length).toFixed(2)) : 0,\n  };\n\n  // 8) Output final\n  const output = {\n    kind: 'avail',\n    version: VERSION,\n    requestId,\n\n    allowedSlots: topK,\n    summary,\n    metrics,\n\n    // Contexto original Ãºtil para auditorÃ­a\n    query: ctx.originalInput || {},\n\n    // InformaciÃ³n de filtros aplicados en la consulta (los filtros ya se aplicaron upstream)\n    filters: {\n      sedePreferida: ctx.sedePreferida || null,\n      timeWindow: ctx.timeWindow || null,\n      windowDays: ctx.windowDays || null,\n      onlyMorning: !!ctx.onlyMorning,\n      onlyAfternoon: !!ctx.onlyAfternoon,\n      includeWeekends: ctx.includeWeekends !== false,\n    },\n\n    // DecisiÃ³n del Gate (Ãºtil para UI/mensajes)\n    gateDecision: combineBusy.scheduleGate?.decision || null,\n\n    // Metadata Ãºtil\n    build: {\n      version: VERSION,\n      generatedAt: new Date().toISOString(),\n      combineBusyVersion: combineBusy.build?.version,\n      scheduleVersion: combineBusy.build?.scheduleVersion,\n    },\n\n    timestamp: new Date().toISOString(),\n  };\n\n  if (DEBUG) {\n    console.log('âœ… CALC_AVAILABILITY v9.0 completado', {\n      topSlot: topK[0] ? `${topK[0].sede} ${topK[0].startLocal || topK[0].start}` : 'none',\n      score: topK[0]?._score,\n      executionMs: metrics.executionTimeMs,\n    });\n  }\n\n  return [{ json: output }];\n} catch (error) {\n  console.error('âŒ Error en CALC_AVAILABILITY:', error);\n  return [\n    {\n      json: {\n        kind: 'error',\n        component: 'CALC_AVAILABILITY',\n        version: VERSION,\n        error: error.message || String(error),\n        stack: DEBUG ? error.stack : undefined,\n        timestamp: new Date().toISOString(),\n      },\n    },\n  ];\n}\n"
      },
      "id": "0ba7e0a9-4d7e-47c8-8150-9f2fb4f3301a",
      "name": "Calc Availability",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        2000
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * SET_DEFAULTS v5.3.0 â€” autocarga de horarios + â€œprÃ³ximo viernesâ€ correcto\n * - Carga SCHEDULE en este orden: input (CARGAR_HORARIOS) â†’ nodo CARGAR_HORARIOS â†’ WorkflowStaticData\n * - Usa sedesMap (objeto real) y meta (aliases) si estÃ¡n presentes\n * - Lee userText o __intent.userText\n * - Soporta â€œprÃ³ximo {dÃ­a}â€, â€œeste {dÃ­a}â€, y dÃ­a suelto\n * - Devuelve windowStart/windowEnd en ISO local 00:00 y llaves YMD para compatibilidad\n */\n\nconst VERSION = '5.3.0';\nconst DEBUG = false;\n\n/* ===================== CONFIG ===================== */\nconst CONFIG = Object.freeze({\n  DEFAULT_WINDOW_DAYS: 14,\n  MAX_WINDOW_DAYS: 90,\n  MAX_INPUT_LENGTH: 500,\n  SLOT_MINUTES: 30,\n  SHORT_NOTICE_MIN: 120,\n  CONFIRMATION_BUFFER_MIN: 15,\n  TZ: 'America/Mexico_City',\n  DAY_NAME_TO_DOW: { 'domingo':0,'lunes':1,'martes':2,'miercoles':3,'miÃ©rcoles':3,'jueves':4,'viernes':5,'sabado':6,'sÃ¡bado':6 },\n  RELATIVE_BASE: ['hoy','maÃ±ana','manana','pasado','pasado maÃ±ana','pasado manana'],\n});\n\nconst LOGS = [];\nconst log = (lvl,msg,data={})=>{\n  if (!DEBUG && lvl==='DEBUG') return;\n  LOGS.push({timestamp:new Date().toISOString(), level:lvl, component:'SET_DEFAULTS', version:VERSION, message:msg, ...data});\n  if (DEBUG) console.log(`[${lvl}] ${msg}`, data);\n};\n\n/* ===================== FECHAS / TZ ===================== */\nfunction dtPartsInTZ(d, tz){\n  const dtf = new Intl.DateTimeFormat('en-CA',{ timeZone:tz, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false });\n  const p = dtf.formatToParts(d).reduce((A,x)=> (A[x.type]=x.value, A), {});\n  return { y:+p.year, m:+p.month, d:+p.day, hh:+p.hour, mm:+p.minute, ss:+p.second };\n}\nfunction ymdInTZ(d, tz){ const p=dtPartsInTZ(d,tz); return `${p.y}-${String(p.m).padStart(2,'0')}-${String(p.d).padStart(2,'0')}`; }\nfunction isoStartOfDayLocal(dateKey, tz){\n  const [y,m,d] = dateKey.split('-').map(Number);\n  // construir 00:00:00 local en tz (corrigiendo DST)\n  const guess = new Date(Date.UTC(y, m-1, d, 0,0,0));\n  const seen = dtPartsInTZ(guess, tz);\n  // queremos y-m-d 00:00 locales\n  const want = Date.UTC(y, m-1, d, 0,0,0);\n  const seenMs = Date.UTC(seen.y, seen.m-1, seen.d, seen.hh, seen.mm, seen.ss);\n  const corrected = new Date(guess.getTime() + (want - seenMs));\n  return corrected.toISOString();\n}\nfunction addDaysYMD(dateKey, days){\n  const [y,m,d] = dateKey.split('-').map(Number);\n  const u = Date.UTC(y, m-1, d, 12,0,0);\n  const n = new Date(u + days*86400000);\n  return `${n.getUTCFullYear()}-${String(n.getUTCMonth()+1).padStart(2,'0')}-${String(n.getUTCDate()).padStart(2,'0')}`;\n}\nfunction getUTCDayFromYMD(dateKey){ const [y,m,d] = dateKey.split('-').map(Number); return new Date(Date.UTC(y,m-1,d,12,0,0)).getUTCDay(); }\nfunction findNextDow(fromYMD, targetDow, strict){\n  // strict=true: mÃ­nimo +1 dÃ­a; strict=false: puede ser el mismo dÃ­a\n  let cur = fromYMD;\n  for (let i=0;i<8;i++){\n    const dow = getUTCDayFromYMD(cur);\n    if (dow === targetDow && (!strict ? true : i>0)) return cur;\n    cur = addDaysYMD(cur,1);\n  }\n  return cur;\n}\n\n/* ===================== SCHEDULE LOADER ===================== */\nfunction pickSedesFromInput(inputJson){\n  // Preferir sedesMap (objeto real con turnos), nunca resume (strings)\n  if (inputJson?.sedesMap && typeof inputJson.sedesMap === 'object') return inputJson.sedesMap;\n  if (inputJson?.sedes && typeof inputJson.sedes === 'object' && !Array.isArray(inputJson.sedes)) return inputJson.sedes;\n  return null;\n}\nfunction loadSchedule(json){\n  // 1) Input directo del caller (CARGAR_HORARIOS)\n  if (json?.kind==='config' && json?.component==='CARGAR_HORARIOS'){\n    const sedes = pickSedesFromInput(json) || {};\n    const schedule = { tz: json.tz || CONFIG.TZ, anchor: json.anchor, rest: json.rest || {}, sedes, meta: json.meta || {} };\n    log('SUCCESS','SCHEDULE desde input',{ version: json.version, sedes: Object.keys(schedule.sedes) });\n    return { schedule, version: json.version, updatedAt: json.updatedAt };\n  }\n  // 2) Intentar leer la salida del nodo CARGAR_HORARIOS (si existe en el grafo)\n  try {\n    const n = $('CARGAR_HORARIOS').first().json;\n    if (n?.kind==='config'){\n      const sedes = pickSedesFromInput(n) || {};\n      const schedule = { tz: n.tz || CONFIG.TZ, anchor: n.anchor, rest: n.rest || {}, sedes, meta: n.meta || {} };\n      log('SUCCESS','SCHEDULE desde nodo CARGAR_HORARIOS',{ version: n.version, sedes: Object.keys(schedule.sedes) });\n      return { schedule, version: n.version, updatedAt: n.updatedAt };\n    }\n  } catch(e){ /* no-op */ }\n\n  // 3) WorkflowStaticData (global)\n  try{\n    const store = (typeof $getWorkflowStaticData==='function') ? $getWorkflowStaticData('global') : this.getWorkflowStaticData('global');\n    if (store?.SCHEDULE?.sedes){\n      const S = store.SCHEDULE;\n      const schedule = { tz: S.tz || CONFIG.TZ, anchor: S.anchor, rest: S.rest || {}, sedes: S.sedes, meta: S.meta || {} };\n      log('SUCCESS','SCHEDULE desde WorkflowStaticData',{ version: store.SCHEDULE_VERSION, sedes: Object.keys(schedule.sedes) });\n      return { schedule, version: store.SCHEDULE_VERSION, updatedAt: store.SCHEDULE_UPDATED_AT };\n    }\n  } catch(e){ /* no-op */ }\n\n  throw new Error('SCHEDULE no disponible. Ejecuta CARGAR_HORARIOS o publica al static data.');\n}\n\n/* ===================== PARSERS ===================== */\nconst norm = s => (s||'').toLowerCase().normalize('NFD').replace(/[\\u0300-\\u036f]/g,'').replace(/\\s+/g,' ').trim();\n\nfunction extractUserText(json){\n  const raw =\n    json.userText || json.query || json.text || json.message || json.user_query || json.content ||\n    (json.__intent && json.__intent.userText) || '';\n  const t = String(raw).trim();\n  if (!t) return { ok:false, raw:'', normalized:'' };\n  if (t.length > CONFIG.MAX_INPUT_LENGTH) return { ok:true, raw: t.slice(0,CONFIG.MAX_INPUT_LENGTH), normalized: norm(t.slice(0,CONFIG.MAX_INPUT_LENGTH)) };\n  return { ok:true, raw:t, normalized:norm(t) };\n}\n\nfunction fuzzySedeFromText(text, meta){\n  if (!text) return { sedePreferida:'', strict:false };\n  const found = [];\n  const metas = meta && typeof meta==='object' ? meta : {};\n  for (const [sede, m] of Object.entries(metas)){\n    const aliases = (m.aliases || []).map(a => String(a).toLowerCase());\n    if (aliases.some(a => text.includes(a))) found.push(sede);\n  }\n  if (found.length===1) return { sedePreferida: found[0], strict:true };\n  if (found.length>1)  return { sedePreferida: found[0], strict:false };\n  return { sedePreferida:'', strict:false };\n}\n\nfunction parseDatesFromText(text, tz, referenceYMD){\n  // Detecta â€œprÃ³ximo {dÃ­a}â€, â€œsiguiente {dÃ­a}â€, â€œeste {dÃ­a}â€, o dÃ­a suelto\n  // Prioridad: prÃ³ximo/siguiente > este > dÃ­a suelto\n  const explicit = [];\n  const lower = text;\n\n  const dowMap = CONFIG.DAY_NAME_TO_DOW;\n  const dowNames = Object.keys(dowMap).sort((a,b)=>b.length-a.length); // evita colisiones (miÃ© vs miercoles)\n  const findDowIn = (s) => {\n    for (const name of dowNames) if (s.includes(name)) return dowMap[name];\n    return null;\n  };\n\n  // prÃ³ximo/siguiente\n  if (/\\b(prox|proximo|prÃ³ximo|siguiente)\\b/.test(lower)){\n    const d = findDowIn(lower);\n    if (d!=null){ explicit.push(findNextDow(referenceYMD, d, /*strict*/true)); }\n  }\n  // este\n  else if (/\\b(este)\\b/.test(lower)){\n    const d = findDowIn(lower);\n    if (d!=null){ explicit.push(findNextDow(referenceYMD, d, /*strict*/false)); }\n  }\n  // dÃ­a suelto\n  else {\n    const d = findDowIn(lower);\n    if (d!=null){ explicit.push(findNextDow(referenceYMD, d, /*strict*/false)); }\n  }\n\n  // Relativos base (hoy/maÃ±ana/pasado)\n  const rel = [\n    { re:/\\bhoy\\b/, add:0 },\n    { re:/\\b(ma[Ã±n]ana)\\b/, add:1 },\n    { re:/\\b(pasado(\\s+ma[Ã±n]ana)?)\\b/, add:2 },\n  ];\n  for (const r of rel) if (r.re.test(lower)) explicit.push(addDaysYMD(referenceYMD, r.add));\n\n  // Ventana\n  const unique = Array.from(new Set(explicit)).sort();\n  let windowStartYMD = referenceYMD;\n  let windowEndYMD   = addDaysYMD(referenceYMD, CONFIG.DEFAULT_WINDOW_DAYS);\n  if (unique.length>0){\n    windowStartYMD = unique[0];\n    windowEndYMD   = unique.length>1 ? unique[unique.length-1] : addDaysYMD(unique[0], 1);\n  }\n\n  return { explicitDates: unique, windowStartYMD, windowEndYMD, dateIntent: unique.length>0 ? 'specific' : 'flexible' };\n}\n\n/* ===================== MAIN ===================== */\ntry {\n  const t0 = Date.now();\n\n  // 1) Cargar schedule\n  const scheduleData = loadSchedule($json);\n  const SCHEDULE = scheduleData.schedule;\n  const TZ = SCHEDULE.tz || CONFIG.TZ;\n\n  // 2) â€œAhoraâ€ en tz\n  const now = new Date();\n  const todayYMD = ymdInTZ(now, TZ);\n\n  // 3) Intento de texto\n  const textInfo = extractUserText($json);\n  const textNorm = textInfo.normalized;\n\n  // 4) Sede fuzzy desde meta\n  const sedeInfo = fuzzySedeFromText(textNorm, SCHEDULE.meta);\n\n  // 5) Punto de referencia:\n  //    â€“ Si el caller mete desiredStart â€œpor defaultâ€ (ahora), lo ignoramos si HAY lenguaje de fecha en el texto.\n  //    â€“ Si el texto NO trae fecha, usamos desiredStart (si es vÃ¡lido) como referencia; si no, hoy.\n  let referenceYMD = todayYMD;\n  const hasDateWords = CONFIG.RELATIVE_BASE.some(w => textNorm.includes(w)) ||\n                       Object.keys(CONFIG.DAY_NAME_TO_DOW).some(k => textNorm.includes(k)) ||\n                       /\\b(prox|proximo|prÃ³ximo|siguiente|este)\\b/.test(textNorm);\n\n  if (!hasDateWords && $json.desiredStart) {\n    const ms = Date.parse($json.desiredStart);\n    if (Number.isFinite(ms)) referenceYMD = ymdInTZ(new Date(ms), TZ);\n  }\n\n  // 6) Parseo de fechas\n  const dInfo = parseDatesFromText(textNorm, TZ, referenceYMD);\n\n  // 7) Construir ventana ISO (inicio/fin a medianoche local)\n  const windowStartISO = isoStartOfDayLocal(dInfo.windowStartYMD, TZ);\n  const windowEndISO   = isoStartOfDayLocal(dInfo.windowEndYMD,   TZ);\n\n  // 8) ParÃ¡metros adicionales\n  const windowDays = Math.max(1, Math.min(CONFIG.MAX_WINDOW_DAYS,\n                       Math.ceil((new Date(windowEndISO)-new Date(windowStartISO))/86400000)));\n\n  // 9) Contexto final\n  const context = {\n    kind: 'context',\n    version: VERSION,\n\n    originalInput: { raw: textInfo.raw || '', normalized: textNorm || '' },\n    locale: 'es-MX',\n    tz: TZ,\n\n    // Ventana (ISO + YMD para compatibilidad)\n    windowStart: windowStartISO,\n    windowEnd:   windowEndISO,\n    windowStartDateKey: dInfo.windowStartYMD,\n    windowEndDateKey:   dInfo.windowEndYMD,\n    computedWindowDays: windowDays,\n\n    // IntenciÃ³n y filtros\n    dateIntent: dInfo.dateIntent,\n    explicitDates: dInfo.explicitDates, // YMDs\n    timeWindow: null,\n\n    // Sede\n    sedePreferida: sedeInfo.sedePreferida,\n    sedes: sedeInfo.sedePreferida ? [sedeInfo.sedePreferida] : Object.keys(SCHEDULE.sedes||{}),\n    strictSede: !!sedeInfo.strict,\n\n    // LÃ­mites operativos\n    windowDays: Number.isFinite($json.windowDays) ? $json.windowDays : CONFIG.DEFAULT_WINDOW_DAYS,\n    maxResults: Number.isFinite($json.maxResults) ? $json.maxResults : 50,\n    includeWeekends: $json.includeWeekends !== false,\n    onlyMorning: !!$json.onlyMorning,\n    onlyAfternoon: !!$json.onlyAfternoon,\n    requestId: $json.requestId || `req-${Date.now()}-${Math.random().toString(36).slice(2,9)}`,\n    source: $json.source || 'unknown',\n\n    constraints: {\n      shortNoticeMin: CONFIG.SHORT_NOTICE_MIN,\n      confirmationBufferMin: CONFIG.CONFIRMATION_BUFFER_MIN,\n      slotMinutes: CONFIG.SLOT_MINUTES,\n      maxWindowDays: CONFIG.MAX_WINDOW_DAYS\n    },\n\n    scheduleMetadata: {\n      version: scheduleData.version,\n      updatedAt: scheduleData.updatedAt,\n      anchor: SCHEDULE.anchor,\n      sedes: Object.keys(SCHEDULE.sedes || {})\n    },\n\n    metadata: { executionTimeMs: Date.now()-t0, logsCount: LOGS.length }\n  };\n\n  if (DEBUG) context._logs = LOGS;\n\n  log('SUCCESS','SET_DEFAULTS completado',{\n    dateIntent: context.dateIntent,\n    sede: context.sedePreferida,\n    start: context.windowStart,\n    end: context.windowEnd\n  });\n\n  return [{ json: context }];\n\n} catch (error){\n  log('ERROR','Error fatal',{ error: error.message, stack: error.stack });\n  return [{\n    json: {\n      kind:'error', component:'SET_DEFAULTS', version:VERSION,\n      error:'UNEXPECTED_ERROR', message: error.message || String(error),\n      timestamp: new Date().toISOString(), logs: DEBUG ? LOGS : undefined\n    }\n  }];\n}\n"
      },
      "id": "2f644883-31c5-47f0-b75f-1ca7a842a24f",
      "name": "SET_DEFAULTS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        2000
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * SCHEDULE_GATE v15.2 - Gate de agenda con SCHEDULE centralizado y filtros\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * Cambios v15.2:\n * - Lee SCHEDULE/HELPERS desde Workflow Static Data. Si falta, retorna error\n *   estructurado (no lanza excepciÃ³n) con guÃ­a para recuperaciÃ³n.\n * - Consume context de SET_DEFAULTS v4.1 directamente (sin params).\n * - Aplica filtros: includeWeekends, onlyMorning, onlyAfternoon, timeWindow.\n * - Usa HELPERS: normalizeSede, isWorkingDay, getShiftsForSedeAndDay, getWeekType\n *   (con fallback local si el helper no existe).\n * - TZ efectiva: context.tz tiene prioridad, luego SCHEDULE.tz, luego 'America/Mexico_City'.\n * - Respeta maxResults del context limitando la salida.\n * - âœ… NUEVO: cada slot trae startLocal, endLocal, startHM y dow.\n */\n\nconst VERSION = '15.2.1';\nconst DEBUG = true;\n\n// ==================== LOGGING ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'SCHEDULE_GATE',\n    version: VERSION,\n    message,\n    ...data,\n  };\n  LOGS.push(entry);\n  if (DEBUG) {\n    const emoji = { INFO: 'â„¹ï¸', WARN: 'âš ï¸', ERROR: 'âŒ', DEBUG: 'ğŸ”', SUCCESS: 'âœ…' }[level.toUpperCase()] || 'ğŸ“';\n    console.log(`${emoji} [${level.toUpperCase()}] ${message}`, data);\n  }\n}\n\n// ==================== TIMEZONE / DATE HELPERS ====================\nlet _formattersCache = {};\nfunction getFormatters(tz) {\n  if (!_formattersCache[tz]) {\n    _formattersCache[tz] = {\n      tz,\n      DTF_FULL: new Intl.DateTimeFormat('en-CA', {\n        timeZone: tz,\n        year: 'numeric', month: '2-digit', day: '2-digit',\n        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false,\n      }),\n      DTF_DISPLAY: new Intl.DateTimeFormat('es-MX', {\n        timeZone: tz,\n        weekday: 'long', year: 'numeric', month: '2-digit', day: '2-digit',\n        hour: '2-digit', minute: '2-digit', hour12: false,\n      }),\n    };\n  }\n  return _formattersCache[tz];\n}\nfunction getLocalParts(date, DTF_FULL) {\n  const parts = DTF_FULL.formatToParts(date);\n  const obj = {};\n  for (const p of parts) obj[p.type] = p.value;\n  return { y: +obj.year, m: +obj.month, d: +obj.day, hh: +obj.hour, mm: +obj.minute, ss: +obj.second };\n}\nfunction localToUTC(y, m, d, hh = 0, mm = 0, ss = 0, DTF_FULL) {\n  const naive = Date.UTC(y, m - 1, d, hh, mm, ss);\n  const asLocal = getLocalParts(new Date(naive), DTF_FULL);\n  const localEpoch = Date.UTC(asLocal.y, asLocal.m - 1, asLocal.d, asLocal.hh, asLocal.mm, asLocal.ss);\n  return naive - (localEpoch - naive);\n}\nfunction timeAtDay(date, hhmm, DTF_FULL) {\n  const [hh, mm] = hhmm.split(':').map(Number);\n  const p = getLocalParts(date, DTF_FULL);\n  return new Date(localToUTC(p.y, p.m, p.d, hh, mm, 0, DTF_FULL)).toISOString();\n}\nfunction formatLocal(iso, DTF_DISPLAY) { return DTF_DISPLAY.format(new Date(iso)); }\nfunction hhmmToMinutes(hhmm) { const [h, m] = hhmm.split(':').map(Number); return h * 60 + m; }\nfunction minutesToHHMM(mins) { const h = Math.floor(mins / 60), m = mins % 60; return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`; }\n\n// âœ… NUEVO: obtener HH:MM local desde un ISO\nfunction formatHHMM(iso, tz) {\n  const dtf = new Intl.DateTimeFormat('en-US', {\n    timeZone: tz,\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false,\n  });\n  const parts = dtf.formatToParts(new Date(iso));\n  const hh = parts.find(p => p.type === 'hour')?.value || '00';\n  const mm = parts.find(p => p.type === 'minute')?.value || '00';\n  return `${hh}:${mm}`;\n}\n\n// ==================== VALIDACIÃ“N & CONTEXT ====================\nfunction validateContextFromInput(item) {\n  if (!item?.json) return { valid: false, error: 'EMPTY_INPUT', message: 'Entrada vacÃ­a en SCHEDULE_GATE' };\n  const ctx = item.json;\n  if (ctx.kind === 'error') return { valid: false, propagateError: true, originalError: ctx };\n  if (ctx.kind !== 'context') return { valid: false, error: 'INVALID_INPUT_KIND', message: `Esperado kind='context', recibiÃ³ '${ctx.kind || 'undefined'}'` };\n  const required = ['windowStart', 'windowEnd', 'tz'];\n  const missing = required.filter((f) => !ctx[f]);\n  if (missing.length) return { valid: false, error: 'MISSING_REQUIRED_FIELDS', message: `Faltan campos: ${missing.join(', ')}` };\n  const startMs = new Date(ctx.windowStart).getTime();\n  const endMs = new Date(ctx.windowEnd).getTime();\n  if (isNaN(startMs) || isNaN(endMs) || startMs >= endMs) return { valid: false, error: 'INVALID_WINDOW', message: 'windowStart/windowEnd invÃ¡lidos' };\n  return { valid: true, ctx };\n}\n\n// ==================== FALLBACKS (si faltan HELPERS) ====================\nfunction computeWeekTypeFallback(dateKey, anchor) {\n  try {\n    const anchorDate = new Date(anchor?.date ? `${anchor.date}T00:00:00Z` : '2025-01-06T00:00:00Z');\n    const d = new Date(`${dateKey}T00:00:00Z`);\n    const MS_PER_DAY = 86400000;\n    const days = Math.floor((d - anchorDate) / MS_PER_DAY);\n    const weeks = Math.floor(days / 7);\n    const anchorType = anchor?.type || 'A';\n    const isEven = weeks % 2 === 0; // pares = tipo anchor\n    return isEven ? anchorType : (anchorType === 'A' ? 'B' : 'A');\n  } catch (e) {\n    log('WARN', 'computeWeekTypeFallback error', { dateKey, e: e.message });\n    return 'A';\n  }\n}\n\n// ==================== GENERACIÃ“N DE SLOTS ====================\nfunction generateSlots(ctx, SCHEDULE, HELPERS, CFG, DTF_FULL, DTF_DISPLAY) {\n  log('INFO', 'ğŸ¯ Iniciando generaciÃ³n de slots', { sedes: ctx.sedes, sedePreferida: ctx.sedePreferida });\n\n  const windowStartMs = new Date(ctx.windowStart).getTime();\n  const windowEndMs = new Date(ctx.windowEnd).getTime();\n  const now = Date.now();\n  const shortNoticeMin = ctx.constraints?.shortNoticeMin || CFG.SHORT_NOTICE_MIN;\n  const shortNoticeBuffer = now + shortNoticeMin * 60000;\n\n  // Determinar sedes a evaluar\n  let sedesToCheck = Array.isArray(ctx.sedes) && ctx.sedes.length ? ctx.sedes.slice() : Object.keys(SCHEDULE.sedes || {});\n  if (ctx.sedePreferida) {\n    const normalized = HELPERS?.normalizeSede ? HELPERS.normalizeSede(ctx.sedePreferida) : ctx.sedePreferida;\n    if (normalized) sedesToCheck = [normalized];\n    log('info', 'Sede normalizada', { original: ctx.sedePreferida, normalized });\n  }\n\n  const includeWeekends = ctx.includeWeekends !== false; // default true\n  const onlyMorning = !!ctx.onlyMorning;\n  const onlyAfternoon = !!ctx.onlyAfternoon;\n  const tw = ctx.timeWindow || null; // {startMin, endMin}\n\n  const allowed = [];\n  const allowedSlots = [];\n  const skipped = { weekends: 0, restDay: 0, noSchedule: 0, wrongWeekType: 0, morningFilter: 0, afternoonFilter: 0, timeWindow: 0, shortNotice: 0, outsideWindow: 0, partialSlot: 0, invalidGrid: 0 };\n\n  const MS_PER_DAY = 86400000;\n  let totalSlotsGenerated = 0;\n\n  for (const sede of sedesToCheck) {\n    const sedeSchedule = (SCHEDULE.sedes || {})[sede];\n    if (!sedeSchedule) { log('WARN', 'Sede no encontrada en SCHEDULE', { sede }); continue; }\n\n    for (let currentMs = windowStartMs; currentMs <= windowEndMs; currentMs += MS_PER_DAY) {\n      const currentDate = new Date(currentMs);\n      const p = getLocalParts(currentDate, DTF_FULL);\n      const localDate = new Date(Date.UTC(p.y, p.m - 1, p.d));\n      const dow = localDate.getUTCDay(); // 0..6\n      const dateKey = `${p.y}-${String(p.m).padStart(2, '0')}-${String(p.d).padStart(2, '0')}`;\n\n      // 1) Fines de semana\n      if (!includeWeekends && (dow === 0 || dow === 6)) { skipped.weekends++; continue; }\n      // 2) DÃ­a de descanso general\n      if (SCHEDULE.rest && SCHEDULE.rest[dow]) { skipped.restDay++; continue; }\n      // 3) DÃ­a laborable por sede\n      if (HELPERS?.isWorkingDay && !HELPERS.isWorkingDay(sede, dow)) { skipped.noSchedule++; continue; }\n\n      // Week type\n      const weekType = HELPERS?.getWeekType\n        ? HELPERS.getWeekType(dateKey, SCHEDULE.anchor)\n        : computeWeekTypeFallback(dateKey, SCHEDULE.anchor);\n\n      // Turnos del dÃ­a\n      let shifts = HELPERS?.getShiftsForSedeAndDay ? HELPERS.getShiftsForSedeAndDay(sede, dow, weekType) : null;\n      if (!shifts || !shifts.length) { skipped.noSchedule++; continue; }\n\n      // Normalizar a objetos {start,end,label,weekType}\n      let normalizedShifts = shifts.map((s) => Array.isArray(s)\n        ? { start: s[0], end: s[1], label: s[2] || `${s[0]}-${s[1]}`, weekType }\n        : { start: s.start, end: s.end, label: s.label || `${s.start}-${s.end}`, weekType: s.weekType || weekType }\n      );\n\n      // 4) Filtro morning / afternoon\n      if (onlyMorning) {\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter((sh) => parseInt(sh.start.split(':')[0], 10) < 14);\n        skipped.morningFilter += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n      if (onlyAfternoon) {\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter((sh) => parseInt(sh.start.split(':')[0], 10) >= 14);\n        skipped.afternoonFilter += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n\n      // 5) Filtro por ventana horaria (overlap)\n      if (tw && (typeof tw.startMin === 'number' || typeof tw.endMin === 'number')) {\n        const reqStart = typeof tw.startMin === 'number' ? tw.startMin : 0;\n        const reqEnd = typeof tw.endMin === 'number' ? tw.endMin : 24 * 60;\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter((sh) => {\n          const sMin = hhmmToMinutes(sh.start);\n          const eMin = hhmmToMinutes(sh.end);\n          return sMin < reqEnd && eMin > reqStart; // overlap\n        });\n        skipped.timeWindow += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n\n      // 6) GeneraciÃ³n de slots\n      for (const sh of normalizedShifts) {\n        const shiftStartMs = new Date(timeAtDay(currentDate, sh.start, DTF_FULL)).getTime();\n        const shiftEndMs = new Date(timeAtDay(currentDate, sh.end, DTF_FULL)).getTime();\n        const slotDurationMs = (SCHEDULE.config?.consultationDuration || 30) * 60000;\n        const anchors = (SCHEDULE.config?.slotAnchors || [0, 30]);\n\n        for (let cursor = shiftStartMs; cursor < shiftEndMs; cursor += slotDurationMs) {\n          const slotStartMs = cursor;\n          const slotEndMs = cursor + slotDurationMs;\n          if (slotEndMs > shiftEndMs) { skipped.partialSlot++; break; }\n\n          // anclajes (:00/:30)\n          const mins = new Date(slotStartMs).getUTCMinutes();\n          if (!anchors.includes(mins)) { skipped.invalidGrid++; continue; }\n          // short notice\n          if (slotStartMs < shortNoticeBuffer) { skipped.shortNotice++; continue; }\n          // ventana\n          if (slotStartMs < windowStartMs || slotStartMs >= windowEndMs) { skipped.outsideWindow++; continue; }\n\n          const startIso = new Date(slotStartMs).toISOString();\n          const endIso = new Date(slotEndMs).toISOString();\n\n          // ColecciÃ³n \"allowed\" minimalista\n          allowed.push({ start: startIso, end: endIso });\n\n          // âœ… Slot enriquecido con hora local y HH:MM local + DOW (UTC)\n          allowedSlots.push({\n            sede,\n            start: startIso,\n            end: endIso,\n            durationMinutes: (SCHEDULE.config?.consultationDuration || 30),\n            label: sh.label,\n            weekType: sh.weekType || weekType || null,\n            startLocal: formatLocal(startIso, DTF_DISPLAY),\n            endLocal: formatLocal(endIso, DTF_DISPLAY),\n            startHM: formatHHMM(startIso, CFG.TZ), // â† NUEVO\n            dayKey: dateKey,\n            dow: new Date(startIso).getUTCDay(),   // â† NUEVO (0..6)\n          });\n\n          totalSlotsGenerated++;\n        }\n      }\n    }\n  }\n\n  // Ordenar por fecha\n  allowed.sort((a, b) => new Date(a.start) - new Date(b.start));\n  allowedSlots.sort((a, b) => new Date(a.start) - new Date(b.start));\n\n  log('SUCCESS', 'âœ… GeneraciÃ³n de slots completada', { totalSlotsGenerated, skipped });\n  return { allowed, allowedSlots, skipped, totalSlotsGenerated, shortNoticeMin: shortNoticeMin };\n}\n\n// ==================== MAIN ====================\ntry {\n  log('INFO', `ğŸš€ SCHEDULE_GATE v${VERSION} iniciando`);\n\n  // (1) Cargar SCHEDULE/HELPERS desde Static Data\n  const store = (typeof $getWorkflowStaticData === 'function')\n    ? $getWorkflowStaticData('global')\n    : this.getWorkflowStaticData('global');\n\n  const SCHEDULE = store.SCHEDULE;\n  const HELPERS = store.SCHEDULE_HELPERS;\n\n  if (!SCHEDULE) {\n    const guidance = {\n      tip: 'Ejecute primero CARGAR_HORARIOS en este mismo workflow para poblar Workflow Static Data (global).',\n      expectedKeys: ['SCHEDULE', 'SCHEDULE_VERSION', 'SCHEDULE_UPDATED_AT', 'SCHEDULE_HELPERS (opcional)'],\n      foundKeys: Object.keys(store || {}),\n    };\n    log('ERROR', 'SCHEDULE ausente en Static Data', guidance);\n    return [{ json: { kind: 'error', component: 'SCHEDULE_GATE', version: VERSION, error: 'SCHEDULE_NOT_LOADED', message: 'SCHEDULE no cargado. Â¿EjecutÃ³ CARGAR_HORARIOS primero?', details: guidance, logs: LOGS } }];\n  }\n\n  log('info', 'SCHEDULE cargado desde Static Data', {\n    version: store.SCHEDULE_VERSION,\n    updatedAt: store.SCHEDULE_UPDATED_AT,\n    tz: SCHEDULE.tz,\n    sedes: Object.keys(SCHEDULE.sedes || {}),\n    hasHelpers: !!HELPERS,\n  });\n\n  // (2) Tomar context del input\n  const input = $input.first();\n  const validation = validateContextFromInput(input);\n  if (!validation.valid) {\n    if (validation.propagateError) { log('INFO', 'Propagando error upstream'); return [input]; }\n    log('ERROR', 'Entrada invÃ¡lida', validation);\n    return [{ json: { kind: 'error', component: 'SCHEDULE_GATE', version: VERSION, error: validation.error, message: validation.message, details: validation, logs: LOGS } }];\n  }\n  const ctx = validation.ctx;\n\n  // (3) CFG derivado\n  const baseTZ = SCHEDULE.tz || 'America/Mexico_City';\n  const CFG = {\n    TZ: ctx.tz || baseTZ,\n    CONSULTATION_DURATION_MIN: (SCHEDULE.config && SCHEDULE.config.consultationDuration) || 30,\n    ANCHORS: (SCHEDULE.config && SCHEDULE.config.slotAnchors) || [0, 30],\n    SHORT_NOTICE_MIN: (SCHEDULE.config && SCHEDULE.config.shortNoticeMinutes) || 120,\n  };\n  const { DTF_FULL, DTF_DISPLAY } = getFormatters(CFG.TZ);\n\n  // (4) Generar slots\n  const result = generateSlots(ctx, SCHEDULE, HELPERS, CFG, DTF_FULL, DTF_DISPLAY);\n\n  // (5) Aplicar maxResults si viene en context\n  let prunedAllowed = result.allowed;\n  let prunedAllowedSlots = result.allowedSlots;\n  if (typeof ctx.maxResults === 'number' && ctx.maxResults > 0) {\n    prunedAllowed = prunedAllowed.slice(0, ctx.maxResults);\n    prunedAllowedSlots = prunedAllowedSlots.slice(0, ctx.maxResults);\n  }\n\n  // (6) Resumen y respuesta\n  const summaryBySede = prunedAllowedSlots.reduce((acc, slot) => { acc[slot.sede] = (acc[slot.sede] || 0) + 1; return acc; }, {});\n\n  const response = {\n    kind: 'scheduleGate',\n    version: VERSION,\n    tz: CFG.TZ,\n    request: {\n      windowStart: ctx.windowStart,\n      windowEnd: ctx.windowEnd,\n      sedes: ctx.sedes,\n      sedePreferida: ctx.sedePreferida,\n      timeWindow: ctx.timeWindow || {},\n      includeWeekends: ctx.includeWeekends !== false,\n      onlyMorning: !!ctx.onlyMorning,\n      onlyAfternoon: !!ctx.onlyAfternoon,\n      maxResults: ctx.maxResults,\n      consultationDuration: CFG.CONSULTATION_DURATION_MIN,\n      requestId: ctx.requestId,\n    },\n    decision: {\n      isOpen: prunedAllowedSlots.length > 0,\n      reason: prunedAllowedSlots.length ? `${prunedAllowedSlots.length} opciones disponibles` : 'Sin horarios en el rango solicitado',\n      shortNoticeMinutes: result.shortNoticeMin,\n    },\n    allowed: prunedAllowed,\n    allowedSlots: prunedAllowedSlots, // â† ahora con startLocal, endLocal, startHM y dow\n    skipped: result.skipped,\n    summary: {\n      totalSlots: prunedAllowedSlots.length,\n      bySede: summaryBySede,\n      byDay: prunedAllowedSlots.reduce((acc, s) => { acc[s.dayKey] = (acc[s.dayKey] || 0) + 1; return acc; }, {}),\n    },\n    meta: {\n      scheduleVersion: store.SCHEDULE_VERSION,\n      scheduleUpdatedAt: store.SCHEDULE_UPDATED_AT,\n      grid: { stepMinutes: CFG.CONSULTATION_DURATION_MIN, anchors: CFG.ANCHORS },\n    },\n    _logs: DEBUG ? LOGS : undefined,\n  };\n\n  log('SUCCESS', 'âœ… SCHEDULE_GATE completado', { total: response.summary.totalSlots, bySede: summaryBySede });\n  return [{ json: response }];\n\n} catch (error) {\n  log('ERROR', 'Error fatal', { error: error.message, stack: error.stack });\n  return [{ json: { kind: 'error', component: 'SCHEDULE_GATE', version: VERSION, error: 'UNEXPECTED_ERROR', message: error.message || String(error), stack: DEBUG ? error.stack : undefined, logs: LOGS } }];\n}\n"
      },
      "id": "5ad411f0-32b2-4008-9ff1-37af3ecb662e",
      "name": "SCHEDULE_GATE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        2000
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * CARGAR_HORARIOS v2.1 â€” salida compatible con SET_DEFAULTS v5.2\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * Cambios clave:\n * - Exporta sedesMap (objeto real de horarios) para consumo directo.\n * - Mantiene resume solo para lectura humana (no para lÃ³gica).\n * - Renombra 'sedes' (array) a 'sedeKeys' para evitar confusiones.\n * - Elimina bloque 'metadata' duplicado (Ãºnica fuente: meta).\n */\n\nconst VERSION = '2.1.0';\nconst TZ = 'America/Mexico_City';\n\n// ==================== CONFIGURACIÃ“N DE HORARIOS ====================\nconst SCHEDULE = {\n  tz: TZ,\n  version: VERSION,\n\n  // Ancla para cÃ¡lculo de semanas alternas (sÃ¡bados)\n  anchor: {\n    date: '2025-01-06',\n    type: 'A',\n    description: 'Semana A de referencia para sÃ¡bados alternos'\n  },\n\n  // DÃ­as de descanso\n  rest: {\n    0: 'Domingo - Cerrado'\n  },\n\n  // DOW: 0=Dom, 1=Lun, 2=Mar, 3=MiÃ©, 4=Jue, 5=Vie, 6=SÃ¡b\n  sedes: {\n    POLANCO: {\n      1: [['09:00', '13:00', 'Lunes Matutino']],\n      2: [['16:00', '20:00', 'Martes Vespertino']],\n      5: [['15:00', '19:00', 'Viernes Vespertino']],\n    },\n    SATELITE: {\n      3: [['09:00', '13:00', 'MiÃ©rcoles Matutino']],\n      4: [\n        ['09:00', '13:00', 'Jueves Matutino'],\n        ['15:00', '20:00', 'Jueves Vespertino'],\n      ],\n      6: {\n        B: [['09:00', '13:00', 'SÃ¡bado Matutino (alterno)']]\n      },\n    },\n  },\n\n  // Metadata de sedes (incluye calendarId)\n  meta: {\n    POLANCO: {\n      name: 'Hospital Ãngeles Santa MÃ³nica, Polanco',\n      fullName: 'Hospital Ãngeles Santa MÃ³nica',\n      location: 'TemÃ­stocles 210, Polanco, CDMX',\n      aliases: ['polanco', 'angeles', 'temistocles', 'santa monica', 'POLANCO'],\n      calendarId: '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com',\n      workingDays: [1, 2, 5], // Lun, Mar, Vie\n      hasWeekends: false,\n    },\n    SATELITE: {\n      name: 'Hospital San Ãngel Inn SatÃ©lite',\n      fullName: 'Hospital San Ãngel Inn SatÃ©lite',\n      location: 'Cto. Centro Comercial 20, Cd. SatÃ©lite, Naucalpan',\n      aliases: ['satelite', 'satÃ©lite', 'san angel inn', 'naucalpan', 'SATELITE'],\n      calendarId: 'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com',\n      workingDays: [3, 4, 6], // MiÃ©, Jue, SÃ¡b (alterno)\n      hasWeekends: true,\n      notes: 'SÃ¡bados alternos (semana B)',\n    },\n  },\n\n  // ConfiguraciÃ³n global\n  config: {\n    consultationDuration: 30,           // minutos\n    slotAnchors: [0, 30],               // slots en :00 y :30\n    shortNoticeMinutes: 120,            // 2 horas mÃ­nimo de aviso\n    confirmationBufferMinutes: 15,      // buffer de confirmaciÃ³n\n    defaultWindowDays: 14,              // ventana default de bÃºsqueda\n    maxWindowDays: 90,                  // mÃ¡ximo de dÃ­as a futuro\n    maxSlots: 50,                       // mÃ¡ximo de slots por respuesta\n    businessDayStart: 8,                // 08:00\n    businessDayEnd: 20,                 // 20:00\n  },\n};\n\n// ==================== VALIDACIÃ“N DE ESQUEMA ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  LOGS.push({ timestamp: new Date().toISOString(), level: level.toUpperCase(), component: 'CARGAR_HORARIOS', version: VERSION, message, ...data });\n}\n\nconst isHHMM = (s) => {\n  if (typeof s !== 'string') return false;\n  const m = /^(\\d{2}):(\\d{2})$/.exec(s);\n  if (!m) return false;\n  const hh = +m[1], mm = +m[2];\n  return hh >= 0 && hh <= 23 && mm >= 0 && mm <= 59;\n};\n\nconst validateShift = (shift, sede, dow) => {\n  if (!Array.isArray(shift)) { log('error', 'Shift no es array', { sede, dow, shift }); return false; }\n  const [start, end, label] = shift;\n  if (!isHHMM(start)) { log('error', 'Start invÃ¡lido', { sede, dow, start }); return false; }\n  if (!isHHMM(end))   { log('error', 'End invÃ¡lido',   { sede, dow, end });   return false; }\n  const toMin = s => { const [h,m] = s.split(':').map(Number); return h*60+m; };\n  if (toMin(start) >= toMin(end)) { log('error', 'start >= end', { sede, dow, start, end }); return false; }\n  if (!label || typeof label !== 'string') log('warn','Label faltante o invÃ¡lido',{ sede, dow, label });\n  return true;\n};\n\nlog('info', 'Iniciando validaciÃ³n de SCHEDULE');\nlet totalShifts = 0, validShifts = 0, errors = [];\n\nfor (const [sede, days] of Object.entries(SCHEDULE.sedes)) {\n  for (const [dow, conf] of Object.entries(days)) {\n    if (Array.isArray(conf)) {\n      for (const shift of conf) { totalShifts++; validateShift(shift, sede, dow) ? validShifts++ : errors.push({ sede, dow, shift }); }\n    } else if (conf && typeof conf === 'object') {\n      for (const [weekType, arr] of Object.entries(conf)) {\n        if (!Array.isArray(arr)) { errors.push({ sede, dow, weekType, error:'Week type value must be array' }); continue; }\n        for (const shift of arr) { totalShifts++; validateShift(shift, sede, dow) ? validShifts++ : errors.push({ sede, dow, weekType, shift }); }\n      }\n    } else {\n      errors.push({ sede, dow, error:'Invalid configuration format' });\n    }\n  }\n}\n\nif (errors.length > 0) {\n  log('error','Errores de validaciÃ³n encontrados',{ errors, totalErrors: errors.length });\n  throw new Error(`SCHEDULE invÃ¡lido: ${errors.length} errores encontrados. Ver logs.`);\n}\n\nlog('info','ValidaciÃ³n OK',{ totalShifts, validShifts, sedesCount: Object.keys(SCHEDULE.sedes).length });\n\n// ==================== HELPERS ====================\nfunction getDayOfWeekInTZ(dateISO, tz) {\n  const dayName = new Intl.DateTimeFormat('en-US', { timeZone: tz, weekday: 'short' }).format(new Date(dateISO));\n  return ({ Sun:0, Mon:1, Tue:2, Wed:3, Thu:4, Fri:5, Sat:6 })[dayName];\n}\nfunction sedeHasScheduleOnDay(sede, dow) {\n  const sedeSchedule = SCHEDULE.sedes[sede]; if (!sedeSchedule) return false; return dow in sedeSchedule;\n}\nfunction classifyTimeRange(hhmm) { return (+hhmm.split(':')[0] < 14) ? 'morning' : 'afternoon'; }\nfunction getShiftsForSedeAndDay(sede, dow, weekType=null) {\n  const sedeSchedule = SCHEDULE.sedes[sede]; if (!sedeSchedule || !(dow in sedeSchedule)) return [];\n  const conf = sedeSchedule[dow];\n  if (Array.isArray(conf)) return conf;\n  if (conf && typeof conf === 'object' && weekType) return conf[weekType] || [];\n  return [];\n}\n\nconst HELPERS = {\n  getDayOfWeekInTZ,\n  sedeHasScheduleOnDay,\n  classifyTimeRange,\n  getShiftsForSedeAndDay,\n  getAllSedes: () => Object.keys(SCHEDULE.sedes),\n  sedeExists: (sede) => sede in SCHEDULE.sedes,\n  normalizeSede: (input) => {\n    if (!input) return null;\n    const lower = input.toLowerCase().trim();\n    for (const [sede, meta] of Object.entries(SCHEDULE.meta)) {\n      if (meta.aliases.some(a => a.toLowerCase() === lower)) return sede;\n    }\n    return null;\n  },\n  getWorkingDays: (sede) => SCHEDULE.meta[sede]?.workingDays || [],\n  isWorkingDay: (sede, dow) => HELPERS.getWorkingDays(sede).includes(dow),\n};\n\n// ==================== PERSISTENCIA EN STATIC DATA ====================\nlog('info','Guardando en Workflow Static Data');\nconst store = (typeof $getWorkflowStaticData === 'function') ? $getWorkflowStaticData('global') : this.getWorkflowStaticData('global');\nstore.SCHEDULE = SCHEDULE;\nstore.SCHEDULE_HELPERS = HELPERS;\nstore.SCHEDULE_VERSION = VERSION;\nstore.SCHEDULE_UPDATED_AT = new Date().toISOString();\nlog('info','SCHEDULE guardado',{ version: VERSION });\n\n// ==================== RESUMEN PARA HUMANO ====================\nconst resume = {};\nfor (const [sede, days] of Object.entries(SCHEDULE.sedes)) {\n  resume[sede] = {};\n  for (const [dow, conf] of Object.entries(days)) {\n    if (Array.isArray(conf)) {\n      resume[sede][dow] = conf.map(s => `${s[0]}-${s[1]} (${s[2]})`);\n    } else if (conf && typeof conf === 'object') {\n      resume[sede][dow] = {};\n      for (const [wt, arr] of Object.entries(conf)) {\n        resume[sede][dow][wt] = arr.map(s => `${s[0]}-${s[1]} (${s[2]})`);\n      }\n    }\n  }\n}\n\n// ==================== ESTADÃSTICAS ====================\nconst stats = {\n  totalSedes: Object.keys(SCHEDULE.sedes).length,\n  totalShifts,\n  validShifts,\n  sedesWithWeekends: Object.values(SCHEDULE.meta).filter(m => m.hasWeekends).length,\n};\n\n// ==================== OUTPUT ====================\nreturn [{\n  json: {\n    kind: 'config',\n    component: 'CARGAR_HORARIOS',\n    version: VERSION,\n    updatedAt: store.SCHEDULE_UPDATED_AT,\n    tz: TZ,\n\n    // Fuente de verdad exportada para SET_DEFAULTS:\n    anchor: SCHEDULE.anchor,\n    config: SCHEDULE.config,\n    meta: SCHEDULE.meta,\n    sedesMap: SCHEDULE.sedes, // ğŸ‘ˆ mapa real (NO strings), Ãºsalo en SET_DEFAULTS\n\n    // Solo para lectura humana / debugging:\n    stats,\n    resume,                   // ğŸ‘ˆ strings legibles; NO consumir como sedes\n    sedeKeys: Object.keys(SCHEDULE.sedes),\n\n    logs: LOGS,\n    message: `âœ… SCHEDULE v${VERSION} cargado en Workflow Static Data (global)`,\n    success: true,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1392,
        2000
      ],
      "id": "b17d4111-f8b5-4882-88db-1151c9d627af",
      "name": "CARGAR_HORARIOS"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * NORMALIZE_BUSY v6.1 â€” Mejoras de IntegraciÃ³n\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * Cambios clave vs v6.0:\n * 1) âœ… Cargar mapping de calendarId â‡¢ sede desde SCHEDULE (Static Data) con fallback\n * 2) âœ… Usar mapping dinÃ¡mico en MAIN (sin hardcoded)\n * 3) âœ… Acceso mejorado al context de SET_DEFAULTS (windowStart/End, tz, requestId)\n * 4) âœ… requestId y metadata de mapping en el output\n * 5) ğŸŸ¡ CFG dinÃ¡mico desde SCHEDULE.config (slotAnchors)\n */\n\nconst BUILD_VERSION = '6.1.0';\nconst DEFAULT_TZ = 'America/Mexico_City';\nconst DEBUG = true;\n\n// ==================== LOGGING ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = { timestamp: new Date().toISOString(), level: level.toUpperCase(), component: 'NORMALIZE_BUSY', version: BUILD_VERSION, message, ...data };\n  LOGS.push(entry);\n  if (DEBUG) {\n    const emoji = { INFO: 'â„¹ï¸', WARN: 'âš ï¸', ERROR: 'âŒ', DEBUG: 'ğŸ”', SUCCESS: 'âœ…' }[level.toUpperCase()] || 'ğŸ“';\n    console.log(`${emoji} [${level.toUpperCase()}] ${message}`, data);\n  }\n}\n\n// ==================== CONFIGURACIÃ“N DINÃMICA ====================\nfunction loadConfig() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function') ? $getWorkflowStaticData('global') : this.getWorkflowStaticData('global');\n    const SCHEDULE = store.SCHEDULE;\n    if (SCHEDULE?.config) {\n      return Object.freeze({\n        MAX_BUSY_INTERVALS: 1000,\n        MIN_INTERVAL_MS: 60_000,\n        MAX_INTERVAL_DAYS: 7,\n        ANCHORS: SCHEDULE.config.slotAnchors || [0, 30],\n        SEDE_PRIORITY: Object.keys(SCHEDULE.sedes || {}) || ['POLANCO', 'SATELITE'],\n      });\n    }\n  } catch (e) {\n    log('WARN', 'No se pudo cargar CFG desde SCHEDULE, usando defaults', { error: e.message });\n  }\n  return Object.freeze({\n    MAX_BUSY_INTERVALS: 1000,\n    MIN_INTERVAL_MS: 60_000,\n    MAX_INTERVAL_DAYS: 7,\n    ANCHORS: [0, 30],\n    SEDE_PRIORITY: ['POLANCO', 'SATELITE'],\n  });\n}\n\n// ==================== CARGAR MAPPING DE CALENDARIOS ====================\nfunction loadCalendarMapping() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function') ? $getWorkflowStaticData('global') : this.getWorkflowStaticData('global');\n    const SCHEDULE = store.SCHEDULE;\n\n    // Intento principal: SCHEDULE.meta\n    if (SCHEDULE?.meta) {\n      const mapping = {};\n      for (const [sede, metadata] of Object.entries(SCHEDULE.meta)) {\n        if (metadata && metadata.calendarId) mapping[metadata.calendarId] = sede;\n      }\n      if (Object.keys(mapping).length > 0) {\n        console.log('âœ… Calendar mapping cargado desde SCHEDULE.meta', { sedes: Object.keys(SCHEDULE.meta), calendars: Object.keys(mapping).length, version: store.SCHEDULE_VERSION });\n        return { CALENDAR_ID_TO_SEDE: mapping, source: 'schedule', version: store.SCHEDULE_VERSION };\n      }\n      console.warn('âš ï¸ No se encontraron calendarIds en SCHEDULE.meta');\n    }\n\n    // Compatibilidad: SCHEDULE.metadata\n    if (SCHEDULE?.metadata) {\n      const mappingMeta = {};\n      for (const [sede, metadata] of Object.entries(SCHEDULE.metadata)) {\n        if (metadata && metadata.calendarId) mappingMeta[metadata.calendarId] = sede;\n      }\n      if (Object.keys(mappingMeta).length > 0) {\n        console.log('âœ… Calendar mapping cargado desde SCHEDULE.metadata (compat)', { sedes: Object.keys(SCHEDULE.metadata), calendars: Object.keys(mappingMeta).length, version: store.SCHEDULE_VERSION });\n        return { CALENDAR_ID_TO_SEDE: mappingMeta, source: 'schedule_metadata', version: store.SCHEDULE_VERSION };\n      }\n    }\n\n    console.warn('âš ï¸ SCHEDULE.meta no disponible o vacÃ­o, usando fallback');\n    return {\n      CALENDAR_ID_TO_SEDE: {\n        '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com': 'POLANCO',\n        'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com': 'SATELITE',\n      },\n      source: 'fallback',\n    };\n  } catch (error) {\n    console.error('âŒ Error cargando calendar mapping:', error.message);\n    return {\n      CALENDAR_ID_TO_SEDE: {\n        '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com': 'POLANCO',\n        'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com': 'SATELITE',\n      },\n      source: 'fallback_error',\n      error: error.message,\n    };\n  }\n}\n\n// ==================== TIMEZONE HELPERS (CACHED) ====================\nlet _fmtCache = {};\nfunction getFormatters(tz) {\n  if (!_fmtCache[tz]) {\n    _fmtCache[tz] = {\n      tz,\n      DTF_FULL: new Intl.DateTimeFormat('en-CA', {\n        timeZone: tz, year: 'numeric', month: '2-digit', day: '2-digit',\n        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false,\n      }),\n    };\n  }\n  return _fmtCache[tz];\n}\nfunction dtPartsInTZ(date, DTF_FULL) {\n  const parts = DTF_FULL.formatToParts(date);\n  const obj = {}; for (const p of parts) obj[p.type] = p.value;\n  return { y: +obj.year, m: +obj.month, d: +obj.day, hh: +obj.hour, mm: +obj.minute, ss: +obj.second };\n}\nfunction zonedEpochMs(y, m, d, hh, mm, ss, DTF_FULL) {\n  const naive = Date.UTC(y, m - 1, d, hh || 0, mm || 0, ss || 0);\n  const seen = dtPartsInTZ(new Date(naive), DTF_FULL);\n  const seenMs = Date.UTC(seen.y, seen.m - 1, seen.d, seen.hh, seen.mm, seen.ss);\n  return naive - (seenMs - naive);\n}\nconst toISO = (ms) => new Date(ms).toISOString();\nfunction toMs(v) {\n  if (v == null) return NaN;\n  if (typeof v === 'number') return v;\n  if (v instanceof Date) return v.getTime();\n  const s = String(v).trim();\n  if (s.endsWith('Z') || /[+-]\\d{2}:\\d{2}$/.test(s)) return Date.parse(s);\n  if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(s)) return Date.parse(s + 'Z');\n  return Date.parse(s);\n}\n\n// ==================== VALIDACIÃ“N DE RESPUESTA ====================\nfunction validateGoogleCalendarResponse(json) {\n  if (json?.error || json?.__ERROR) return { valid: false, error: 'GCAL_API_ERROR', message: json.error?.message || json.__ERROR?.message || 'Error de Google Calendar API' };\n  if (json == null) return { valid: false, error: 'NULL_RESPONSE', message: 'Google Calendar retornÃ³ null' };\n  if (typeof json !== 'object') return { valid: false, error: 'INVALID_TYPE', message: `Esperaba objeto, recibiÃ³ ${typeof json}` };\n  return { valid: true };\n}\n\n// ==================== INTERVAL HELPERS ====================\nfunction clampMs(sMs, eMs, wsMs, weMs, MIN_INTERVAL_MS) {\n  if (!Number.isFinite(sMs) || !Number.isFinite(eMs) || sMs >= eMs) return null;\n  const S = wsMs != null ? Math.max(sMs, wsMs) : sMs;\n  const E = weMs != null ? Math.min(eMs, weMs) : eMs;\n  if (S >= E) return null;\n  if ((E - S) < MIN_INTERVAL_MS) return null;\n  return [S, E];\n}\nfunction validateInterval(interval, source = 'unknown') {\n  if (!interval || typeof interval !== 'object') return { valid: false, error: `Invalid interval object from ${source}` };\n  if (!interval.start || !interval.end) return { valid: false, error: `Missing start/end in interval from ${source}` };\n  const sMs = toMs(interval.start), eMs = toMs(interval.end);\n  if (!Number.isFinite(sMs)) return { valid: false, error: `Invalid start time \"${interval.start}\" from ${source}` };\n  if (!Number.isFinite(eMs)) return { valid: false, error: `Invalid end time \"${interval.end}\" from ${source}` };\n  if (sMs >= eMs) return { valid: false, error: `Start >= end in interval from ${source}: ${interval.start} >= ${interval.end}` };\n  return { valid: true, sMs, eMs };\n}\nfunction splitMultidayInterval(sMs, eMs, DTF_FULL, MAX_INTERVAL_DAYS) {\n  const startP = dtPartsInTZ(new Date(sMs), DTF_FULL);\n  const endP = dtPartsInTZ(new Date(eMs), DTF_FULL);\n  if (startP.y === endP.y && startP.m === endP.m && startP.d === endP.d) return [[sMs, eMs]];\n  const startDayMs = zonedEpochMs(startP.y, startP.m, startP.d, 0, 0, 0, DTF_FULL);\n  const endDayMs = zonedEpochMs(endP.y, endP.m, endP.d, 0, 0, 0, DTF_FULL);\n  const daysDiff = Math.round((endDayMs - startDayMs) / 86_400_000);\n  const out = [];\n  if (daysDiff > MAX_INTERVAL_DAYS) {\n    const endFirst = zonedEpochMs(startP.y, startP.m, startP.d, 23, 59, 59, DTF_FULL);\n    out.push([sMs, endFirst]);\n    const startLast = zonedEpochMs(endP.y, endP.m, endP.d, 0, 0, 0, DTF_FULL);\n    out.push([startLast, eMs]);\n    return out;\n  }\n  let current = startDayMs;\n  for (let i = 0; i <= daysDiff; i++) {\n    const p = dtPartsInTZ(new Date(current), DTF_FULL);\n    const dayStart = zonedEpochMs(p.y, p.m, p.d, 0, 0, 0, DTF_FULL);\n    const dayEnd = zonedEpochMs(p.y, p.m, p.d, 23, 59, 59, DTF_FULL);\n    const S = Math.max(sMs, dayStart), E = Math.min(eMs, dayEnd);\n    if (S < E) out.push([S, E]);\n    current += 86_400_000;\n  }\n  return out;\n}\nfunction mergeExclusiveMs(pairs) {\n  if (!pairs || !pairs.length) return [];\n  pairs.sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]));\n  const out = []; let [s0, e0] = pairs[0];\n  for (let i = 1; i < pairs.length; i++) { const [s, e] = pairs[i]; if (s < e0) { if (e > e0) e0 = e; } else { out.push([s0, e0]); s0 = s; e0 = e; } }\n  out.push([s0, e0]); return out;\n}\nfunction minuteFromMs(ms) { return Math.floor((ms / 60000) % 60); }\nfunction checkOffGrid(mergedPairs, anchors) {\n  const off = [];\n  for (const [S, E] of mergedPairs) {\n    const sOn = anchors.includes(minuteFromMs(S));\n    const eOn = anchors.includes(minuteFromMs(E));\n    if (!sOn || !eOn) off.push({ interval: { start: toISO(S), end: toISO(E) }, startOnGrid: sOn, endOnGrid: eOn });\n  }\n  return off;\n}\n\n// ==================== DETECCIÃ“N DE SEDE ====================\nfunction detectSede(calendarIds, explicitSede, CALENDAR_ID_TO_SEDE, SEDE_PRIORITY) {\n  if (explicitSede) {\n    const expected = Object.entries(CALENDAR_ID_TO_SEDE).filter(([, sede]) => sede === explicitSede).map(([cid]) => cid);\n    const allMatch = calendarIds.every(cid => expected.includes(cid));\n    return allMatch ? { sede: explicitSede, source: 'explicit_validated', calendarIds } : { sede: null, source: 'explicit_mismatch', error: `Sede \"${explicitSede}\" no coincide con calendarios: ${calendarIds.join(', ')}`, calendarIds };\n  }\n  if (calendarIds.length === 1) {\n    const sede = CALENDAR_ID_TO_SEDE[calendarIds[0]];\n    return sede ? { sede, source: 'single_calendar', calendarIds } : { sede: null, source: 'unknown_calendar', error: `Calendar ID desconocido: ${calendarIds[0]}`, calendarIds };\n  }\n  const sedesDetected = new Set();\n  for (const cid of calendarIds) { const sede = CALENDAR_ID_TO_SEDE[cid]; if (sede) sedesDetected.add(sede); }\n  if (sedesDetected.size === 1) return { sede: Array.from(sedesDetected)[0], source: 'multiple_calendars_same_sede', calendarIds };\n  if (sedesDetected.size > 1) {\n    const prioritized = (SEDE_PRIORITY || []).find(s => sedesDetected.has(s));\n    if (prioritized) return { sede: prioritized, source: 'multiple_sedes_prioritized', warning: `MÃºltiples sedes detectadas: ${Array.from(sedesDetected).join(', ')}, usando ${prioritized}`, calendarIds };\n  }\n  return { sede: null, source: 'unable_to_detect', error: 'No se pudo determinar sede', calendarIds };\n}\n\n// ==================== EXTRACCIÃ“N DE BUSY ====================\nfunction extractBusyPairs(json, opts) {\n  const { maxIntervals, DTF_FULL, MIN_INTERVAL_MS, MAX_INTERVAL_DAYS, wsMs, weMs } = opts;\n  const pairs = []; const calendarIds = []; const errors = [];\n\n  if (json && json.calendars && typeof json.calendars === 'object') {\n    for (const calId of Object.keys(json.calendars)) {\n      calendarIds.push(calId);\n      const arr = json.calendars[calId]?.busy || [];\n      if (arr.length > maxIntervals) errors.push(`Calendar ${calId} tiene ${arr.length} intervalos, tomando primeros ${maxIntervals}`);\n      const toProcess = arr.slice(0, maxIntervals);\n      for (const it of toProcess) {\n        const v = validateInterval(it, `calendar:${calId}`);\n        if (!v.valid) { errors.push(v.error); continue; }\n        const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n        for (const [s, e] of splits) { const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS); if (cl) pairs.push(cl); }\n      }\n    }\n    return { pairs, calendarIds, errors };\n  }\n\n  if (Array.isArray(json?.busy)) {\n    const arr = json.busy.slice(0, maxIntervals);\n    for (const it of arr) {\n      const v = validateInterval(it, 'direct_busy');\n      if (!v.valid) { errors.push(v.error); continue; }\n      const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n      for (const [s, e] of splits) { const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS); if (cl) pairs.push(cl); }\n    }\n    return { pairs, calendarIds, errors };\n  }\n\n  if (Array.isArray(json)) {\n    const arr = json.slice(0, maxIntervals);\n    for (const it of arr) {\n      const v = validateInterval(it, 'array');\n      if (!v.valid) { errors.push(v.error); continue; }\n      const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n      for (const [s, e] of splits) { const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS); if (cl) pairs.push(cl); }\n    }\n    return { pairs, calendarIds, errors };\n  }\n\n  return { pairs, calendarIds, errors };\n}\n\n// ==================== MAIN ====================\ntry {\n  const startTime = DEBUG ? Date.now() : 0;\n  const items = $input.all();\n\n  // âœ… NUEVO: Cargar mapping de calendarios desde SCHEDULE\n  const calendarMappingData = loadCalendarMapping();\n  const CALENDAR_ID_TO_SEDE = calendarMappingData.CALENDAR_ID_TO_SEDE || {};\n  const SEDE_TO_CALENDAR_IDS = Object.entries(CALENDAR_ID_TO_SEDE).reduce((acc, [calId, sede]) => { (acc[sede] ||= []).push(calId); return acc; }, {});\n  if (DEBUG) {\n    console.log('ğŸ“‹ Calendar mapping:', { source: calendarMappingData.source, sedes: Object.keys(SEDE_TO_CALENDAR_IDS), totalCalendars: Object.keys(CALENDAR_ID_TO_SEDE).length });\n  }\n\n  // 1) Obtener ventana y parÃ¡metros desde SET_DEFAULTS\n  let wsMs = null, weMs = null, slotDefaultMin = 30;\n  let requestId = `normalize-${Date.now()}`;\n  let effectiveTZ = DEFAULT_TZ;\n  let explicitSede = null;\n\n  try {\n    const setDefaultsItems = $('SET_DEFAULTS').all();\n    if (setDefaultsItems && setDefaultsItems.length > 0) {\n      const ctx = setDefaultsItems[0].json;\n      if (ctx?.kind === 'context') {\n        if (ctx.windowStart) wsMs = toMs(ctx.windowStart);\n        if (ctx.windowEnd) weMs = toMs(ctx.windowEnd);\n        if (Number.isFinite(ctx.constraints?.slotMinutes)) {\n          slotDefaultMin = Math.max(10, Math.min(120, ctx.constraints.slotMinutes));\n        }\n        if (ctx.requestId) requestId = ctx.requestId;\n        if (ctx.tz) effectiveTZ = ctx.tz;\n        if (ctx.sedePreferida) explicitSede = String(ctx.sedePreferida).toUpperCase();\n        if (DEBUG) console.log('âœ… Context cargado desde SET_DEFAULTS', { windowStart: ctx.windowStart, windowEnd: ctx.windowEnd, tz: effectiveTZ, requestId, explicitSede });\n      } else {\n        console.warn('âš ï¸ SET_DEFAULTS no retornÃ³ context vÃ¡lido, kind:', ctx?.kind);\n      }\n    } else {\n      console.warn('âš ï¸ No se encontrÃ³ SET_DEFAULTS en items');\n    }\n  } catch (err) {\n    console.warn('âš ï¸ Error obteniendo context de SET_DEFAULTS:', err.message);\n  }\n\n  // 2) TZ/CFG\n  const { DTF_FULL } = getFormatters(effectiveTZ);\n  const CFG = loadConfig();\n\n  // 3) Procesar entradas\n  const rawPairs = []; const allCalendarIds = new Set(); const errors = [];\n  for (let i = 0; i < items.length; i++) {\n    const json = items[i]?.json || {};\n    const vr = validateGoogleCalendarResponse(json);\n    if (!vr.valid) { errors.push(vr.message); continue; }\n    const ext = extractBusyPairs(json, { maxIntervals: CFG.MAX_BUSY_INTERVALS, DTF_FULL, MIN_INTERVAL_MS: CFG.MIN_INTERVAL_MS, MAX_INTERVAL_DAYS: CFG.MAX_INTERVAL_DAYS, wsMs, weMs });\n    ext.calendarIds.forEach(cid => allCalendarIds.add(cid));\n    rawPairs.push(...ext.pairs);\n    if (ext.errors.length) errors.push(...ext.errors);\n  }\n\n  // 4) Detectar sede automÃ¡ticamente o validar explÃ­cita\n  const calendarIdsArray = Array.from(allCalendarIds);\n  const sedeDetection = detectSede(calendarIdsArray, explicitSede, CALENDAR_ID_TO_SEDE, CFG.SEDE_PRIORITY);\n  if (!sedeDetection.sede) {\n    return [{\n      json: {\n        kind: 'busy', sede: null, busy: [], busyBySede: {},\n        sourceStatus: {\n          ok: false,\n          sede: null,\n          tz: effectiveTZ,\n          requestId,\n          errors: [sedeDetection.error || 'No se pudo determinar SEDE'],\n          sedeDetection,\n          build: { version: BUILD_VERSION, generatedAt: new Date().toISOString(), scheduleVersion: calendarMappingData.version },\n          calendarMappingSource: calendarMappingData.source,\n        }\n      }\n    }];\n  }\n\n  const SEDE = sedeDetection.sede;\n  if (sedeDetection.warning) errors.push(sedeDetection.warning);\n\n  // 5) Merge + off-grid\n  const mergedPairs = mergeExclusiveMs(rawPairs);\n  const offGridDetails = checkOffGrid(mergedPairs, CFG.ANCHORS);\n\n  // 6) Salida normalizada\n  const busy = mergedPairs.map(([sMs, eMs]) => ({ sede: SEDE, start: toISO(sMs), end: toISO(eMs) }));\n\n  // 7) MÃ©tricas\n  const metrics = {\n    totalItems: items.length,\n    totalRaw: rawPairs.length,\n    merged: mergedPairs.length,\n    offGridCount: offGridDetails.length,\n    calendarIds: calendarIdsArray,\n    executionTimeMs: DEBUG ? (Date.now() - startTime) : undefined,\n  };\n\n  const status = {\n    ok: errors.length === 0,\n    sede: SEDE,\n    sedeDetection,\n    tz: effectiveTZ,\n    requestId,\n    calendarMappingSource: calendarMappingData.source,\n    window: { start: wsMs != null ? toISO(wsMs) : null, end: weMs != null ? toISO(weMs) : null },\n    policy: { source: 'freebusy', slotDefaultMin, maxIntervals: CFG.MAX_BUSY_INTERVALS, maxIntervalDays: CFG.MAX_INTERVAL_DAYS },\n    metrics,\n    offGridDetails: offGridDetails.length ? offGridDetails : undefined,\n    errors,\n    build: { version: BUILD_VERSION, generatedAt: new Date().toISOString(), scheduleVersion: calendarMappingData.version },\n    _logs: DEBUG ? LOGS : undefined,\n  };\n\n  log('SUCCESS', 'âœ… NORMALIZE_BUSY completado', { sede: SEDE, totalBusy: busy.length, offGrid: offGridDetails.length });\n\n  return [{\n    json: { kind: 'busy', sede: SEDE, busy, busyBySede: { [SEDE]: busy }, sourceStatus: status },\n    pairedItem: items.map((_, i) => ({ item: i })),\n  }];\n\n} catch (err) {\n  log('ERROR', 'Error fatal', { error: err?.message, stack: err?.stack });\n  return [{ json: { kind: 'busy', sede: null, busy: [], busyBySede: {}, sourceStatus: { ok: false, errors: [String(err?.message || err)], stack: DEBUG ? err?.stack : undefined, build: { version: BUILD_VERSION, generatedAt: new Date().toISOString() } } } }];\n}\n"
      },
      "id": "25088a1b-7921-4806-b2d8-5faab71399dc",
      "name": "Normalize Busy POLANCO",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -496,
        1904
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * NORMALIZE_BUSY v6.2 â€” SATÃ‰LITE (estricto)\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * Cambios clave:\n * 1) âœ… Cargar mapping de calendarId â‡¢ sede desde SCHEDULE (Static Data) con fallback\n * 2) âœ… CFG dinÃ¡mico desde SCHEDULE.config (slotAnchors)\n * 3) âœ… Acceso mejorado al context de SET_DEFAULTS (windowStart/End, tz, requestId)\n * 4) âœ… requestId, scheduleVersion y mappingSource en el output\n * 5) âœ… Modo ESTRICTO por sede: solo procesa calendarios de SATÃ‰LITE\n */\n\nconst BUILD_VERSION = '6.2.0';\nconst DEFAULT_TZ = 'America/Mexico_City';\nconst DEBUG = true;\nconst EXPECTED_SEDE = 'SATELITE';\n\n// ==================== LOGGING ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = { timestamp: new Date().toISOString(), level: level.toUpperCase(), component: 'NORMALIZE_BUSY_SATELITE', version: BUILD_VERSION, message, ...data };\n  LOGS.push(entry);\n  if (DEBUG) {\n    const emoji = { INFO: 'â„¹ï¸', WARN: 'âš ï¸', ERROR: 'âŒ', DEBUG: 'ğŸ”', SUCCESS: 'âœ…' }[level.toUpperCase()] || 'ğŸ“';\n    console.log(`${emoji} [${level.toUpperCase()}] ${message}`, data);\n  }\n}\n\n// ==================== CONFIGURACIÃ“N DINÃMICA ====================\nfunction loadConfig() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function')\n      ? $getWorkflowStaticData('global')\n      : this.getWorkflowStaticData('global');\n    const SCHEDULE = store.SCHEDULE;\n    if (SCHEDULE?.config) {\n      return Object.freeze({\n        MAX_BUSY_INTERVALS: 1000,\n        MIN_INTERVAL_MS: 60_000,\n        MAX_INTERVAL_DAYS: 7,\n        ANCHORS: SCHEDULE.config.slotAnchors || [0, 30],\n        SEDE_PRIORITY: Object.keys(SCHEDULE.sedes || {}) || ['POLANCO', 'SATELITE'],\n      });\n    }\n  } catch (e) {\n    log('WARN', 'No se pudo cargar CFG desde SCHEDULE, usando defaults', { error: e.message });\n  }\n  return Object.freeze({\n    MAX_BUSY_INTERVALS: 1000,\n    MIN_INTERVAL_MS: 60_000,\n    MAX_INTERVAL_DAYS: 7,\n    ANCHORS: [0, 30],\n    SEDE_PRIORITY: ['POLANCO', 'SATELITE'],\n  });\n}\n\n// ==================== CARGAR MAPPING DE CALENDARIOS ====================\nfunction loadCalendarMapping() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function')\n      ? $getWorkflowStaticData('global')\n      : this.getWorkflowStaticData('global');\n    const SCHEDULE = store.SCHEDULE;\n\n    // Preferido: SCHEDULE.meta\n    if (SCHEDULE?.meta) {\n      const mapping = {};\n      for (const [sede, meta] of Object.entries(SCHEDULE.meta)) {\n        if (meta?.calendarId) mapping[meta.calendarId] = sede;\n      }\n      if (Object.keys(mapping).length > 0) {\n        console.log('âœ… Calendar mapping cargado desde SCHEDULE.meta', {\n          sedes: Object.keys(SCHEDULE.meta),\n          calendars: Object.keys(mapping).length,\n          version: store.SCHEDULE_VERSION,\n        });\n        return { CALENDAR_ID_TO_SEDE: mapping, source: 'schedule', version: store.SCHEDULE_VERSION };\n      }\n      console.warn('âš ï¸ SCHEDULE.meta sin calendarIds; intentando metadata (compat)');\n    }\n\n    // Compatibilidad: SCHEDULE.metadata\n    if (SCHEDULE?.metadata) {\n      const mappingMeta = {};\n      for (const [sede, meta] of Object.entries(SCHEDULE.metadata)) {\n        if (meta?.calendarId) mappingMeta[meta.calendarId] = sede;\n      }\n      if (Object.keys(mappingMeta).length > 0) {\n        console.log('âœ… Calendar mapping cargado desde SCHEDULE.metadata (compat)', {\n          sedes: Object.keys(SCHEDULE.metadata),\n          calendars: Object.keys(mappingMeta).length,\n          version: store.SCHEDULE_VERSION,\n        });\n        return { CALENDAR_ID_TO_SEDE: mappingMeta, source: 'schedule_metadata', version: store.SCHEDULE_VERSION };\n      }\n    }\n\n    // Fallback a hardcoded (incluye SATÃ‰LITE)\n    console.warn('âš ï¸ SCHEDULE no provee mapping, usando fallback hardcoded');\n    return {\n      CALENDAR_ID_TO_SEDE: {\n        // Polanco:\n        '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com': 'POLANCO',\n        // SatÃ©lite:\n        'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com': 'SATELITE',\n      },\n      source: 'fallback',\n      version: 'fallback',\n    };\n  } catch (error) {\n    console.error('âŒ Error cargando calendar mapping:', error.message);\n    return {\n      CALENDAR_ID_TO_SEDE: {\n        '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com': 'POLANCO',\n        'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com': 'SATELITE',\n      },\n      source: 'fallback_error',\n      version: 'fallback_error',\n      error: error.message,\n    };\n  }\n}\n\n// ==================== TIMEZONE HELPERS (CACHED) ====================\nlet _fmtCache = {};\nfunction getFormatters(tz) {\n  if (!_fmtCache[tz]) {\n    _fmtCache[tz] = {\n      tz,\n      DTF_FULL: new Intl.DateTimeFormat('en-CA', {\n        timeZone: tz,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false,\n      }),\n    };\n  }\n  return _fmtCache[tz];\n}\nfunction dtPartsInTZ(date, DTF_FULL) {\n  const parts = DTF_FULL.formatToParts(date);\n  const obj = {};\n  for (const p of parts) obj[p.type] = p.value;\n  return { y: +obj.year, m: +obj.month, d: +obj.day, hh: +obj.hour, mm: +obj.minute, ss: +obj.second };\n}\nfunction zonedEpochMs(y, m, d, hh, mm, ss, DTF_FULL) {\n  const naive = Date.UTC(y, m - 1, d, hh || 0, mm || 0, ss || 0);\n  const seen = dtPartsInTZ(new Date(naive), DTF_FULL);\n  const seenMs = Date.UTC(seen.y, seen.m - 1, seen.d, seen.hh, seen.mm, seen.ss);\n  return naive - (seenMs - naive);\n}\nconst toISO = (ms) => new Date(ms).toISOString();\nfunction toMs(v) {\n  if (v == null) return NaN;\n  if (typeof v === 'number') return v;\n  if (v instanceof Date) return v.getTime();\n  const s = String(v).trim();\n  if (s.endsWith('Z') || /[+-]\\d{2}:\\d{2}$/.test(s)) return Date.parse(s);\n  if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(s)) return Date.parse(s + 'Z');\n  return Date.parse(s);\n}\n\n// ==================== VALIDACIÃ“N DE RESPUESTA ====================\nfunction validateGoogleCalendarResponse(json) {\n  if (json?.error || json?.__ERROR) return { valid: false, error: 'GCAL_API_ERROR', message: json.error?.message || json.__ERROR?.message || 'Error de Google Calendar API' };\n  if (json == null) return { valid: false, error: 'NULL_RESPONSE', message: 'Google Calendar retornÃ³ null' };\n  if (typeof json !== 'object') return { valid: false, error: 'INVALID_TYPE', message: `Esperaba objeto, recibiÃ³ ${typeof json}` };\n  return { valid: true };\n}\n\n// ==================== INTERVAL HELPERS ====================\nfunction clampMs(sMs, eMs, wsMs, weMs, MIN_INTERVAL_MS) {\n  if (!Number.isFinite(sMs) || !Number.isFinite(eMs) || sMs >= eMs) return null;\n  const S = wsMs != null ? Math.max(sMs, wsMs) : sMs;\n  const E = weMs != null ? Math.min(eMs, weMs) : eMs;\n  if (S >= E) return null;\n  if ((E - S) < MIN_INTERVAL_MS) return null;\n  return [S, E];\n}\nfunction validateInterval(interval, source = 'unknown') {\n  if (!interval || typeof interval !== 'object') return { valid: false, error: `Invalid interval object from ${source}` };\n  if (!interval.start || !interval.end) return { valid: false, error: `Missing start/end in interval from ${source}` };\n  const sMs = toMs(interval.start), eMs = toMs(interval.end);\n  if (!Number.isFinite(sMs)) return { valid: false, error: `Invalid start time \"${interval.start}\" from ${source}` };\n  if (!Number.isFinite(eMs)) return { valid: false, error: `Invalid end time \"${interval.end}\" from ${source}` };\n  if (sMs >= eMs) return { valid: false, error: `Start >= end in interval from ${source}: ${interval.start} >= ${interval.end}` };\n  return { valid: true, sMs, eMs };\n}\nfunction splitMultidayInterval(sMs, eMs, DTF_FULL, MAX_INTERVAL_DAYS) {\n  const startP = dtPartsInTZ(new Date(sMs), DTF_FULL);\n  const endP = dtPartsInTZ(new Date(eMs), DTF_FULL);\n  if (startP.y === endP.y && startP.m === endP.m && startP.d === endP.d) return [[sMs, eMs]];\n  const startDayMs = zonedEpochMs(startP.y, startP.m, startP.d, 0, 0, 0, DTF_FULL);\n  const endDayMs = zonedEpochMs(endP.y, endP.m, endP.d, 0, 0, 0, DTF_FULL);\n  const daysDiff = Math.round((endDayMs - startDayMs) / 86_400_000);\n  const out = [];\n  if (daysDiff > MAX_INTERVAL_DAYS) {\n    const endFirst = zonedEpochMs(startP.y, startP.m, startP.d, 23, 59, 59, DTF_FULL);\n    out.push([sMs, endFirst]);\n    const startLast = zonedEpochMs(endP.y, endP.m, endP.d, 0, 0, 0, DTF_FULL);\n    out.push([startLast, eMs]);\n    return out;\n  }\n  let current = startDayMs;\n  for (let i = 0; i <= daysDiff; i++) {\n    const p = dtPartsInTZ(new Date(current), DTF_FULL);\n    const dayStart = zonedEpochMs(p.y, p.m, p.d, 0, 0, 0, DTF_FULL);\n    const dayEnd = zonedEpochMs(p.y, p.m, p.d, 23, 59, 59, DTF_FULL);\n    const S = Math.max(sMs, dayStart), E = Math.min(eMs, dayEnd);\n    if (S < E) out.push([S, E]);\n    current += 86_400_000;\n  }\n  return out;\n}\nfunction mergeExclusiveMs(pairs) {\n  if (!pairs || !pairs.length) return [];\n  pairs.sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]));\n  const out = []; let [s0, e0] = pairs[0];\n  for (let i = 1; i < pairs.length; i++) {\n    const [s, e] = pairs[i];\n    if (s < e0) { if (e > e0) e0 = e; }\n    else { out.push([s0, e0]); s0 = s; e0 = e; }\n  }\n  out.push([s0, e0]);\n  return out;\n}\nconst minuteFromMs = (ms) => Math.floor((ms / 60000) % 60);\nfunction checkOffGrid(mergedPairs, anchors) {\n  const off = [];\n  for (const [S, E] of mergedPairs) {\n    const sOn = anchors.includes(minuteFromMs(S));\n    const eOn = anchors.includes(minuteFromMs(E));\n    if (!sOn || !eOn) off.push({ interval: { start: toISO(S), end: toISO(E) }, startOnGrid: sOn, endOnGrid: eOn });\n  }\n  return off;\n}\n\n// ==================== DETECCIÃ“N DE SEDE ====================\nfunction detectSede(calendarIds, explicitSede, CALENDAR_ID_TO_SEDE, SEDE_PRIORITY) {\n  if (explicitSede) {\n    const expected = Object.entries(CALENDAR_ID_TO_SEDE)\n      .filter(([, sede]) => sede === explicitSede)\n      .map(([cid]) => cid);\n    const allMatch = calendarIds.every(cid => expected.includes(cid));\n    return allMatch\n      ? { sede: explicitSede, source: 'explicit_validated', calendarIds }\n      : { sede: null, source: 'explicit_mismatch', error: `Sede \"${explicitSede}\" no coincide con calendarios: ${calendarIds.join(', ')}`, calendarIds };\n  }\n  if (calendarIds.length === 1) {\n    const sede = CALENDAR_ID_TO_SEDE[calendarIds[0]];\n    return sede\n      ? { sede, source: 'single_calendar', calendarIds }\n      : { sede: null, source: 'unknown_calendar', error: `Calendar ID desconocido: ${calendarIds[0]}`, calendarIds };\n  }\n  const sedesDetected = new Set();\n  for (const cid of calendarIds) { const sede = CALENDAR_ID_TO_SEDE[cid]; if (sede) sedesDetected.add(sede); }\n  if (sedesDetected.size === 1) return { sede: Array.from(sedesDetected)[0], source: 'multiple_calendars_same_sede', calendarIds };\n  if (sedesDetected.size > 1) {\n    const prioritized = (SEDE_PRIORITY || []).find(s => sedesDetected.has(s));\n    if (prioritized) return { sede: prioritized, source: 'multiple_sedes_prioritized', warning: `MÃºltiples sedes detectadas: ${Array.from(sedesDetected).join(', ')}, usando ${prioritized}`, calendarIds };\n  }\n  return { sede: null, source: 'unable_to_detect', error: 'No se pudo determinar sede', calendarIds };\n}\n\n// ==================== EXTRACCIÃ“N DE BUSY (con filtro por sede) ====================\nfunction extractBusyPairs(json, opts) {\n  const { maxIntervals, DTF_FULL, MIN_INTERVAL_MS, MAX_INTERVAL_DAYS, wsMs, weMs, allowedCalIds } = opts;\n  const pairs = []; const calendarIds = []; const errors = [];\n  const skippedCalendars = [];\n\n  // Formato 1: { calendars: { calId: { busy: [...] } } }\n  if (json && json.calendars && typeof json.calendars === 'object') {\n    for (const calId of Object.keys(json.calendars)) {\n      if (Array.isArray(allowedCalIds) && allowedCalIds.length && !allowedCalIds.includes(calId)) {\n        skippedCalendars.push(calId);\n        continue; // estricto: solo calendarios de SATÃ‰LITE\n      }\n      calendarIds.push(calId);\n      const arr = json.calendars[calId]?.busy || [];\n      if (arr.length > maxIntervals) errors.push(`Calendar ${calId} tiene ${arr.length} intervalos, tomando primeros ${maxIntervals}`);\n      const toProcess = arr.slice(0, maxIntervals);\n      for (const it of toProcess) {\n        const v = validateInterval(it, `calendar:${calId}`);\n        if (!v.valid) { errors.push(v.error); continue; }\n        const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n        for (const [s, e] of splits) {\n          const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS);\n          if (cl) pairs.push(cl);\n        }\n      }\n    }\n    return { pairs, calendarIds, errors, skippedCalendars };\n  }\n\n  // Formato 2: { busy: [...] }\n  if (Array.isArray(json?.busy)) {\n    const arr = json.busy.slice(0, maxIntervals);\n    for (const it of arr) {\n      const v = validateInterval(it, 'direct_busy');\n      if (!v.valid) { errors.push(v.error); continue; }\n      const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n      for (const [s, e] of splits) {\n        const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS);\n        if (cl) pairs.push(cl);\n      }\n    }\n    return { pairs, calendarIds, errors, skippedCalendars };\n  }\n\n  // Formato 3: array directo\n  if (Array.isArray(json)) {\n    const arr = json.slice(0, maxIntervals);\n    for (const it of arr) {\n      const v = validateInterval(it, 'array');\n      if (!v.valid) { errors.push(v.error); continue; }\n      const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n      for (const [s, e] of splits) {\n        const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS);\n        if (cl) pairs.push(cl);\n      }\n    }\n    return { pairs, calendarIds, errors, skippedCalendars };\n  }\n\n  return { pairs, calendarIds, errors, skippedCalendars };\n}\n\n// ==================== MAIN ====================\ntry {\n  const startTime = DEBUG ? Date.now() : 0;\n  const items = $input.all();\n\n  // 0) Mapping de calendarios\n  const calendarMappingData = loadCalendarMapping();\n  const CALENDAR_ID_TO_SEDE = calendarMappingData.CALENDAR_ID_TO_SEDE || {};\n  const SEDE_TO_CALENDAR_IDS = Object.entries(CALENDAR_ID_TO_SEDE)\n    .reduce((acc, [calId, sede]) => { (acc[sede] ||= []).push(calId); return acc; }, {});\n  const allowedCalIds = SEDE_TO_CALENDAR_IDS[EXPECTED_SEDE] || [];\n  if (DEBUG) {\n    console.log('ğŸ“‹ Calendar mapping (SATÃ‰LITE):', {\n      source: calendarMappingData.source,\n      version: calendarMappingData.version,\n      expectedSede: EXPECTED_SEDE,\n      allowedCalIds,\n      totalCalendars: Object.keys(CALENDAR_ID_TO_SEDE).length,\n    });\n  }\n\n  // 1) Context desde SET_DEFAULTS\n  let wsMs = null, weMs = null, slotDefaultMin = 30;\n  let requestId = `normalize-${Date.now()}`;\n  let effectiveTZ = DEFAULT_TZ;\n  let explicitSede = EXPECTED_SEDE; // modo estricto\n\n  try {\n    const setDefaultsItems = $('SET_DEFAULTS').all();\n    if (setDefaultsItems && setDefaultsItems.length > 0) {\n      const ctx = setDefaultsItems[0].json;\n      if (ctx?.kind === 'context') {\n        if (ctx.windowStart) wsMs = toMs(ctx.windowStart);\n        if (ctx.windowEnd) weMs = toMs(ctx.windowEnd);\n        if (Number.isFinite(ctx.constraints?.slotMinutes)) {\n          slotDefaultMin = Math.max(10, Math.min(120, ctx.constraints.slotMinutes));\n        }\n        if (ctx.requestId) requestId = ctx.requestId;\n        if (ctx.tz) effectiveTZ = ctx.tz;\n        // Si vino sedePreferida distinta a SATÃ‰LITE, lo avisamos pero mantenemos estricto a SATÃ‰LITE\n        if (ctx.sedePreferida && String(ctx.sedePreferida).toUpperCase() !== EXPECTED_SEDE) {\n          log('WARN', 'sedePreferida distinta al nodo SATÃ‰LITE; se ignorarÃ¡ y se usarÃ¡ SATÃ‰LITE', {\n            sedePreferida: ctx.sedePreferida, expected: EXPECTED_SEDE,\n          });\n        }\n        if (DEBUG) console.log('âœ… Context cargado desde SET_DEFAULTS', {\n          windowStart: ctx.windowStart, windowEnd: ctx.windowEnd, tz: effectiveTZ, requestId,\n        });\n      } else {\n        console.warn('âš ï¸ SET_DEFAULTS no retornÃ³ context vÃ¡lido, kind:', ctx?.kind);\n      }\n    } else {\n      console.warn('âš ï¸ No se encontrÃ³ SET_DEFAULTS en items');\n    }\n  } catch (err) {\n    console.warn('âš ï¸ Error obteniendo context de SET_DEFAULTS:', err.message);\n  }\n\n  // 2) TZ/CFG\n  const { DTF_FULL } = getFormatters(effectiveTZ);\n  const CFG = loadConfig();\n\n  // 3) Procesar entradas con filtro de calendarios de SATÃ‰LITE\n  const rawPairs = []; const allCalendarIds = new Set(); const errors = []; const skippedCalGlobal = new Set();\n  for (let i = 0; i < items.length; i++) {\n    const json = items[i]?.json || {};\n    const vr = validateGoogleCalendarResponse(json);\n    if (!vr.valid) { errors.push(vr.message); continue; }\n\n    const ext = extractBusyPairs(json, {\n      maxIntervals: CFG.MAX_BUSY_INTERVALS,\n      DTF_FULL,\n      MIN_INTERVAL_MS: CFG.MIN_INTERVAL_MS,\n      MAX_INTERVAL_DAYS: CFG.MAX_INTERVAL_DAYS,\n      wsMs, weMs,\n      allowedCalIds, // ğŸ”’ estricto SATÃ‰LITE\n    });\n\n    ext.calendarIds.forEach(cid => allCalendarIds.add(cid));\n    if (Array.isArray(ext.skippedCalendars) && ext.skippedCalendars.length) {\n      ext.skippedCalendars.forEach(cid => skippedCalGlobal.add(cid));\n    }\n    rawPairs.push(...ext.pairs);\n    if (ext.errors.length) errors.push(...ext.errors);\n  }\n\n  // 4) DetecciÃ³n/validaciÃ³n de sede (estricto SATÃ‰LITE)\n  const calendarIdsArray = Array.from(allCalendarIds);\n  const sedeDetection = detectSede(calendarIdsArray, explicitSede, CALENDAR_ID_TO_SEDE, CFG.SEDE_PRIORITY);\n  if (!sedeDetection.sede) {\n    return [{\n      json: {\n        kind: 'busy',\n        sede: null,\n        busy: [],\n        busyBySede: {},\n        sourceStatus: {\n          ok: false,\n          sede: null,\n          tz: effectiveTZ,\n          requestId,\n          errors: [sedeDetection.error || 'No se pudo determinar SEDE'],\n          skippedCalendars: Array.from(skippedCalGlobal),\n          sedeDetection,\n          build: { version: BUILD_VERSION, generatedAt: new Date().toISOString(), scheduleVersion: calendarMappingData.version },\n          calendarMappingSource: calendarMappingData.source,\n        }\n      }\n    }];\n  }\n\n  const SEDE = sedeDetection.sede; // deberÃ­a ser SATÃ‰LITE\n  if (SEDE !== EXPECTED_SEDE) {\n    errors.push(`DetecciÃ³n de sede inesperada: ${SEDE} (se esperaba ${EXPECTED_SEDE})`);\n  }\n  if (sedeDetection.warning) errors.push(sedeDetection.warning);\n\n  // 5) Merge + off-grid\n  const mergedPairs = mergeExclusiveMs(rawPairs);\n  const offGridDetails = checkOffGrid(mergedPairs, CFG.ANCHORS);\n\n  // 6) Salida normalizada\n  const busy = mergedPairs.map(([sMs, eMs]) => ({ sede: SEDE, start: toISO(sMs), end: toISO(eMs) }));\n\n  // 7) MÃ©tricas\n  const metrics = {\n    totalItems: items.length,\n    totalRaw: rawPairs.length,\n    merged: mergedPairs.length,\n    offGridCount: offGridDetails.length,\n    calendarIds: calendarIdsArray,\n    skippedCalendars: Array.from(skippedCalGlobal),\n    executionTimeMs: DEBUG ? (Date.now() - startTime) : undefined,\n  };\n\n  const status = {\n    ok: errors.length === 0,\n    sede: SEDE,\n    sedeDetection,\n    tz: effectiveTZ,\n    requestId,\n    calendarMappingSource: calendarMappingData.source,\n    window: {\n      start: wsMs != null ? toISO(wsMs) : null,\n      end:  weMs != null ? toISO(weMs) : null,\n    },\n    policy: {\n      source: 'freebusy',\n      slotDefaultMin: slotDefaultMin,\n      maxIntervals: CFG.MAX_BUSY_INTERVALS,\n      maxIntervalDays: CFG.MAX_INTERVAL_DAYS,\n      anchors: CFG.ANCHORS,\n    },\n    metrics,\n    offGridDetails: offGridDetails.length ? offGridDetails : undefined,\n    errors,\n    build: {\n      version: BUILD_VERSION,\n      generatedAt: new Date().toISOString(),\n      scheduleVersion: calendarMappingData.version,\n    },\n    _logs: DEBUG ? LOGS : undefined,\n  };\n\n  log('SUCCESS', 'âœ… NORMALIZE_BUSY (SATÃ‰LITE) completado', { totalBusy: busy.length, offGrid: offGridDetails.length });\n\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE,\n      busy,\n      busyBySede: { [SEDE]: busy },\n      sourceStatus: status,\n    },\n    pairedItem: items.map((_, i) => ({ item: i })),\n  }];\n\n} catch (err) {\n  log('ERROR', 'Error fatal', { error: err?.message, stack: err?.stack });\n  return [{\n    json: {\n      kind: 'busy',\n      sede: EXPECTED_SEDE,\n      busy: [],\n      busyBySede: {},\n      sourceStatus: {\n        ok: false,\n        sede: EXPECTED_SEDE,\n        errors: [String(err?.message || err)],\n        stack: DEBUG ? err?.stack : undefined,\n        build: { version: BUILD_VERSION, generatedAt: new Date().toISOString() },\n      }\n    }\n  }];\n}\n"
      },
      "id": "3b08b976-ec56-4e87-b31c-e6d23e26e06b",
      "name": "Normalize Busy SATELITE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -496,
        2096
      ]
    }
  ],
  "pinData": {
    "When Executed by Another Workflow": [
      {
        "json": {
          "desiredStart": "2025-10-25T00:00:00Z",
          "userText": "PrÃ³ximo viernes en Polancor",
          "sedePreferida": "",
          "timezone": "America/Mexico_City",
          "windowDays": 14,
          "maxResults": 50,
          "includeWeekends": null,
          "onlyMorning": null,
          "onlyAfternoon": null,
          "requestId": "1761363269893-6bpk86rak",
          "source": "urobot_whatsapp"
        }
      }
    ]
  },
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "CARGAR_HORARIOS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - POLANCO": {
      "main": [
        [
          {
            "node": "Normalize Busy POLANCO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - SATELITE": {
      "main": [
        [
          {
            "node": "Normalize Busy SATELITE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Busy (append)1": {
      "main": [
        [
          {
            "node": "Combine Busy",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Busy": {
      "main": [
        [
          {
            "node": "Calc Availability",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calc Availability": {
      "main": [
        [
          {
            "node": "Build Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SET_DEFAULTS": {
      "main": [
        [
          {
            "node": "SCHEDULE_GATE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SCHEDULE_GATE": {
      "main": [
        [
          {
            "node": "Availability - POLANCO",
            "type": "main",
            "index": 0
          },
          {
            "node": "Availability - SATELITE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CARGAR_HORARIOS": {
      "main": [
        [
          {
            "node": "SET_DEFAULTS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy POLANCO": {
      "main": [
        [
          {
            "node": "Merge Busy (append)1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy SATELITE": {
      "main": [
        [
          {
            "node": "Merge Busy (append)1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/Mexico_City",
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "EV0uQg6ljO1CwH6A"
  },
  "versionId": "fed1a196-cd42-4ea7-ad77-4f89851bfce8",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "ab2739af75c0bf0ee034fd37e78576df139d0a4fcd48adc710d9ceec11fc12c5"
  },
  "id": "HtbhK8aN1uBbKCLU",
  "tags": []
}