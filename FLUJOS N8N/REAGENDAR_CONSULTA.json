{
  "name": "REAGENDAR_CONSULTA",
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"telefono\": \"6673184624\",\n  \"consultaId\": \"\",\n  \"newDate\": \"2025-10-25\",\n  \"newTime\": \"14:00\",\n  \"newSede\": \"POLANCO\",\n  \"reason\": \"Conflicto de horario\"\n}"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -752,
        -160
      ],
      "id": "697b6587-7ee8-490a-80b8-d308b0c6fa1e",
      "name": "When executed by another workflow"
    },
    {
      "parameters": {
        "jsCode": "/**\n * ========================================================================\n * Validate Input v6.2 - REAGENDAR_CONSULTA (FIX: lee SCHEDULE m√∫ltiple)\n * ========================================================================\n * Cambios v6.2:\n * ‚úÖ Lee SCHEDULE desde m√∫ltiples fuentes (output, static data)\n * ‚úÖ Prioriza output de CARGAR_HORARIOS sobre static data\n * ‚úÖ Logging mejorado de fuente de SCHEDULE\n */\n\n'use strict';\n\n// ========================================================================\n// CONFIG\n// ========================================================================\nconst CONFIG = {\n  TIMEZONE: 'America/Mexico_City',\n  FIXED_TZ_OFFSET: '-06:00',\n  MIN_HOURS_ADVANCE: 2,\n  WARNING_HOURS_ADVANCE: 4,\n  MAX_DAYS_AHEAD: 90,\n  VALID_SEDES: ['POLANCO', 'SATELITE'],\n  PHONE_LENGTH: 10,\n  VERSION: '6.2',\n};\n\n// ========================================================================\n// HELPERS\n// ========================================================================\nfunction normalizePhone(raw) {\n  if (!raw) return '';\n  const digits = String(raw).replace(/\\D/g, '');\n  if (digits.length === 10) return digits;\n  if (digits.length === 12 && digits.startsWith('52')) return digits.slice(2);\n  if (digits.length === 13 && digits.startsWith('521')) return digits.slice(3);\n  if (digits.length >= 10) return digits.slice(-10);\n  return '';\n}\n\nfunction getMexicoDateTime(dateStr, timeStr) {\n  if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(dateStr) || !/^\\d{2}:\\d{2}$/.test(timeStr)) return null;\n  const iso = `${dateStr}T${timeStr}:00${CONFIG.FIXED_TZ_OFFSET}`;\n  const d = new Date(iso);\n  return isNaN(d.getTime()) ? null : d;\n}\n\nfunction formatDate(date) {\n  try {\n    return date.toLocaleString('es-MX', {\n      timeZone: CONFIG.TIMEZONE,\n      weekday: 'long', year: 'numeric', month: 'long',\n      day: 'numeric', hour: '2-digit', minute: '2-digit', hour12: false,\n    });\n  } catch { return date.toISOString(); }\n}\n\nfunction getDayOfWeekMX(dateStr) {\n  const d = new Date(`${dateStr}T12:00:00${CONFIG.FIXED_TZ_OFFSET}`);\n  return d.getUTCDay();\n}\n\n// ========================================================================\n// VALIDACI√ìN DE HORARIOS DEL DOCTOR\n// ========================================================================\n\nfunction timeToMinutes(timeStr) {\n  const [h, m] = timeStr.split(':').map(Number);\n  return h * 60 + m;\n}\n\nfunction minutesToTime(mins) {\n  const h = Math.floor(mins / 60);\n  const m = mins % 60;\n  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;\n}\n\nfunction getWeekType(dateStr, anchor) {\n  if (!anchor || !anchor.date) return null;\n  \n  const targetDate = new Date(`${dateStr}T00:00:00-06:00`);\n  const anchorDate = new Date(`${anchor.date}T00:00:00-06:00`);\n  \n  const diffTime = targetDate - anchorDate;\n  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n  const diffWeeks = Math.floor(diffDays / 7);\n  \n  return (diffWeeks % 2 === 0) ? anchor.type : (anchor.type === 'A' ? 'B' : 'A');\n}\n\nfunction validateDoctorSchedule(dateStr, timeStr, sede, SCHEDULE) {\n  if (!SCHEDULE || !SCHEDULE.sedes) {\n    return {\n      valid: false,\n      error: 'SCHEDULE_NOT_LOADED',\n      message: 'Configuraci√≥n de horarios no cargada',\n    };\n  }\n\n  const dow = getDayOfWeekMX(dateStr);\n  const dayNames = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];\n  \n  if (!SCHEDULE.sedes[sede]) {\n    return {\n      valid: false,\n      error: 'SEDE_NOT_IN_SCHEDULE',\n      message: `Sede ${sede} no encontrada en configuraci√≥n`,\n    };\n  }\n\n  const sedeSchedule = SCHEDULE.sedes[sede];\n  let shifts = sedeSchedule[dow] || [];\n\n  // Manejo de s√°bados con formato de objeto {A: [...], B: [...]}\n  if (dow === 6 && shifts && typeof shifts === 'object' && !Array.isArray(shifts)) {\n    const weekType = getWeekType(dateStr, SCHEDULE.anchor);\n    shifts = shifts[weekType] || [];\n  }\n\n  // Manejo de shifts con semana tipo en posici√≥n [3]\n  if (dow === 6 && Array.isArray(shifts) && shifts.length > 0) {\n    const weekType = getWeekType(dateStr, SCHEDULE.anchor);\n    shifts = shifts.filter(shift => {\n      if (shift.length >= 4 && shift[3]) {\n        return shift[3] === weekType;\n      }\n      return true;\n    });\n  }\n\n  // Si no hay horarios para este d√≠a\n  if (!shifts || shifts.length === 0) {\n    const availableDays = [];\n    for (let d = 1; d <= 6; d++) {\n      if (d === 0) continue;\n      const dayShifts = sedeSchedule[d];\n      if (dayShifts && (Array.isArray(dayShifts) ? dayShifts.length > 0 : Object.keys(dayShifts).length > 0)) {\n        availableDays.push(dayNames[d]);\n      }\n    }\n\n    return {\n      valid: false,\n      error: 'NO_CONSULTATION_DAY',\n      message: `No hay consultas los ${dayNames[dow]} en ${sede}`,\n      availableDays: availableDays.join(', '),\n      requestedDay: dayNames[dow],\n      requestedDate: dateStr,\n    };\n  }\n\n  // Validar que la hora est√© dentro de alg√∫n turno\n  const requestedMins = timeToMinutes(timeStr);\n  let validShift = null;\n\n  for (const shift of shifts) {\n    const [startTime, endTime] = shift;\n    const startMins = timeToMinutes(startTime);\n    const endMins = timeToMinutes(endTime);\n\n    if (requestedMins >= startMins && requestedMins < endMins) {\n      validShift = shift;\n      break;\n    }\n  }\n\n  if (!validShift) {\n    const availableRanges = shifts.map(shift => {\n      const label = shift[2] ? ` (${shift[2]})` : '';\n      return `${shift[0]}-${shift[1]}${label}`;\n    }).join(', ');\n\n    return {\n      valid: false,\n      error: 'TIME_OUT_OF_SCHEDULE',\n      message: `La hora ${timeStr} est√° fuera del horario de consulta`,\n      requestedTime: timeStr,\n      availableRanges,\n      day: dayNames[dow],\n      sede,\n    };\n  }\n\n  return {\n    valid: true,\n    shift: validShift,\n    shiftLabel: validShift[2] || `${validShift[0]}-${validShift[1]}`,\n  };\n}\n\n// ========================================================================\n// OBTENER INPUT CORRECTO DEL TRIGGER\n// ========================================================================\n\nlet input = {};\nlet inputSource = 'unknown';\n\ntry {\n  const triggerNode = $('When executed by another workflow');\n  if (triggerNode && triggerNode.item && triggerNode.item.json) {\n    input = triggerNode.item.json;\n    inputSource = 'trigger-node';\n  } else {\n    input = $input.first()?.json || {};\n    inputSource = 'fallback-input';\n  }\n} catch (e) {\n  console.warn('‚ö†Ô∏è Error accessing trigger node:', e.message);\n  input = $input.first()?.json || {};\n  inputSource = 'fallback-error';\n}\n\n// Si el input parece ser configuraci√≥n de CARGAR_HORARIOS\nif (input.kind === 'config' || input.component === 'CARGAR_HORARIOS') {\n  console.warn('‚ö†Ô∏è Input detectado como config, buscando datos de reagendamiento...');\n  \n  try {\n    const triggerNode = $('When executed by another workflow');\n    if (triggerNode && triggerNode.item && triggerNode.item.json) {\n      input = triggerNode.item.json;\n      inputSource = 'trigger-node-corrected';\n    }\n  } catch (e) {\n    console.error('‚ùå No se pudo acceder al nodo trigger');\n  }\n}\n\n// Soporte para datos anidados en 'query'\nif (input && typeof input.query === 'object') {\n  input = input.query;\n  inputSource += '-query-unwrapped';\n}\n\n// ========================================================================\n// CARGAR SCHEDULE DESDE M√öLTIPLES FUENTES\n// ========================================================================\n\nlet SCHEDULE = null;\nlet HELPERS = null;\nlet scheduleSource = 'none';\n\n// 1. Intentar leer desde el output de CARGAR_HORARIOS (m√°s reciente)\ntry {\n  const cargarNode = $('CARGAR_HORARIOS');\n  if (cargarNode && cargarNode.item && cargarNode.item.json) {\n    const cargarOutput = cargarNode.item.json;\n    \n    // Reconstruir SCHEDULE desde el output\n    if (cargarOutput.kind === 'config' && cargarOutput.component === 'CARGAR_HORARIOS') {\n      // El output tiene metadata pero no la estructura completa\n      // Intentar desde static data primero\n      const store = $getWorkflowStaticData('global');\n      if (store.SCHEDULE) {\n        SCHEDULE = store.SCHEDULE;\n        HELPERS = store.SCHEDULE_HELPERS;\n        scheduleSource = 'static-data-via-output';\n      }\n    }\n  }\n} catch (e) {\n  console.warn('‚ö†Ô∏è No se pudo leer CARGAR_HORARIOS output:', e.message);\n}\n\n// 2. Si no se encontr√≥, intentar desde Workflow Static Data\nif (!SCHEDULE) {\n  try {\n    const store = $getWorkflowStaticData('global');\n    if (store.SCHEDULE) {\n      SCHEDULE = store.SCHEDULE;\n      HELPERS = store.SCHEDULE_HELPERS;\n      scheduleSource = 'static-data-direct';\n    }\n  } catch (e) {\n    console.warn('‚ö†Ô∏è No se pudo leer static data:', e.message);\n  }\n}\n\n// 3. Fallback: Reconstruir SCHEDULE inline (√∫ltima opci√≥n)\nif (!SCHEDULE) {\n  console.warn('‚ö†Ô∏è SCHEDULE no disponible, usando configuraci√≥n inline');\n  \n  SCHEDULE = {\n    version: '2.0.0-inline',\n    tz: 'America/Mexico_City',\n    anchor: { date: '2025-01-06', type: 'A' },\n    sedes: {\n      POLANCO: {\n        1: [['09:00', '13:00', 'Lunes Matutino']],\n        2: [['16:00', '20:00', 'Martes Vespertino']],\n        5: [['15:00', '19:00', 'Viernes Vespertino']],\n      },\n      SATELITE: {\n        3: [['09:00', '13:00', 'Mi√©rcoles Matutino']],\n        4: [\n          ['09:00', '13:00', 'Jueves Matutino'],\n          ['15:00', '20:00', 'Jueves Vespertino'],\n        ],\n        6: {\n          B: [['09:00', '13:00', 'S√°bado Matutino (alterno)']]\n        },\n      },\n    },\n  };\n  scheduleSource = 'inline-fallback';\n}\n\nconsole.log('üì• Validate Input v6.2:', JSON.stringify({\n  inputSource,\n  inputKeys: Object.keys(input || {}),\n  scheduleSource,\n  scheduleLoaded: !!SCHEDULE,\n  scheduleVersion: SCHEDULE?.version || 'N/A',\n  hasReagendarData: !!(input.telefono || input.newDate || input.newTime || input.newSede),\n}, null, 2));\n\n// ========================================================================\n// VALIDACIONES B√ÅSICAS\n// ========================================================================\nconst errors = [];\nconst warnings = [];\nconst metadata = {\n  version: CONFIG.VERSION,\n  timezone: CONFIG.TIMEZONE,\n  fixedOffset: CONFIG.FIXED_TZ_OFFSET,\n  validationStarted: new Date().toISOString(),\n  inputSource,\n  scheduleSource,\n  inputReceivedKeys: Object.keys(input || {}),\n  scheduleAvailable: !!SCHEDULE,\n  scheduleVersion: SCHEDULE?.version || null,\n};\n\n// 1) Tel√©fono\nconst telefono = normalizePhone(input.telefono);\nif (!telefono) {\n  errors.push({ field: 'telefono', code: 'PHONE_REQUIRED', message: 'El tel√©fono es obligatorio' });\n} else if (telefono.length !== CONFIG.PHONE_LENGTH) {\n  errors.push({\n    field: 'telefono', code: 'PHONE_INVALID_LENGTH',\n    message: `Debe tener ${CONFIG.PHONE_LENGTH} d√≠gitos (ej. 6673184624)`,\n    received: telefono, receivedLength: telefono.length,\n  });\n}\n\n// 2) Identificador de b√∫squeda\nif (!input.consultaId && !telefono) {\n  errors.push({\n    field: 'consultaId|telefono',\n    code: 'SEARCH_PARAMS_REQUIRED',\n    message: 'Se requiere consultaId o tel√©fono v√°lido para buscar la consulta',\n  });\n}\n\n// 3) Fecha\nif (!input.newDate) {\n  errors.push({ field: 'newDate', code: 'DATE_REQUIRED', message: 'La nueva fecha es obligatoria' });\n} else if (!/^\\d{4}-\\d{2}-\\d{2}$/.test(input.newDate)) {\n  errors.push({\n    field: 'newDate', code: 'DATE_INVALID_FORMAT',\n    message: 'Use YYYY-MM-DD (ej. 2025-10-25)', received: input.newDate,\n  });\n}\n\n// 4) Hora\nif (!input.newTime) {\n  errors.push({ field: 'newTime', code: 'TIME_REQUIRED', message: 'La nueva hora es obligatoria' });\n} else if (!/^\\d{2}:\\d{2}$/.test(input.newTime)) {\n  errors.push({\n    field: 'newTime', code: 'TIME_INVALID_FORMAT',\n    message: 'Use HH:MM 24h (ej. 14:00)', received: input.newTime,\n  });\n} else {\n  const [hh, mm] = input.newTime.split(':').map(Number);\n  if (hh < 0 || hh > 23) errors.push({ field: 'newTime', code: 'TIME_INVALID_HOURS', message: 'Hora inv√°lida (00‚Äì23)', received: hh });\n  if (mm < 0 || mm > 59) errors.push({ field: 'newTime', code: 'TIME_INVALID_MINUTES', message: 'Minutos inv√°lidos (00‚Äì59)', received: mm });\n}\n\n// 5) Sede\nconst newSede = input.newSede ? String(input.newSede).toUpperCase().trim() : null;\nif (!newSede) {\n  errors.push({ field: 'newSede', code: 'SEDE_REQUIRED', message: 'La sede es obligatoria' });\n} else if (!CONFIG.VALID_SEDES.includes(newSede)) {\n  errors.push({\n    field: 'newSede', code: 'SEDE_INVALID',\n    message: `Sede inv√°lida. Opciones: ${CONFIG.VALID_SEDES.join(', ')}`,\n    received: newSede, validOptions: CONFIG.VALID_SEDES,\n  });\n}\n\n// ========================================================================\n// VALIDACIONES COMBINADAS (fecha+hora+horarios del doctor)\n// ========================================================================\nif (errors.length === 0 && input.newDate && input.newTime) {\n  const newDT = getMexicoDateTime(input.newDate, input.newTime);\n  const nowUTC = new Date();\n  \n  if (!newDT) {\n    errors.push({\n      field: 'newDate|newTime', code: 'DATETIME_INVALID',\n      message: 'Fecha/hora inv√°lidas para la zona de CDMX',\n      received: { date: input.newDate, time: input.newTime },\n    });\n  } else {\n    if (newDT <= nowUTC) {\n      errors.push({\n        field: 'newDate|newTime', code: 'DATETIME_PAST',\n        message: 'La nueva cita debe ser en el futuro',\n        requested: formatDate(newDT), current: formatDate(nowUTC),\n      });\n    } else {\n      const hoursAhead = (newDT - nowUTC) / 3.6e6;\n      const daysAhead = Math.floor(hoursAhead / 24);\n\n      if (hoursAhead < CONFIG.MIN_HOURS_ADVANCE) {\n        errors.push({\n          field: 'newDate|newTime', code: 'DATETIME_TOO_SOON',\n          message: `M√≠nimo ${CONFIG.MIN_HOURS_ADVANCE} horas de anticipaci√≥n`,\n          hoursAhead: Number(hoursAhead.toFixed(2)),\n        });\n      } else if (hoursAhead < CONFIG.WARNING_HOURS_ADVANCE) {\n        warnings.push({\n          field: 'newDate|newTime', code: 'DATETIME_SHORT_NOTICE',\n          message: `Poca anticipaci√≥n (~${hoursAhead.toFixed(1)}h). Recomendado ‚â• ${CONFIG.WARNING_HOURS_ADVANCE}h`,\n          hoursAhead: Number(hoursAhead.toFixed(2)),\n        });\n      }\n\n      if (daysAhead > CONFIG.MAX_DAYS_AHEAD) {\n        errors.push({\n          field: 'newDate', code: 'DATE_TOO_FAR',\n          message: `No m√°s de ${CONFIG.MAX_DAYS_AHEAD} d√≠as a futuro`,\n          daysAhead, maxAllowed: CONFIG.MAX_DAYS_AHEAD,\n        });\n      }\n\n      const dow = getDayOfWeekMX(input.newDate);\n      if (dow === 0) {\n        errors.push({\n          field: 'newDate', code: 'DATE_SUNDAY',\n          message: 'No se agendan citas los domingos',\n          date: input.newDate, dayName: 'Domingo',\n        });\n      }\n    }\n\n    // VALIDACI√ìN DE HORARIOS DEL DOCTOR\n    if (SCHEDULE && newSede) {\n      const scheduleValidation = validateDoctorSchedule(\n        input.newDate,\n        input.newTime,\n        newSede,\n        SCHEDULE\n      );\n\n      if (!scheduleValidation.valid) {\n        errors.push({\n          field: 'newDate|newTime|newSede',\n          code: scheduleValidation.error,\n          message: scheduleValidation.message,\n          ...scheduleValidation,\n        });\n      } else {\n        metadata.validatedShift = scheduleValidation.shiftLabel;\n        metadata.shiftDetails = scheduleValidation.shift;\n      }\n    } else if (!SCHEDULE) {\n      warnings.push({\n        field: 'system',\n        code: 'SCHEDULE_NOT_AVAILABLE',\n        message: 'No se pudo validar horarios del doctor. Continuando sin validaci√≥n de schedule.',\n      });\n    }\n  }\n}\n\n// ========================================================================\n// OUTPUT\n// ========================================================================\nconst metadataOut = {\n  ...metadata,\n  validationCompleted: new Date().toISOString(),\n  errorsCount: errors.length,\n  warningsCount: warnings.length,\n};\n\nif (errors.length > 0) {\n  const payload = {\n    status: 'VALIDATION_ERROR',\n    success: false,\n    errors,\n    warnings,\n    metadata: metadataOut,\n    _abort: true,\n    _timestamp: new Date().toISOString(),\n  };\n  console.error('‚ùå Validation failed:', JSON.stringify(payload, null, 2));\n  return [{ json: payload }];\n}\n\nconst validated = {\n  telefono,\n  consultaId: input.consultaId || null,\n  newDate: input.newDate,\n  newTime: input.newTime,\n  newSede: newSede,\n  reason: input.reason || 'Reagendamiento solicitado por paciente',\n\n  _validated: true,\n  _warnings: warnings,\n  _metadata: metadataOut,\n  _timestamp: new Date().toISOString(),\n  _timezone: CONFIG.TIMEZONE,\n  _dayOfWeek: getDayOfWeekMX(input.newDate),\n  _inputSource: inputSource,\n};\n\nconsole.log('‚úÖ Validation success:', JSON.stringify({\n  status: 'OK',\n  inputSource,\n  scheduleSource,\n  validatedPreview: { ...validated, _metadata: '[omitted]', _warnings: warnings.length },\n}, null, 2));\n\nreturn [{ json: validated }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -304,
        -160
      ],
      "id": "3bb7534f-1f81-4194-bcfb-87dd644748e4",
      "name": "Validate Input"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._abort}}",
              "value2": true
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -80,
        -160
      ],
      "id": "87fb8a37-f737-4d19-8de3-9207d01ca65f",
      "name": "Valid?"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "status",
              "name": "status",
              "value": "={{$json.status}}",
              "type": "string"
            },
            {
              "id": "errors",
              "name": "errors",
              "value": "={{$json.errors}}",
              "type": "array"
            },
            {
              "id": "message",
              "name": "message",
              "value": "=Error de validaci√≥n: {{ $json.errors.join(', ') }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        144,
        -256
      ],
      "id": "fc5f0094-adcf-4e44-913a-5a044ec52107",
      "name": "Return Validation Error"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT * FROM buscar_consulta_para_reagendar(\n  {{ $json.telefono ? \"'\" + $json.telefono + \"'\" : 'NULL' }}::TEXT,\n  {{ $json.consultaId ? \"'\" + $json.consultaId + \"'\" : 'NULL' }}::TEXT\n);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        144,
        -64
      ],
      "id": "2e9a88b8-efb3-4c9b-be0b-353992f153bf",
      "name": "Buscar Consulta (PostgreSQL)",
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 1000,
      "credentials": {
        "postgres": {
          "id": "k3E9sYtyRqQbgtHs",
          "name": "UROBOT"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * ========================================================================\n * Process Search Result v5.0 - PRODUCTION READY\n * ========================================================================\n * MEJORAS v5.0:\n * ‚úÖ Validaci√≥n de estados de cita v√°lidos\n * ‚úÖ Manejo de calendar_event_id vac√≠o/null\n * ‚úÖ Validaci√≥n de cita no pasada\n * ‚úÖ Detecci√≥n de reagendamiento redundante\n * ‚úÖ Campos corregidos seg√∫n schema DB\n * ‚úÖ Metadata enriquecida\n * ‚úÖ Logging estructurado\n */\n\nconst validation = $items('Validate Input')[0]?.json || {};\nconst pgResult = $input.first()?.json || {};\n\n// ========================================================================\n// CONSTANTES DE CONFIGURACI√ìN\n// ========================================================================\n\nconst CONFIG = {\n  CALENDAR_IDS: {\n    POLANCO: '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com',\n    SATELITE: 'c_67f78ba9fc1f38bb02cc70bc5e00c798e9f7c67a42fba2b1c2085f2bbf55ef8f@group.calendar.google.com'\n  },\n  \n  // Estados de cita que S√ç se pueden reagendar\n  VALID_STATES_TO_RESCHEDULE: [\n    'Programada',\n    'Confirmada',\n    'Pendiente'\n  ],\n  \n  // Estados que NO se pueden reagendar\n  INVALID_STATES: [\n    'Cancelada',\n    'Completada',\n    'No Asisti√≥',\n    'En Proceso'\n  ],\n  \n  TIMEZONE: 'America/Mexico_City'\n};\n\n// ========================================================================\n// FUNCIONES AUXILIARES\n// ========================================================================\n\n/**\n * Valida si una fecha ya pas√≥\n */\nfunction isDateInPast(dateString) {\n  if (!dateString) return false;\n  \n  const appointmentDate = new Date(dateString);\n  const now = new Date();\n  \n  return appointmentDate < now;\n}\n\n/**\n * Formatea fecha para mensajes\n */\nfunction formatDateTime(isoString) {\n  if (!isoString) return 'N/A';\n  \n  const date = new Date(isoString);\n  return date.toLocaleString('es-MX', {\n    timeZone: CONFIG.TIMEZONE,\n    dateStyle: 'full',\n    timeStyle: 'short'\n  });\n}\n\n/**\n * Extrae solo la fecha (YYYY-MM-DD) de un timestamp\n */\nfunction extractDate(isoString) {\n  if (!isoString) return null;\n  return isoString.split('T')[0];\n}\n\n/**\n * Extrae solo la hora (HH:mm) de un timestamp\n */\nfunction extractTime(isoString) {\n  if (!isoString) return null;\n  \n  const date = new Date(isoString);\n  return date.toLocaleTimeString('es-MX', {\n    timeZone: CONFIG.TIMEZONE,\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false\n  });\n}\n\n// ========================================================================\n// VALIDAR RESULTADO RPC\n// ========================================================================\n\nconst metadata = {\n  processStarted: new Date().toISOString(),\n  searchParams: {\n    telefono: validation.telefono,\n    consultaId: validation.consultaId\n  },\n  version: '5.0'\n};\n\nconst rpcResult = pgResult.buscar_consulta_para_reagendar;\n\nif (!rpcResult) {\n  console.error('‚ùå No RPC result:', JSON.stringify(pgResult, null, 2));\n  \n  return [{\n    json: {\n      status: 'DATABASE_ERROR',\n      message: 'Error al buscar consulta en base de datos. No se recibi√≥ respuesta del RPC.',\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\nif (!rpcResult.success) {\n  const errorCode = rpcResult.error || 'NOT_FOUND';\n  const errorMessage = rpcResult.message || 'No se encontr√≥ la consulta para reagendar';\n  \n  console.warn('‚ö†Ô∏è Consulta no encontrada:', JSON.stringify({\n    telefono: validation.telefono,\n    consultaId: validation.consultaId,\n    error: errorCode,\n    message: errorMessage\n  }, null, 2));\n  \n  return [{\n    json: {\n      status: errorCode,\n      message: errorMessage,\n      searchParams: {\n        telefono: validation.telefono,\n        consultaId: validation.consultaId\n      },\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\nconst consulta = rpcResult.consulta;\n\nif (!consulta) {\n  console.error('‚ùå Missing consulta object:', JSON.stringify(rpcResult, null, 2));\n  \n  return [{\n    json: {\n      status: 'DATA_ERROR',\n      message: 'Datos de consulta incompletos en la respuesta de la base de datos',\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// ========================================================================\n// VALIDACIONES DE NEGOCIO\n// ========================================================================\n\n// 1. Validar sede y obtener calendar ID\nconst sedeUpper = consulta.sede ? String(consulta.sede).toUpperCase() : null;\nconst calendarId = sedeUpper ? CONFIG.CALENDAR_IDS[sedeUpper] : null;\n\nif (!calendarId) {\n  console.error('‚ùå Invalid sede:', consulta.sede);\n  \n  return [{\n    json: {\n      status: 'INVALID_SEDE',\n      message: `Sede inv√°lida en la consulta encontrada: ${consulta.sede}. Debe ser POLANCO o SATELITE`,\n      consultaData: {\n        uuid: consulta.consulta_uuid,\n        sede: consulta.sede\n      },\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// 2. Validar estado de la cita\nconst estadoCita = consulta.estado_cita || 'Desconocido';\n\nif (CONFIG.INVALID_STATES.includes(estadoCita)) {\n  console.warn('‚ö†Ô∏è Cannot reschedule - Invalid state:', estadoCita);\n  \n  return [{\n    json: {\n      status: 'INVALID_STATE',\n      message: `No se puede reagendar una cita en estado: ${estadoCita}`,\n      consultaData: {\n        uuid: consulta.consulta_uuid,\n        estado: estadoCita,\n        paciente: consulta.paciente_nombre\n      },\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\nif (!CONFIG.VALID_STATES_TO_RESCHEDULE.includes(estadoCita)) {\n  console.warn('‚ö†Ô∏è Unknown state for rescheduling:', estadoCita);\n  // No abortar, solo warning\n}\n\n// 3. Validar que la cita no haya pasado\nif (isDateInPast(consulta.fecha_hora_utc)) {\n  console.warn('‚ö†Ô∏è Cannot reschedule - Appointment in the past');\n  \n  return [{\n    json: {\n      status: 'APPOINTMENT_PAST',\n      message: `No se puede reagendar una cita que ya pas√≥ (${formatDateTime(consulta.fecha_hora_utc)})`,\n      consultaData: {\n        uuid: consulta.consulta_uuid,\n        fechaProgramada: consulta.fecha_hora_utc,\n        ahora: new Date().toISOString()\n      },\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// 4. Validar calendar_event_id (puede ser vac√≠o/null)\nconst hasCalendarEvent = !!(consulta.calendar_event_id && consulta.calendar_event_id.trim());\n\nif (!hasCalendarEvent) {\n  console.warn('‚ö†Ô∏è Warning: Consulta sin event ID en calendario:', {\n    uuid: consulta.consulta_uuid,\n    calendar_event_id: consulta.calendar_event_id\n  });\n}\n\n// 5. Detectar reagendamiento redundante (misma fecha/hora/sede)\nconst currentDate = extractDate(consulta.fecha_hora_utc);\nconst currentTime = extractTime(consulta.fecha_hora_utc);\n\nconst isRedundant = (\n  validation.newDate === currentDate &&\n  validation.newTime === currentTime &&\n  validation.newSede === sedeUpper\n);\n\nif (isRedundant) {\n  console.warn('‚ö†Ô∏è Reagendamiento redundante detectado');\n  \n  return [{\n    json: {\n      status: 'REDUNDANT_RESCHEDULE',\n      message: 'La nueva fecha, hora y sede son id√©nticas a la cita actual. No hay cambios para realizar.',\n      currentAppointment: {\n        fecha: currentDate,\n        hora: currentTime,\n        sede: sedeUpper\n      },\n      requestedAppointment: {\n        fecha: validation.newDate,\n        hora: validation.newTime,\n        sede: validation.newSede\n      },\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// ========================================================================\n// CONSTRUIR RESPUESTA\n// ========================================================================\n\nconst output = {\n  // Pasar validaci√≥n original\n  ...validation,\n  \n  // Datos de la cita encontrada\n  oldAppointment: {\n    // UUIDs (CORREGIDO: era .uuid, ahora .consulta_uuid)\n    uuid: consulta.consulta_uuid,\n    pacienteUuid: consulta.paciente_uuid,\n    \n    // IDs\n    consultaId: consulta.consulta_id_publico,\n    \n    // Calendar\n    calendarEventId: hasCalendarEvent ? consulta.calendar_event_id : null,\n    calendarLink: consulta.calendar_link || null,\n    calendarId: calendarId,\n    \n    // Sede\n    sede: sedeUpper,\n    \n    // Paciente\n    pacienteNombre: consulta.paciente_nombre || 'N/A',\n    telefono: consulta.telefono,\n    \n    // Fecha/Hora\n    fechaHoraUtc: consulta.fecha_hora_utc,\n    fecha: currentDate,\n    hora: currentTime,\n    \n    // Estado\n    estadoCita: estadoCita,\n    tipoCita: consulta.tipo_cita || 'primera_vez',\n    \n    // Flags\n    hasCalendarEvent: hasCalendarEvent\n  },\n  \n  // Metadata\n  _validated: true,\n  _consultaFound: true,\n  _hasCalendarEvent: hasCalendarEvent,\n  _willDeleteOldEvent: hasCalendarEvent,\n  _metadata: {\n    ...metadata,\n    processCompleted: new Date().toISOString(),\n    consultaValidations: {\n      sedeValid: true,\n      stateValid: CONFIG.VALID_STATES_TO_RESCHEDULE.includes(estadoCita),\n      notInPast: true,\n      notRedundant: true,\n      hasCalendarEvent: hasCalendarEvent\n    }\n  }\n};\n\n// ========================================================================\n// LOGGING\n// ========================================================================\n\nconsole.log('‚úÖ Consulta procesada exitosamente:', JSON.stringify({\n  uuid: consulta.consulta_uuid,\n  paciente: output.oldAppointment.pacienteNombre,\n  sede: sedeUpper,\n  fechaActual: formatDateTime(consulta.fecha_hora_utc),\n  estado: estadoCita,\n  hasCalendarEvent: hasCalendarEvent,\n  cambios: {\n    fecha: `${currentDate} ‚Üí ${validation.newDate}`,\n    hora: `${currentTime} ‚Üí ${validation.newTime}`,\n    sede: `${sedeUpper} ‚Üí ${validation.newSede}`\n  }\n}, null, 2));\n\nreturn [{ json: output }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        368,
        -64
      ],
      "id": "14af0423-2845-47e9-b96a-a1665096fc3c",
      "name": "Process Search Result"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._abort}}",
              "value2": true
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        592,
        -64
      ],
      "id": "ccccbfd9-b8bd-41ca-be95-b96aa1cceca9",
      "name": "Found?"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "status",
              "name": "status",
              "value": "={{$json.status}}",
              "type": "string"
            },
            {
              "id": "message",
              "name": "message",
              "value": "={{$json.message}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        816,
        -160
      ],
      "id": "b6275009-0109-4581-8d47-cc246c585dfa",
      "name": "Return Not Found"
    },
    {
      "parameters": {
        "jsCode": "/**\n * ========================================================================\n * Parse New DateTime v3.2 - FIX: Google Calendar ISO format\n * ========================================================================\n * Cambios v3.2:\n * ‚úÖ Remueve milisegundos de timestamps ISO (.000Z ‚Üí Z)\n * ‚úÖ Formato compatible con Google Calendar API\n * ‚úÖ Validaci√≥n mejorada de Calendar ID\n */\n\nconst input = $input.first()?.json || {};\n\nconsole.log('üîç ===== PARSE NEW DATETIME v3.2 - INICIO =====');\n\n// ========================================================================\n// CARGAR SCHEDULE DESDE WORKFLOW STATIC DATA\n// ========================================================================\n\nconst store = $getWorkflowStaticData('global');\nconst SCHEDULE = store.SCHEDULE;\nconst HELPERS = store.SCHEDULE_HELPERS;\n\nif (!SCHEDULE || !HELPERS) {\n  console.error('‚ùå SCHEDULE no est√° cargado en Workflow Static Data');\n  console.error('   Aseg√∫rate de que el nodo CARGAR_HORARIOS se ejecute primero');\n  \n  return [{\n    json: {\n      status: 'ERROR',\n      error: 'SCHEDULE_NOT_LOADED',\n      message: 'SCHEDULE no est√° inicializado. Ejecuta CARGAR_HORARIOS primero.',\n      _abort: true\n    }\n  }];\n}\n\nconsole.log('‚úÖ SCHEDULE cargado:', {\n  version: SCHEDULE.version,\n  sedes: Object.keys(SCHEDULE.sedes),\n  updatedAt: store.SCHEDULE_UPDATED_AT\n});\n\n// ========================================================================\n// VALIDAR DATOS NECESARIOS\n// ========================================================================\n\nif (!input.newDate || !input.newTime || !input.newSede) {\n  console.error('‚ùå Faltan datos requeridos');\n  return [{\n    json: {\n      status: 'ERROR',\n      error: 'MISSING_DATA',\n      message: 'Faltan datos de fecha, hora o sede',\n      _abort: true\n    }\n  }];\n}\n\n// ========================================================================\n// NORMALIZAR Y VALIDAR SEDE\n// ========================================================================\n\n// Normalizar nombre de sede (maneja aliases)\nconst sedeNormalized = HELPERS.normalizeSede(input.newSede) || input.newSede.toUpperCase().trim();\n\nconsole.log('üîç Sede solicitada:', input.newSede);\nconsole.log('üîç Sede normalizada:', sedeNormalized);\n\n// Verificar que la sede existe\nif (!HELPERS.sedeExists(sedeNormalized)) {\n  const availableSedes = HELPERS.getAllSedes();\n  console.error('‚ùå Sede no v√°lida:', sedeNormalized);\n  console.error('‚ùå Sedes disponibles:', availableSedes);\n  \n  return [{\n    json: {\n      status: 'ERROR',\n      error: 'INVALID_SEDE',\n      message: `Sede inv√°lida: ${sedeNormalized}`,\n      availableSedes: availableSedes,\n      requestedSede: input.newSede,\n      _abort: true\n    }\n  }];\n}\n\n// ========================================================================\n// OBTENER CALENDAR ID DESDE SCHEDULE\n// ========================================================================\n\nconst calendarId = SCHEDULE.meta[sedeNormalized]?.calendarId || SCHEDULE.metadata[sedeNormalized]?.calendarId;\n\nconsole.log('‚úÖ Calendar ID obtenido:', calendarId);\n\nif (!calendarId) {\n  console.error('‚ùå No se encontr√≥ Calendar ID en SCHEDULE para:', sedeNormalized);\n  console.error('   SCHEDULE.meta disponible:', Object.keys(SCHEDULE.meta || {}));\n  console.error('   SCHEDULE.metadata disponible:', Object.keys(SCHEDULE.metadata || {}));\n  \n  return [{\n    json: {\n      status: 'ERROR',\n      error: 'MISSING_CALENDAR_ID',\n      message: `No hay Calendar ID configurado para ${sedeNormalized}`,\n      sede: sedeNormalized,\n      _abort: true\n    }\n  }];\n}\n\n// ========================================================================\n// HELPER: Convertir a ISO sin milisegundos (Google Calendar compatible)\n// ========================================================================\n\n/**\n * Convierte Date a ISO string SIN milisegundos\n * Google Calendar rechaza formato con .000Z\n * \n * Entrada: Date object\n * Salida: \"2025-10-22T16:30:00Z\" (sin .000)\n */\nfunction toISOWithoutMilliseconds(date) {\n  if (!date || isNaN(date.getTime())) {\n    return null;\n  }\n  \n  // M√©todo 1: Remover milisegundos del string\n  return date.toISOString().replace(/\\.\\d{3}Z$/, 'Z');\n  \n  // M√©todo 2 alternativo (m√°s manual pero m√°s control):\n  // const pad = (n) => String(n).padStart(2, '0');\n  // const year = date.getUTCFullYear();\n  // const month = pad(date.getUTCMonth() + 1);\n  // const day = pad(date.getUTCDate());\n  // const hours = pad(date.getUTCHours());\n  // const minutes = pad(date.getUTCMinutes());\n  // const seconds = pad(date.getUTCSeconds());\n  // return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}Z`;\n}\n\n// ========================================================================\n// CONSTRUIR TIMESTAMPS\n// ========================================================================\n\n// Formato: 2025-10-23T09:00:00-06:00 (CST para M√©xico)\nconst localDateTimeStr = `${input.newDate}T${input.newTime}:00-06:00`;\nconsole.log('üîç Local DateTime String:', localDateTimeStr);\n\nconst startDate = new Date(localDateTimeStr);\n\nif (isNaN(startDate.getTime())) {\n  console.error('‚ùå Fecha/hora inv√°lida:', localDateTimeStr);\n  return [{\n    json: {\n      status: 'ERROR',\n      error: 'INVALID_DATETIME',\n      message: 'Fecha u hora inv√°lida',\n      received: { date: input.newDate, time: input.newTime },\n      _abort: true\n    }\n  }];\n}\n\n// ‚úÖ FIX: Usar funci√≥n sin milisegundos\nconst duracion = SCHEDULE.config.consultationDuration || 30;\nconst endDate = new Date(startDate.getTime() + (duracion * 60 * 1000));\n\nconst startISO = toISOWithoutMilliseconds(startDate);\nconst endISO = toISOWithoutMilliseconds(endDate);\n\nif (!startISO || !endISO) {\n  console.error('‚ùå Error generando timestamps ISO');\n  return [{\n    json: {\n      status: 'ERROR',\n      error: 'ISO_GENERATION_FAILED',\n      message: 'No se pudieron generar timestamps ISO v√°lidos',\n      _abort: true\n    }\n  }];\n}\n\nconsole.log('‚úÖ Start ISO (sin milisegundos):', startISO);\nconsole.log('‚úÖ End ISO (sin milisegundos):', endISO);\nconsole.log('‚úÖ Duraci√≥n:', duracion, 'minutos');\n\n// Calcular d√≠a de la semana\nconst dayOfWeek = startDate.getDay();\nconst dayNames = ['domingo', 'lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado'];\nconst dayName = dayNames[dayOfWeek];\n\n// ========================================================================\n// VALIDAR QUE LA SEDE TIENE HORARIOS EN ESE D√çA\n// ========================================================================\n\nconst hasSchedule = HELPERS.sedeHasScheduleOnDay(sedeNormalized, dayOfWeek);\n\nif (!hasSchedule) {\n  const workingDays = HELPERS.getWorkingDays(sedeNormalized);\n  const workingDayNames = workingDays.map(d => dayNames[d]);\n  \n  console.warn('‚ö†Ô∏è La sede no tiene horarios el', dayName);\n  console.warn('‚ö†Ô∏è D√≠as laborables:', workingDayNames);\n  \n  // No abortar, solo advertir - la validaci√≥n detallada se har√° despu√©s\n}\n\n// ========================================================================\n// CONSTRUIR NUEVO APPOINTMENT\n// ========================================================================\n\nconst newAppointment = {\n  calendarId: calendarId,\n  startISO: startISO,\n  endISO: endISO,\n  date: input.newDate,\n  time: input.newTime,\n  dateLocal: input.newDate,\n  timeLocal: input.newTime,\n  sede: sedeNormalized,\n  dayOfWeek: dayOfWeek,\n  dayName: dayName,\n  timezone: SCHEDULE.tz,\n  duration: duracion\n};\n\nconsole.log('‚úÖ newAppointment construido:', JSON.stringify(newAppointment, null, 2));\n\n// ========================================================================\n// CONSTRUIR RESULTADO COMPLETO\n// ========================================================================\n\nconst result = {\n  // Mantener todos los datos anteriores\n  ...input,\n  \n  // Actualizar sede normalizada\n  newSede: sedeNormalized,\n  \n  // Agregar nueva informaci√≥n\n  newAppointment: newAppointment,\n  \n  // Metadata √∫til\n  _scheduleVersion: SCHEDULE.version,\n  _scheduleUpdatedAt: store.SCHEDULE_UPDATED_AT\n};\n\n// ========================================================================\n// VERIFICACI√ìN FINAL\n// ========================================================================\n\nconsole.log('‚úÖ ===== PARSE NEW DATETIME v3.2 - RESULTADO =====');\nconsole.log('‚úÖ calendarId:', result.newAppointment.calendarId);\nconsole.log('‚úÖ startISO:', result.newAppointment.startISO);\nconsole.log('‚úÖ endISO:', result.newAppointment.endISO);\nconsole.log('‚úÖ sede:', result.newSede);\nconsole.log('‚úÖ pacienteNombre:', result.oldAppointment?.pacienteNombre);\n\n// Verificaci√≥n de campos cr√≠ticos\nconst errors = [];\n\nif (!result.newAppointment.calendarId) {\n  console.error('‚ùå CR√çTICO: calendarId es undefined');\n  errors.push('calendarId missing');\n}\nif (!result.newAppointment.startISO) {\n  console.error('‚ùå CR√çTICO: startISO es undefined');\n  errors.push('startISO missing');\n}\nif (!result.newAppointment.endISO) {\n  console.error('‚ùå CR√çTICO: endISO es undefined');\n  errors.push('endISO missing');\n}\n\n// Validar formato ISO (no debe tener .000)\nif (result.newAppointment.startISO && result.newAppointment.startISO.includes('.')) {\n  console.error('‚ùå CR√çTICO: startISO contiene milisegundos:', result.newAppointment.startISO);\n  errors.push('startISO has milliseconds');\n}\nif (result.newAppointment.endISO && result.newAppointment.endISO.includes('.')) {\n  console.error('‚ùå CR√çTICO: endISO contiene milisegundos:', result.newAppointment.endISO);\n  errors.push('endISO has milliseconds');\n}\n\nif (errors.length > 0) {\n  console.error('‚ùå ERRORES DE VALIDACI√ìN:', errors);\n  console.error('   Abortando para prevenir error en Google Calendar');\n  \n  return [{\n    json: {\n      status: 'ERROR',\n      error: 'VALIDATION_FAILED',\n      message: 'Validaci√≥n de datos cr√≠ticos fall√≥',\n      errors: errors,\n      _abort: true\n    }\n  }];\n}\n\nconsole.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\n\nreturn [{ json: result }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        816,
        32
      ],
      "id": "4671ba71-54ec-4477-9869-cbd9027ead03",
      "name": "Parse New DateTime"
    },
    {
      "parameters": {
        "jsCode": "/**\n * ========================================================================\n * Validate Doctor Schedule v5.0 - PRODUCTION READY\n * ========================================================================\n * MEJORAS v5.0:\n * ‚úÖ C√°lculo correcto de dayOfWeek con timezone\n * ‚úÖ Validaci√≥n de rango hora/minutos\n * ‚úÖ Manejo correcto de medianoche\n * ‚úÖ Logging detallado\n * ‚úÖ Mensajes descriptivos con horarios sugeridos\n * ‚úÖ Metadata enriquecida\n * ‚úÖ Configuraci√≥n centralizada\n * ‚úÖ Manejo expl√≠cito de s√°bados alternos\n *\n * Entradas esperadas:\n *   {\n *     newAppointment: {\n *       sede: \"POLANCO\" | \"SATELITE\",\n *       date: \"YYYY-MM-DD\",\n *       dayOfWeek: 0..6 (opcional),\n *       time: \"HH:MM\",\n *       duracionMinutos: 30\n *     }\n *   }\n */\n\nconst ctx = $input.first()?.json || {};\nconst appt = ctx.newAppointment || {};\nlet { sede, dayOfWeek, time, duracionMinutos = 30, date } = appt;\n\n// ========================================================================\n// CONSTANTES DE CONFIGURACI√ìN\n// ========================================================================\n\nconst CONFIG = {\n  TIMEZONE: 'America/Mexico_City',\n  DEFAULT_DURATION: 30,\n  \n  // Horarios oficiales del doctor (24h formato)\n  SCHEDULE: {\n    POLANCO: {\n      1: [['09:00', '13:00']],                    // Lunes\n      2: [['16:00', '20:00']],                    // Martes\n      3: [],                                       // Mi√©rcoles\n      4: [],                                       // Jueves\n      5: [['15:00', '19:00']],                    // Viernes\n      6: [],                                       // S√°bado\n      0: []                                        // Domingo\n    },\n    SATELITE: {\n      1: [],                                       // Lunes\n      2: [],                                       // Martes\n      3: [['09:00', '13:00']],                    // Mi√©rcoles\n      4: [['09:00', '13:00'], ['15:00', '20:00']], // Jueves (turno partido)\n      5: [],                                       // Viernes\n      6: [['09:00', '13:00']],                    // S√°bado (alternos - requiere confirmaci√≥n)\n      0: []                                        // Domingo\n    }\n  },\n  \n  DAY_NAMES: ['domingo', 'lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado']\n};\n\n// ========================================================================\n// FUNCIONES AUXILIARES\n// ========================================================================\n\n/**\n * Convierte HH:MM a minutos desde medianoche\n */\nfunction toMinutes(hhmm) {\n  const [h, m] = String(hhmm).split(':').map(Number);\n  return h * 60 + m;\n}\n\n/**\n * Suma minutos a una hora HH:MM\n */\nfunction addMinutes(hhmm, minutes) {\n  const totalMin = toMinutes(hhmm) + minutes;\n  const h = Math.floor(totalMin / 60) % 24;\n  const m = totalMin % 60;\n  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;\n}\n\n/**\n * Formatea hora a 12h\n */\nfunction format12h(hhmm) {\n  const [H, M] = hhmm.split(':').map(Number);\n  const ampm = H >= 12 ? 'PM' : 'AM';\n  const h = ((H + 11) % 12) + 1;\n  return `${h}:${String(M).padStart(2, '0')} ${ampm}`;\n}\n\n/**\n * Obtiene nombre del d√≠a\n */\nfunction getDayName(dayIndex) {\n  return CONFIG.DAY_NAMES[dayIndex];\n}\n\n/**\n * Calcula dayOfWeek CORRECTAMENTE en timezone CDMX\n */\nfunction calculateDayOfWeek(dateString) {\n  // Usar Intl.DateTimeFormat para obtener el d√≠a correcto en CDMX\n  const date = new Date(`${dateString}T12:00:00Z`); // UTC mediod√≠a\n  \n  const formatter = new Intl.DateTimeFormat('en-US', {\n    timeZone: CONFIG.TIMEZONE,\n    weekday: 'short'\n  });\n  \n  const dayStr = formatter.format(date);\n  const dayMap = { 'Sun': 0, 'Mon': 1, 'Tue': 2, 'Wed': 3, 'Thu': 4, 'Fri': 5, 'Sat': 6 };\n  \n  return dayMap[dayStr];\n}\n\n/**\n * Valida formato y rango de hora\n */\nfunction validateTime(timeStr) {\n  if (!/^\\d{2}:\\d{2}$/.test(String(timeStr || ''))) {\n    return { valid: false, error: 'Formato inv√°lido. Use HH:MM' };\n  }\n  \n  const [h, m] = timeStr.split(':').map(Number);\n  \n  if (h < 0 || h > 23) {\n    return { valid: false, error: `Hora inv√°lida: ${h}. Debe estar entre 00 y 23` };\n  }\n  \n  if (m < 0 || m > 59) {\n    return { valid: false, error: `Minutos inv√°lidos: ${m}. Deben estar entre 00 y 59` };\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Verifica si un rango de tiempo cabe en alg√∫n intervalo\n */\nfunction fitsInSchedule(startTime, endTime, intervals) {\n  const startMin = toMinutes(startTime);\n  const endMin = toMinutes(endTime);\n  \n  // Manejar caso de medianoche (endTime < startTime significa que cruza medianoche)\n  const crossesMidnight = endMin <= startMin;\n  \n  if (crossesMidnight) {\n    // Si cruza medianoche, no puede caber en ning√∫n intervalo del mismo d√≠a\n    return false;\n  }\n  \n  // Verificar si el rango cae completamente dentro de alg√∫n intervalo\n  return intervals.some(([intervalStart, intervalEnd]) => {\n    const intervalStartMin = toMinutes(intervalStart);\n    const intervalEndMin = toMinutes(intervalEnd);\n    \n    return startMin >= intervalStartMin && endMin <= intervalEndMin;\n  });\n}\n\n/**\n * Genera sugerencias de horarios disponibles\n */\nfunction suggestAvailableSlots(intervals, duration) {\n  const suggestions = [];\n  \n  intervals.forEach(([start, end]) => {\n    const startMin = toMinutes(start);\n    const endMin = toMinutes(end);\n    const availableMin = endMin - startMin;\n    \n    // Generar slots cada 30 minutos\n    for (let min = startMin; min + duration <= endMin; min += 30) {\n      const slotStart = `${String(Math.floor(min / 60)).padStart(2, '0')}:${String(min % 60).padStart(2, '0')}`;\n      const slotEnd = addMinutes(slotStart, duration);\n      \n      suggestions.push({\n        start: slotStart,\n        end: slotEnd,\n        start12: format12h(slotStart),\n        end12: format12h(slotEnd)\n      });\n    }\n  });\n  \n  return suggestions;\n}\n\n// ========================================================================\n// VALIDACIONES B√ÅSICAS\n// ========================================================================\n\nconst metadata = {\n  validationStarted: new Date().toISOString(),\n  version: '5.0'\n};\n\n// 1. Validar sede\nif (!sede || !['POLANCO', 'SATELITE'].includes(String(sede).toUpperCase())) {\n  console.error('‚ùå Invalid sede:', sede);\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'VALIDATION_ERROR',\n      message: `Sede inv√°lida: ${sede}. Debe ser POLANCO o SATELITE`,\n      validSedes: ['POLANCO', 'SATELITE'],\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\nsede = String(sede).toUpperCase();\n\n// 2. Calcular dayOfWeek si no viene\nif ((dayOfWeek === undefined || dayOfWeek === null) && date) {\n  dayOfWeek = calculateDayOfWeek(date);\n  console.log(`üìÖ Calculated dayOfWeek: ${dayOfWeek} (${getDayName(dayOfWeek)})`);\n}\n\n// 3. Validar dayOfWeek\nif (typeof dayOfWeek !== 'number' || dayOfWeek < 0 || dayOfWeek > 6) {\n  console.error('‚ùå Invalid dayOfWeek:', dayOfWeek);\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'VALIDATION_ERROR',\n      message: 'dayOfWeek inv√°lido o ausente. Debe ser 0-6 (0=domingo)',\n      received: { dayOfWeek, date },\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// 4. Validar formato y rango de time\nconst timeValidation = validateTime(time);\nif (!timeValidation.valid) {\n  console.error('‚ùå Invalid time:', time, timeValidation.error);\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'VALIDATION_ERROR',\n      message: `Hora inv√°lida: ${timeValidation.error}`,\n      received: time,\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// 5. Validar duraci√≥n\nduracionMinutos = Number.isFinite(+duracionMinutos) ? +duracionMinutos : CONFIG.DEFAULT_DURATION;\n\nif (duracionMinutos <= 0 || duracionMinutos > 120) {\n  console.warn('‚ö†Ô∏è Unusual duration:', duracionMinutos);\n}\n\n// ========================================================================\n// VALIDACI√ìN DE HORARIO\n// ========================================================================\n\nconst intervals = CONFIG.SCHEDULE[sede][dayOfWeek] || [];\nconst dayNameStr = getDayName(dayOfWeek);\n\n// Verificar si hay consulta ese d√≠a\nif (!intervals.length) {\n  console.warn(`‚ö†Ô∏è No schedule for ${dayNameStr} at ${sede}`);\n  \n  // Encontrar d√≠as disponibles en esta sede\n  const availableDays = Object.entries(CONFIG.SCHEDULE[sede])\n    .filter(([day, slots]) => slots.length > 0)\n    .map(([day, slots]) => ({\n      day: parseInt(day),\n      dayName: getDayName(parseInt(day)),\n      intervals: slots.map(([s, e]) => ({ start: s, end: e, start12: format12h(s), end12: format12h(e) }))\n    }));\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'DAY_NOT_AVAILABLE',\n      message: `No hay consulta los ${dayNameStr}s en ${sede}`,\n      requestedDay: {\n        dayOfWeek,\n        dayName: dayNameStr,\n        sede\n      },\n      availableDays,\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// Calcular hora de fin\nconst startTime = time;\nconst endTime = addMinutes(time, duracionMinutos);\n\n// Verificar si cruza medianoche\nconst crossesMidnight = toMinutes(endTime) <= toMinutes(startTime);\n\nif (crossesMidnight) {\n  console.error('‚ùå Appointment crosses midnight:', { startTime, endTime, duracionMinutos });\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'CROSSES_MIDNIGHT',\n      message: `La cita de ${format12h(startTime)} con duraci√≥n ${duracionMinutos} min cruza la medianoche. Esto no est√° permitido.`,\n      startTime,\n      endTime,\n      duracionMinutos,\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// Verificar si cabe en el horario\nconst fits = fitsInSchedule(startTime, endTime, intervals);\n\nif (!fits) {\n  console.warn(`‚ö†Ô∏è Time out of range: ${startTime} - ${endTime} not in intervals`);\n  \n  const suggestions = suggestAvailableSlots(intervals, duracionMinutos);\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'TIME_OUT_OF_RANGE',\n      message: `El horario ${format12h(startTime)} - ${format12h(endTime)} (${duracionMinutos} min) no est√° disponible en ${sede}`,\n      requestedTime: {\n        start: startTime,\n        end: endTime,\n        start12: format12h(startTime),\n        end12: format12h(endTime),\n        duration: duracionMinutos\n      },\n      availableIntervals: intervals.map(([s, e]) => ({\n        start: s,\n        end: e,\n        start12: format12h(s),\n        end12: format12h(e)\n      })),\n      suggestedSlots: suggestions.slice(0, 10), // Primeros 10 slots\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// ========================================================================\n// MANEJO ESPECIAL: S√ÅBADOS EN SAT√âLITE\n// ========================================================================\n\nconst isSaturdayAtSatelite = (sede === 'SATELITE' && dayOfWeek === 6);\n\n// ========================================================================\n// CONSTRUIR RESPUESTA EXITOSA\n// ========================================================================\n\nconst output = {\n  ...ctx,\n  \n  scheduleCheck: {\n    valid: true,\n    sede,\n    dayOfWeek,\n    dayName: dayNameStr,\n    timeStart: startTime,\n    timeEnd: endTime,\n    timeStart12: format12h(startTime),\n    timeEnd12: format12h(endTime),\n    durationMin: duracionMinutos,\n    intervals: intervals.map(([s, e]) => ({ start: s, end: e })),\n    saturdayNeedsConfirmation: isSaturdayAtSatelite,\n    checkedAt: new Date().toISOString()\n  },\n  \n  _metadata: {\n    ...metadata,\n    validationCompleted: new Date().toISOString()\n  }\n};\n\n// Marcar s√°bados alternos en SAT√âLITE\nif (isSaturdayAtSatelite) {\n  output.status = 'NEEDS_CONFIRMATION';\n  output.message = `‚ö†Ô∏è S√°bado en SAT√âLITE es alterno. La cita requiere confirmaci√≥n de disponibilidad con el doctor.`;\n  \n  console.warn('‚ö†Ô∏è Saturday at SATELITE - requires confirmation');\n}\n\n// ========================================================================\n// LOGGING\n// ========================================================================\n\nconsole.log('‚úÖ Schedule validation passed:', JSON.stringify({\n  sede,\n  day: `${dayNameStr} (${dayOfWeek})`,\n  time: `${format12h(startTime)} - ${format12h(endTime)}`,\n  duration: `${duracionMinutos} min`,\n  intervals: intervals.map(([s, e]) => `${format12h(s)}-${format12h(e)}`).join(', '),\n  needsConfirmation: isSaturdayAtSatelite\n}, null, 2));\n\nreturn [{ json: output }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        32
      ],
      "id": "57d99a18-0680-479d-a705-b58cacaddf9c",
      "name": "Validate Doctor Schedule"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._abort}}",
              "value2": true
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1264,
        32
      ],
      "id": "d2099dcc-5453-4b19-9773-6b033e71a8ad",
      "name": "Schedule Valid?"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "status",
              "name": "status",
              "value": "={{$json.status}}",
              "type": "string"
            },
            {
              "id": "message",
              "name": "message",
              "value": "={{$json.message}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1488,
        -64
      ],
      "id": "88d339cf-16cb-4de5-abe6-2eb53ff3dc82",
      "name": "Return Invalid Schedule"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "HtbhK8aN1uBbKCLU",
          "mode": "list",
          "cachedResultUrl": "/workflow/HtbhK8aN1uBbKCLU",
          "cachedResultName": "DISPONIBILIDAD_CALENDARIO"
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [
        1488,
        128
      ],
      "id": "b7834d93-50fe-4e30-95d2-69e2d394caeb",
      "name": "Call 'DISPONIBILIDAD_CALENDARIO'",
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 1000
    },
    {
      "parameters": {
        "jsCode": "/**\n * ========================================================================\n * Check Availability v5.0 - PRODUCTION READY\n * ========================================================================\n * MEJORAS v5.0:\n * ‚úÖ Comparaci√≥n robusta de timestamps (normalizaci√≥n)\n * ‚úÖ Maneja m√∫ltiples formatos de slot\n * ‚úÖ Valida respuesta del workflow\n * ‚úÖ Proporciona alternativas cercanas\n * ‚úÖ Distingue entre slot ocupado vs no existente\n * ‚úÖ Logging detallado\n * ‚úÖ Metadata enriquecida\n * ‚úÖ Manejo de errores del workflow\n *\n * Procesa la respuesta del workflow DISPONIBILIDAD_CALENDARIO\n */\n\nconst ctx = $items('Validate Doctor Schedule')[0]?.json || {};\nconst availResult = $input.first()?.json || {};\n\nconst { newAppointment } = ctx;\n\n// ========================================================================\n// FUNCIONES AUXILIARES\n// ========================================================================\n\n/**\n * Normaliza timestamp ISO para comparaci√≥n consistente\n * Convierte a formato est√°ndar sin milisegundos\n */\nfunction normalizeISO(isoString) {\n  if (!isoString) return null;\n  \n  try {\n    const date = new Date(isoString);\n    \n    if (isNaN(date.getTime())) {\n      console.warn('‚ö†Ô∏è Invalid ISO string:', isoString);\n      return null;\n    }\n    \n    // Formato est√°ndar: YYYY-MM-DDTHH:mm:ssZ (sin milisegundos)\n    return date.toISOString().replace(/\\.\\d{3}Z$/, 'Z');\n  } catch (e) {\n    console.error('‚ùå Error normalizing ISO:', isoString, e);\n    return null;\n  }\n}\n\n/**\n * Obtiene el timestamp de inicio de un slot (maneja m√∫ltiples formatos)\n */\nfunction getSlotStart(slot) {\n  return slot.startISO || slot.start || slot.startTime || null;\n}\n\n/**\n * Calcula diferencia en minutos entre dos timestamps\n */\nfunction minutesDiff(iso1, iso2) {\n  const d1 = new Date(iso1);\n  const d2 = new Date(iso2);\n  return Math.abs((d1 - d2) / 60000);\n}\n\n/**\n * Formatea timestamp para display\n */\nfunction formatDateTime(isoString) {\n  if (!isoString) return 'N/A';\n  \n  const date = new Date(isoString);\n  return date.toLocaleString('es-MX', {\n    timeZone: 'America/Mexico_City',\n    weekday: 'short',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: true\n  });\n}\n\n// ========================================================================\n// VALIDACIONES B√ÅSICAS\n// ========================================================================\n\nconst metadata = {\n  checkStarted: new Date().toISOString(),\n  version: '5.0'\n};\n\nif (!newAppointment) {\n  console.error('‚ùå Missing newAppointment in context');\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'MISSING_DATA',\n      message: 'Datos de cita no encontrados en el contexto',\n      available: false,\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\nif (!newAppointment.startISO) {\n  console.error('‚ùå Missing startISO in newAppointment:', newAppointment);\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'MISSING_START_TIME',\n      message: 'Falta startISO en newAppointment',\n      newAppointment,\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// ========================================================================\n// VALIDAR RESPUESTA DEL WORKFLOW\n// ========================================================================\n\n// Verificar si el workflow devolvi√≥ un error\nif (availResult.error || availResult.status === 'error') {\n  console.error('‚ùå Availability workflow error:', availResult);\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'AVAILABILITY_ERROR',\n      message: availResult.message || 'Error al consultar disponibilidad de calendario',\n      error: availResult.error,\n      available: false,\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// Verificar si hay slots\nconst slots = availResult.slots || availResult.allowedSlots || [];\n\nif (!Array.isArray(slots)) {\n  console.error('‚ùå Invalid slots format:', typeof slots);\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'INVALID_RESPONSE',\n      message: 'Formato de respuesta inv√°lido del workflow de disponibilidad',\n      receivedType: typeof slots,\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\nif (slots.length === 0) {\n  console.warn('‚ö†Ô∏è No slots returned from availability workflow');\n  \n  return [{\n    json: {\n      ...ctx,\n      status: 'NO_SLOTS_AVAILABLE',\n      message: 'No hay horarios disponibles en el rango consultado',\n      available: false,\n      metadata,\n      _abort: true\n    }\n  }];\n}\n\n// ========================================================================\n// BUSCAR SLOT ESPEC√çFICO (CON NORMALIZACI√ìN)\n// ========================================================================\n\nconst requestedTime = normalizeISO(newAppointment.startISO);\n\nconsole.log('üîç Buscando slot:', {\n  requested: requestedTime,\n  totalSlots: slots.length,\n  sampleSlots: slots.slice(0, 3).map(s => ({\n    start: normalizeISO(getSlotStart(s)),\n    available: s.available\n  }))\n});\n\n// Buscar slot exacto\nlet requestedSlot = null;\nlet closestSlots = [];\n\nslots.forEach(slot => {\n  const slotStart = getSlotStart(slot);\n  const slotTime = normalizeISO(slotStart);\n  \n  if (!slotTime) {\n    console.warn('‚ö†Ô∏è Slot sin timestamp v√°lido:', slot);\n    return;\n  }\n  \n  // Comparaci√≥n exacta (normalizada)\n  if (slotTime === requestedTime) {\n    requestedSlot = slot;\n    console.log('‚úÖ Slot exacto encontrado:', {\n      start: slotTime,\n      available: slot.available,\n      sede: slot.sede\n    });\n  }\n  \n  // Guardar slots cercanos (¬±2 horas) para sugerencias\n  const diffMin = minutesDiff(slotTime, requestedTime);\n  if (diffMin <= 120) {\n    closestSlots.push({\n      ...slot,\n      startNormalized: slotTime,\n      diffMinutes: diffMin,\n      diffDisplay: `${Math.floor(diffMin / 60)}h ${diffMin % 60}m`\n    });\n  }\n});\n\n// Ordenar slots cercanos por cercan√≠a y disponibilidad\nclosestSlots.sort((a, b) => {\n  // Primero por disponibilidad, luego por cercan√≠a\n  if (a.available && !b.available) return -1;\n  if (!a.available && b.available) return 1;\n  return a.diffMinutes - b.diffMinutes;\n});\n\n// ========================================================================\n// ANALIZAR RESULTADO\n// ========================================================================\n\nconst available = requestedSlot?.available === true;\nconst slotFound = !!requestedSlot;\n\n// Logging detallado\nif (!slotFound) {\n  console.warn('‚ö†Ô∏è Slot exacto NO encontrado');\n  console.warn('üìã Slots m√°s cercanos:', closestSlots.slice(0, 5).map(s => ({\n    start: formatDateTime(s.startNormalized),\n    available: s.available,\n    diff: s.diffDisplay\n  })));\n} else if (!available) {\n  console.warn('‚ùå Slot encontrado pero NO disponible (ocupado)');\n  console.warn('üìã Alternativas disponibles:', closestSlots\n    .filter(s => s.available)\n    .slice(0, 5)\n    .map(s => ({\n      start: formatDateTime(s.startNormalized),\n      diff: s.diffDisplay\n    })));\n} else {\n  console.log('‚úÖ Slot encontrado y DISPONIBLE');\n}\n\n// ========================================================================\n// CONSTRUIR RESPUESTA\n// ========================================================================\n\nconst output = {\n  ...ctx,\n  available,\n  \n  availabilityCheck: {\n    requestedSlot: requestedTime,\n    requestedDisplay: formatDateTime(requestedTime),\n    found: slotFound,\n    available,\n    status: !slotFound ? 'NOT_FOUND' : (available ? 'AVAILABLE' : 'OCCUPIED'),\n    checkedAt: new Date().toISOString(),\n    \n    // Informaci√≥n del slot encontrado (si existe)\n    slotDetails: requestedSlot ? {\n      start: normalizeISO(getSlotStart(requestedSlot)),\n      end: requestedSlot.end || requestedSlot.endISO,\n      available: requestedSlot.available,\n      sede: requestedSlot.sede,\n      calendarId: requestedSlot.calendarId\n    } : null,\n    \n    // Total de slots revisados\n    totalSlotsChecked: slots.length,\n    \n    // Slots cercanos como alternativas\n    nearbySlots: closestSlots.slice(0, 10).map(s => ({\n      start: s.startNormalized,\n      startDisplay: formatDateTime(s.startNormalized),\n      available: s.available,\n      diffMinutes: s.diffMinutes,\n      diffDisplay: s.diffDisplay,\n      sede: s.sede\n    }))\n  },\n  \n  _metadata: {\n    ...metadata,\n    checkCompleted: new Date().toISOString()\n  }\n};\n\n// ========================================================================\n// LOGGING FINAL\n// ========================================================================\n\nconsole.log('üìä Availability check resultado:', JSON.stringify({\n  requested: formatDateTime(requestedTime),\n  found: slotFound,\n  available,\n  status: output.availabilityCheck.status,\n  totalChecked: slots.length,\n  nearbyAvailable: closestSlots.filter(s => s.available).length\n}, null, 2));\n\nreturn [{ json: output }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1712,
        128
      ],
      "id": "52fb76d9-3f2f-46b0-89c3-284bcd1d0a6b",
      "name": "Check if Available"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.available}}",
              "value2": true
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        1936,
        128
      ],
      "id": "e6080115-487a-4193-8f19-5a9aebb43a8c",
      "name": "Available?"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "status",
              "name": "status",
              "value": "UNAVAILABLE",
              "type": "string"
            },
            {
              "id": "message",
              "name": "message",
              "value": "=El horario solicitado ({{ $json.newAppointment.date }} {{ $json.newAppointment.time }}) ya no est√° disponible",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2160,
        32
      ],
      "id": "31d701d6-4e59-4c07-95b9-67f635af1060",
      "name": "Return Unavailable"
    },
    {
      "parameters": {
        "operation": "delete",
        "calendar": {
          "__rl": true,
          "value": "={{$json.oldAppointment.calendarId}} ",
          "mode": "id"
        },
        "eventId": "={{$json.oldAppointment.calendarEventId}}",
        "options": {
          "sendUpdates": "all"
        }
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        2384,
        128
      ],
      "id": "64e94191-c29f-44db-b9f2-10471cf4f449",
      "name": "Delete Old Calendar Event",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 2000,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "LWCHe5J8QGKC4iFi",
          "name": "Google Calendar account - Clinicasdelcorazoncdmx@gmail.com"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "calendar": {
          "__rl": true,
          "value": "={{ $('Available?').item.json.newAppointment.calendarId }}",
          "mode": "id"
        },
        "start": "={{ $('Available?').item.json.newAppointment.startISO }}",
        "end": "={{ $('Available?').item.json.newAppointment.endISO }}",
        "additionalFields": {
          "description": "=CITA REAGENDADA\nPaciente: {{ $('Available?').item.json.oldAppointment.pacienteNombre }}\nTel√©fono: {{ $('Available?').item.json.oldAppointment.telefono }}\nTipo Cita: {{ $('Available?').item.json.oldAppointment.tipoCita }}\n\nMotivo del cambio: {{ $('Available?').item.json.reason }}",
          "summary": "=={{ `üè• Reagendado ‚Äì ${$('Available?').item.json.oldAppointment.pacienteNombre} ‚Äì üìç ${$('Available?').item.json.newSede} ‚Äì üìû ${$('Available?').item.json.oldAppointment.telefono}` }}"
        }
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        2608,
        224
      ],
      "id": "08af8a97-0131-4307-86d8-d05c911472af",
      "name": "Create New Calendar Event",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 2000,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "LWCHe5J8QGKC4iFi",
          "name": "Google Calendar account - Clinicasdelcorazoncdmx@gmail.com"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * ========================================================================\n * Prepare RPC Call v6.1 - PRODUCTION READY\n * ========================================================================\n * CORRECCI√ìN v6.1:\n * ‚úÖ Usa reagendar_consulta_atomica (funci√≥n correcta)\n * ‚úÖ Par√°metros actualizados seg√∫n schema DB\n * ‚úÖ Obtiene datos del contexto desde nodo anterior correcto\n * ‚úÖ Obtiene evento de calendario del input actual\n * ‚úÖ Validaci√≥n completa de datos de entrada\n * ‚úÖ Informaci√≥n de auditor√≠a completa\n * ‚úÖ Manejo correcto de NULLs\n * ‚úÖ Metadata enriquecida\n * ‚úÖ Logging detallado\n *\n * Prepara los par√°metros para llamar a la funci√≥n RPC de reagendamiento\n * en PostgreSQL: reagendar_consulta_atomica()\n */\n\n// ========================================================================\n// OBTENER DATOS DE ENTRADA\n// ========================================================================\n\n// 1. Evento de calendario (del nodo actual - \"Create New Calendar Event\")\nconst calendarEvent = $input.first()?.json || {};\n\n// 2. Contexto original con oldAppointment, newAppointment, telefono, reason\n//    Obtener desde el nodo \"If\" que tiene todos los datos originales\nconst ctx = $('If')?.item?.json || $('Available?')?.item?.json || {};\n\nconsole.log('üì• Datos recibidos:', {\n  hasCalendarEvent: !!calendarEvent.id,\n  hasContext: !!ctx.oldAppointment,\n  calendarEventId: calendarEvent.id,\n  contextKeys: Object.keys(ctx)\n});\n\nconst { oldAppointment, newAppointment, telefono, reason } = ctx;\n\n// ========================================================================\n// CONSTANTES\n// ========================================================================\n\nconst CONFIG = {\n  RPC_FUNCTION: 'reagendar_consulta_atomica',\n  VERSION: '6.1',\n  TIMEZONE: 'America/Mexico_City',\n  DEFAULT_DURATION: 30\n};\n\n// ========================================================================\n// FUNCIONES AUXILIARES\n// ========================================================================\n\n/**\n * Valida que un timestamp ISO sea v√°lido\n */\nfunction validateISO(isoString) {\n  if (!isoString) return { valid: false, error: 'Timestamp vac√≠o' };\n  \n  const date = new Date(isoString);\n  \n  if (isNaN(date.getTime())) {\n    return { valid: false, error: 'Formato ISO inv√°lido' };\n  }\n  \n  return { valid: true, date };\n}\n\n/**\n * Valida UUID formato\n */\nfunction validateUUID(uuid) {\n  if (!uuid) return { valid: false, error: 'UUID vac√≠o' };\n  \n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n  \n  if (!uuidRegex.test(uuid)) {\n    return { valid: false, error: 'Formato UUID inv√°lido' };\n  }\n  \n  return { valid: true };\n}\n\n/**\n * Formatea fecha para display\n */\nfunction formatDateTime(isoString) {\n  const date = new Date(isoString);\n  return date.toLocaleString('es-MX', {\n    timeZone: CONFIG.TIMEZONE,\n    dateStyle: 'full',\n    timeStyle: 'short'\n  });\n}\n\n/**\n * Convierte hora HH:MM a HH:MM:SS\n */\nfunction formatTimeWithSeconds(time) {\n  if (!time) return '00:00:00';\n  \n  // Si ya tiene segundos, retornar tal cual\n  if (time.split(':').length === 3) {\n    return time;\n  }\n  \n  // Si solo tiene HH:MM, agregar :00\n  return time + ':00';\n}\n\n// ========================================================================\n// VALIDACIONES DE ENTRADA\n// ========================================================================\n\nconst metadata = {\n  prepareStarted: new Date().toISOString(),\n  version: CONFIG.VERSION,\n  rpcFunction: CONFIG.RPC_FUNCTION\n};\n\nconst errors = [];\n\n// 1. Validar oldAppointment\nif (!oldAppointment) {\n  errors.push({\n    field: 'oldAppointment',\n    code: 'MISSING_OLD_APPOINTMENT',\n    message: 'Datos de cita antigua no encontrados'\n  });\n} else {\n  // Validar UUID\n  const uuidField = oldAppointment.uuid || oldAppointment.consulta_uuid;\n  \n  if (!uuidField) {\n    errors.push({\n      field: 'oldAppointment.uuid',\n      code: 'MISSING_UUID',\n      message: 'UUID de consulta faltante en oldAppointment'\n    });\n  } else {\n    const uuidValidation = validateUUID(uuidField);\n    if (!uuidValidation.valid) {\n      errors.push({\n        field: 'oldAppointment.uuid',\n        code: 'INVALID_UUID',\n        message: uuidValidation.error,\n        received: uuidField\n      });\n    }\n  }\n  \n  // Validar otros campos requeridos\n  if (!oldAppointment.sede) {\n    errors.push({\n      field: 'oldAppointment.sede',\n      code: 'MISSING_SEDE',\n      message: 'Sede faltante en oldAppointment'\n    });\n  }\n  \n  if (!oldAppointment.fechaHoraUtc) {\n    errors.push({\n      field: 'oldAppointment.fechaHoraUtc',\n      code: 'MISSING_OLD_DATETIME',\n      message: 'Fecha/hora faltante en oldAppointment'\n    });\n  }\n}\n\n// 2. Validar newAppointment\nif (!newAppointment) {\n  errors.push({\n    field: 'newAppointment',\n    code: 'MISSING_NEW_APPOINTMENT',\n    message: 'Datos de cita nueva no encontrados'\n  });\n} else {\n  // Validar startISO\n  if (!newAppointment.startISO) {\n    errors.push({\n      field: 'newAppointment.startISO',\n      code: 'MISSING_START_ISO',\n      message: 'startISO faltante en newAppointment'\n    });\n  } else {\n    const isoValidation = validateISO(newAppointment.startISO);\n    if (!isoValidation.valid) {\n      errors.push({\n        field: 'newAppointment.startISO',\n        code: 'INVALID_START_ISO',\n        message: isoValidation.error,\n        received: newAppointment.startISO\n      });\n    }\n  }\n  \n  // Validar date\n  if (!newAppointment.date) {\n    errors.push({\n      field: 'newAppointment.date',\n      code: 'MISSING_DATE',\n      message: 'date faltante en newAppointment'\n    });\n  }\n  \n  // Validar time\n  if (!newAppointment.time) {\n    errors.push({\n      field: 'newAppointment.time',\n      code: 'MISSING_TIME',\n      message: 'time faltante en newAppointment'\n    });\n  }\n  \n  // Validar sede\n  if (!newAppointment.sede) {\n    errors.push({\n      field: 'newAppointment.sede',\n      code: 'MISSING_NEW_SEDE',\n      message: 'Sede faltante en newAppointment'\n    });\n  } else if (!['POLANCO', 'SATELITE'].includes(newAppointment.sede)) {\n    errors.push({\n      field: 'newAppointment.sede',\n      code: 'INVALID_SEDE',\n      message: `Sede inv√°lida: ${newAppointment.sede}`,\n      received: newAppointment.sede\n    });\n  }\n}\n\n// 3. Validar tel√©fono\nif (!telefono) {\n  errors.push({\n    field: 'telefono',\n    code: 'MISSING_TELEFONO',\n    message: 'Tel√©fono faltante'\n  });\n} else if (!/^\\d{10}$/.test(telefono)) {\n  errors.push({\n    field: 'telefono',\n    code: 'INVALID_TELEFONO',\n    message: 'Tel√©fono debe tener 10 d√≠gitos',\n    received: telefono\n  });\n}\n\n// 4. Validar Calendar Event\nlet newCalendarEventId = null;\nlet newCalendarLink = null;\nlet calendarEventCreated = false;\n\nif (calendarEvent && calendarEvent.id) {\n  // Evento creado exitosamente\n  newCalendarEventId = calendarEvent.id;\n  newCalendarLink = calendarEvent.htmlLink || null;\n  calendarEventCreated = true;\n  \n  console.log('‚úÖ Evento de calendario creado:', {\n    id: newCalendarEventId,\n    link: newCalendarLink\n  });\n} else {\n  console.warn('‚ö†Ô∏è Evento de calendario NO creado o sin ID');\n  \n  // IMPORTANTE: Para reagendar_consulta_atomica, el calendar_event_id es REQUERIDO\n  errors.push({\n    field: 'calendarEvent',\n    code: 'MISSING_CALENDAR_EVENT',\n    message: 'No se pudo crear el evento de calendario. Es requerido para reagendar.'\n  });\n}\n\n// ========================================================================\n// RETORNAR ERRORES SI HAY\n// ========================================================================\n\nif (errors.length > 0) {\n  console.error('‚ùå Validaci√≥n fallida:', JSON.stringify(errors, null, 2));\n  \n  return [{\n    json: {\n      status: 'VALIDATION_ERROR',\n      message: 'Fall√≥ la validaci√≥n de datos para RPC',\n      errors,\n      metadata,\n      _abort: true,\n      _debug: {\n        hasCalendarEvent: !!calendarEvent.id,\n        hasContext: !!ctx.oldAppointment,\n        contextKeys: Object.keys(ctx),\n        calendarEventKeys: Object.keys(calendarEvent)\n      }\n    }\n  }];\n}\n\n// ========================================================================\n// PREPARAR PAR√ÅMETROS RPC\n// ========================================================================\n\n// Usar el campo correcto del UUID\nconst consultaUuid = oldAppointment.uuid || oldAppointment.consulta_uuid;\n\n// Formatear hora con segundos\nconst nuevaHoraConsulta = formatTimeWithSeconds(newAppointment.time);\n\nconst rpcParams = {\n  // UUID de la consulta anterior a reagendar\n  p_consulta_uuid_anterior: consultaUuid,\n  \n  // Nueva fecha/hora en UTC (ISO 8601)\n  p_nueva_fecha_hora_utc: newAppointment.startISO,\n  \n  // Nueva fecha local (YYYY-MM-DD)\n  p_nueva_fecha_consulta: newAppointment.date,\n  \n  // Nueva hora local (HH:MM:SS)\n  p_nueva_hora_consulta: nuevaHoraConsulta,\n  \n  // Nueva sede (POLANCO o SATELITE)\n  p_nueva_sede: newAppointment.sede,\n  \n  // Timezone (opcional, default America/Mexico_City)\n  p_timezone: CONFIG.TIMEZONE,\n  \n  // Duraci√≥n en minutos (opcional, default 30)\n  p_nueva_duracion_minutos: CONFIG.DEFAULT_DURATION,\n  \n  // ID del nuevo evento en Google Calendar (REQUERIDO)\n  p_nuevo_calendar_event_id: newCalendarEventId,\n  \n  // Link del nuevo evento en Google Calendar (REQUERIDO)\n  p_nuevo_calendar_link: newCalendarLink,\n  \n  // Motivo del reagendamiento\n  p_motivo_reagendamiento: reason || 'Reagendamiento solicitado por paciente'\n};\n\n// ========================================================================\n// PREPARAR DATOS DE AUDITOR√çA\n// ========================================================================\n\nconst auditData = {\n  // Informaci√≥n de la cita antigua\n  oldAppointmentData: {\n    uuid: consultaUuid,\n    consultaId: oldAppointment.consultaId,\n    pacienteNombre: oldAppointment.pacienteNombre,\n    telefono: oldAppointment.telefono,\n    fechaHoraUtc: oldAppointment.fechaHoraUtc,\n    fechaHoraDisplay: formatDateTime(oldAppointment.fechaHoraUtc),\n    sede: oldAppointment.sede,\n    calendarEventId: oldAppointment.calendarEventId,\n    estadoCita: oldAppointment.estadoCita\n  },\n  \n  // Informaci√≥n de la cita nueva\n  newAppointmentData: {\n    fechaHoraUtc: newAppointment.startISO,\n    fechaHoraDisplay: formatDateTime(newAppointment.startISO),\n    sede: newAppointment.sede,\n    date: newAppointment.date,\n    time: newAppointment.time,\n    timeWithSeconds: nuevaHoraConsulta,\n    calendarEventId: newCalendarEventId,\n    calendarLink: newCalendarLink\n  },\n  \n  // Informaci√≥n del cambio\n  changeData: {\n    reason,\n    requestedBy: telefono,\n    timestamp: new Date().toISOString(),\n    calendarEventCreated,\n    \n    // Resumen del cambio\n    summary: {\n      sedeChanged: oldAppointment.sede !== newAppointment.sede,\n      oldSede: oldAppointment.sede,\n      newSede: newAppointment.sede,\n      oldDateTime: formatDateTime(oldAppointment.fechaHoraUtc),\n      newDateTime: formatDateTime(newAppointment.startISO)\n    }\n  }\n};\n\n// ========================================================================\n// CONSTRUIR RESPUESTA\n// ========================================================================\n\nconst output = {\n  ...ctx,\n  \n  // Par√°metros para el RPC\n  rpcParams,\n  \n  // IDs del nuevo evento\n  newCalendarEventId,\n  newCalendarLink,\n  \n  // Datos de auditor√≠a\n  _audit: auditData,\n  \n  // Metadata\n  _metadata: {\n    ...metadata,\n    prepareCompleted: new Date().toISOString(),\n    validationPassed: true,\n    errorsCount: 0,\n    warningsCount: 0\n  },\n  \n  // Flags √∫tiles\n  _flags: {\n    calendarEventCreated,\n    sedeChanged: auditData.changeData.summary.sedeChanged,\n    hasOldCalendarEvent: !!(oldAppointment.calendarEventId && oldAppointment.calendarEventId.trim())\n  }\n};\n\n// ========================================================================\n// LOGGING\n// ========================================================================\n\nconsole.log('‚úÖ RPC params preparados:', JSON.stringify({\n  function: CONFIG.RPC_FUNCTION,\n  params: {\n    consulta_uuid_anterior: consultaUuid,\n    nueva_fecha_hora_utc: newAppointment.startISO,\n    nueva_fecha_consulta: newAppointment.date,\n    nueva_hora_consulta: nuevaHoraConsulta,\n    nueva_sede: newAppointment.sede,\n    timezone: CONFIG.TIMEZONE,\n    nueva_duracion_minutos: CONFIG.DEFAULT_DURATION,\n    nuevo_calendar_event_id: newCalendarEventId,\n    nuevo_calendar_link: newCalendarLink,\n    motivo: reason,\n    \n    // Display info\n    old_datetime_display: formatDateTime(oldAppointment.fechaHoraUtc),\n    new_datetime_display: formatDateTime(newAppointment.startISO),\n    sede_changed: auditData.changeData.summary.sedeChanged\n  }\n}, null, 2));\n\nreturn [{ json: output }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2832,
        224
      ],
      "id": "bf654c32-a398-4234-97cc-d6215b94cdbb",
      "name": "Prepare RPC Call"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "=SELECT * FROM reagendar_consulta_atomica(\n  '{{ $json.rpcParams.p_consulta_uuid_anterior }}'::UUID,\n  '{{ $json.rpcParams.p_nueva_fecha_hora_utc }}'::TIMESTAMPTZ,\n  '{{ $json.rpcParams.p_nueva_fecha_consulta }}'::DATE,\n  '{{ $json.rpcParams.p_nueva_hora_consulta }}'::TIME,\n  '{{ $json.rpcParams.p_nueva_sede }}'::TEXT,\n  '{{ $json.rpcParams.p_timezone }}'::TEXT,\n  {{ $json.rpcParams.p_nueva_duracion_minutos }}::INTEGER,\n  '{{ $json.rpcParams.p_nuevo_calendar_event_id }}'::TEXT,\n  '{{ $json.rpcParams.p_nuevo_calendar_link }}'::TEXT,\n  '{{ $json.rpcParams.p_motivo_reagendamiento }}'::TEXT\n);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [
        3056,
        224
      ],
      "id": "242c0a97-82ea-458f-98cb-6f21d7ff5590",
      "name": "Reagendar (PostgreSQL)",
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 2000,
      "credentials": {
        "postgres": {
          "id": "k3E9sYtyRqQbgtHs",
          "name": "UROBOT"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * ========================================================================\n * Build Success Response v5.0 - PRODUCTION READY\n * ========================================================================\n * MEJORAS v5.0:\n * ‚úÖ Validaci√≥n completa del resultado RPC\n * ‚úÖ Nombres de campos corregidos\n * ‚úÖ Formato consistente de fechas\n * ‚úÖ Informaci√≥n completa para WhatsApp\n * ‚úÖ Datos para UROBOT optimizados\n * ‚úÖ Captura de advertencias\n * ‚úÖ Metadata de auditor√≠a completa\n * ‚úÖ Logging estructurado\n *\n * Construye la respuesta final exitosa del reagendamiento\n */\n\nconst ctx = $items('Prepare RPC Call')[0]?.json || {};\nconst dbResult = $input.first()?.json || {};\n\nconst { \n  oldAppointment, \n  newAppointment, \n  newCalendarEventId, \n  newCalendarLink,\n  telefono,\n  reason,\n  _audit,\n  _flags\n} = ctx;\n\n// ========================================================================\n// CONSTANTES\n// ========================================================================\n\nconst CONFIG = {\n  TIMEZONE: 'America/Mexico_City',\n  VERSION: '5.0',\n  \n  // Direcciones de las sedes\n  SEDE_ADDRESSES: {\n    POLANCO: 'Av. Homero 1425, Polanco IV Secci√≥n, Miguel Hidalgo, 11550 CDMX',\n    SATELITE: 'Circuito Centro Comercial 2251, Cd. Sat√©lite, 53100 Naucalpan de Ju√°rez, M√©x.'\n  },\n  \n  // Nombres de display\n  SEDE_DISPLAY: {\n    POLANCO: 'Polanco',\n    SATELITE: 'Sat√©lite'\n  },\n  \n  // Informaci√≥n del doctor\n  DOCTOR: {\n    nombre: 'Dr. [Nombre]',\n    especialidad: 'Urolog√≠a'\n  }\n};\n\n// ========================================================================\n// FUNCIONES AUXILIARES\n// ========================================================================\n\n/**\n * Formatea fecha en espa√±ol largo\n */\nfunction formatDateLong(isoString) {\n  if (!isoString) return 'N/A';\n  \n  const date = new Date(isoString);\n  return date.toLocaleDateString('es-MX', {\n    timeZone: CONFIG.TIMEZONE,\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  });\n}\n\n/**\n * Formatea fecha corta (DD/MM/YYYY)\n */\nfunction formatDateShort(isoString) {\n  if (!isoString) return 'N/A';\n  \n  const date = new Date(isoString);\n  return date.toLocaleDateString('es-MX', {\n    timeZone: CONFIG.TIMEZONE,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit'\n  });\n}\n\n/**\n * Formatea hora (HH:MM)\n */\nfunction formatTime(isoString) {\n  if (!isoString) return 'N/A';\n  \n  const date = new Date(isoString);\n  return date.toLocaleTimeString('es-MX', {\n    timeZone: CONFIG.TIMEZONE,\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false\n  });\n}\n\n/**\n * Formatea hora en 12h (h:mm AM/PM)\n */\nfunction formatTime12h(isoString) {\n  if (!isoString) return 'N/A';\n  \n  const date = new Date(isoString);\n  return date.toLocaleTimeString('es-MX', {\n    timeZone: CONFIG.TIMEZONE,\n    hour: 'numeric',\n    minute: '2-digit',\n    hour12: true\n  });\n}\n\n/**\n * Obtiene direcci√≥n de la sede\n */\nfunction getSedeAddress(sede) {\n  return CONFIG.SEDE_ADDRESSES[sede] || 'Direcci√≥n no disponible';\n}\n\n/**\n * Obtiene nombre de display de la sede\n */\nfunction getSedeDisplay(sede) {\n  return CONFIG.SEDE_DISPLAY[sede] || sede;\n}\n\n// ========================================================================\n// VALIDACI√ìN DEL RESULTADO RPC\n// ========================================================================\n\nconst metadata = {\n  responseStarted: new Date().toISOString(),\n  version: CONFIG.VERSION\n};\n\n// Validar estructura del resultado\nif (!dbResult || typeof dbResult !== 'object') {\n  console.error('‚ùå Invalid DB result structure:', typeof dbResult);\n  \n  return [{\n    json: {\n      status: 'DATABASE_ERROR',\n      message: 'Estructura de respuesta de base de datos inv√°lida',\n      receivedType: typeof dbResult,\n      _abort: true\n    }\n  }];\n}\n\n// Extraer resultado RPC\nconst rpcResult = dbResult.reagendar_consulta || dbResult;\n\n// Validar √©xito del RPC\nif (!rpcResult) {\n  console.error('‚ùå Missing RPC result:', JSON.stringify(dbResult, null, 2));\n  \n  return [{\n    json: {\n      status: 'DATABASE_ERROR',\n      message: 'Resultado de funci√≥n RPC no encontrado',\n      dbResult,\n      _abort: true\n    }\n  }];\n}\n\nif (!rpcResult.success) {\n  console.error('‚ùå DB update failed:', JSON.stringify(rpcResult, null, 2));\n  \n  return [{\n    json: {\n      status: 'DATABASE_ERROR',\n      message: rpcResult.message || 'Error al actualizar la consulta en base de datos',\n      error: rpcResult.error,\n      errorDetails: rpcResult.details,\n      _abort: true\n    }\n  }];\n}\n\nconsole.log('‚úÖ RPC executed successfully');\n\n// ========================================================================\n// VALIDAR DATOS COMPLETOS\n// ========================================================================\n\nconst warnings = [];\n\nif (!oldAppointment) {\n  warnings.push('oldAppointment faltante');\n}\n\nif (!newAppointment) {\n  warnings.push('newAppointment faltante');\n}\n\nif (!telefono) {\n  warnings.push('telefono faltante');\n}\n\nif (warnings.length > 0) {\n  console.warn('‚ö†Ô∏è Advertencias en datos:', warnings);\n}\n\n// ========================================================================\n// CONSTRUIR RESPUESTA COMPLETA\n// ========================================================================\n\n// Usar campo correcto del UUID\nconst consultaUuid = oldAppointment?.uuid || oldAppointment?.consulta_uuid;\n\n// Datos de la cita antigua (formateados consistentemente)\nconst oldAppointmentData = {\n  fecha: formatDateShort(oldAppointment?.fechaHoraUtc),\n  fechaLarga: formatDateLong(oldAppointment?.fechaHoraUtc),\n  hora: formatTime(oldAppointment?.fechaHoraUtc),\n  hora12h: formatTime12h(oldAppointment?.fechaHoraUtc),\n  sede: oldAppointment?.sede,\n  sedeDisplay: getSedeDisplay(oldAppointment?.sede),\n  direccion: getSedeAddress(oldAppointment?.sede),\n  fechaHoraUtc: oldAppointment?.fechaHoraUtc\n};\n\n// Datos de la cita nueva (formateados consistentemente)\nconst newAppointmentData = {\n  fecha: formatDateShort(newAppointment?.startISO),\n  fechaLarga: formatDateLong(newAppointment?.startISO),\n  hora: formatTime(newAppointment?.startISO),\n  hora12h: formatTime12h(newAppointment?.startISO),\n  sede: newAppointment?.sede,\n  sedeDisplay: getSedeDisplay(newAppointment?.sede),\n  direccion: getSedeAddress(newAppointment?.sede),\n  fechaHoraUtc: newAppointment?.startISO,\n  \n  // Informaci√≥n del calendario\n  calendarEventId: newCalendarEventId,\n  calendarLink: newCalendarLink,\n  hasCalendarEvent: !!(newCalendarEventId && newCalendarEventId.trim())\n};\n\n// Datos del paciente\nconst patientData = {\n  nombre: oldAppointment?.pacienteNombre || 'N/A',\n  telefono: telefono,\n  telefonoWhatsApp: `52${telefono}@s.whatsapp.net`\n};\n\n// Informaci√≥n del cambio\nconst changeInfo = {\n  sedeChanged: _flags?.sedeChanged || false,\n  calendarEventCreated: _flags?.calendarEventCreated || false,\n  hasOldCalendarEvent: _flags?.hasOldCalendarEvent || false,\n  motivo: reason || 'Reagendamiento solicitado por paciente',\n  reagendadoAt: new Date().toISOString()\n};\n\n// ========================================================================\n// MENSAJE PARA WHATSAPP\n// ========================================================================\n\nconst whatsappMessage = `\n‚úÖ *Cita Reagendada Exitosamente*\n\nHola *${patientData.nombre}*,\n\nTu cita ha sido reagendada:\n\nüìÖ *Cita Anterior:*\n- Fecha: ${oldAppointmentData.fechaLarga}\n- Hora: ${oldAppointmentData.hora12h}\n- Sede: ${oldAppointmentData.sedeDisplay}\n\nüìÖ *Nueva Cita:*\n- Fecha: ${newAppointmentData.fechaLarga}\n- Hora: ${newAppointmentData.hora12h}\n- Sede: ${newAppointmentData.sedeDisplay}\n\nüìç *Direcci√≥n:*\n${newAppointmentData.direccion}\n\n${newAppointmentData.hasCalendarEvent ? `üìÜ *Evento en tu calendario:*\\n${newAppointmentData.calendarLink}\\n` : ''}\n${changeInfo.motivo ? `üìù *Motivo:* ${changeInfo.motivo}\\n` : ''}\n*Importante:* Por favor llega 10 minutos antes de tu cita.\n\nGracias por tu preferencia.\nCl√≠nicas del Coraz√≥n CDMX üíô\n`.trim();\n\n// ========================================================================\n// MENSAJE PARA UROBOT\n// ========================================================================\n\nconst urobotMessage = `‚úÖ Tu cita ha sido reagendada exitosamente.\n\nüìÖ Nueva fecha: ${newAppointmentData.fechaLarga}\n‚è∞ Hora: ${newAppointmentData.hora12h}\nüìç Sede: ${newAppointmentData.sedeDisplay}\nüè• Direcci√≥n: ${newAppointmentData.direccion}\n\n${newAppointmentData.hasCalendarEvent ? `üìÜ Link a tu calendario: ${newAppointmentData.calendarLink}` : ''}`;\n\n// ========================================================================\n// CONSTRUIR RESPUESTA FINAL\n// ========================================================================\n\nconst response = {\n  // Status principal\n  status: 'RESCHEDULED',\n  success: true,\n  message: 'Cita reagendada exitosamente',\n  \n  // Datos de las citas\n  oldAppointment: oldAppointmentData,\n  newAppointment: newAppointmentData,\n  \n  // Datos del paciente\n  patient: patientData,\n  \n  // Informaci√≥n del cambio\n  change: changeInfo,\n  \n  // Mensajes formateados\n  messages: {\n    whatsapp: whatsappMessage,\n    urobot: urobotMessage,\n    short: `Cita reagendada para ${newAppointmentData.fechaLarga} a las ${newAppointmentData.hora12h} en ${newAppointmentData.sedeDisplay}`\n  },\n  \n  // Metadata\n  metadata: {\n    consultaId: oldAppointment?.consultaId,\n    consultaUuid: consultaUuid,\n    pacienteUuid: oldAppointment?.pacienteUuid,\n    reagendadoAt: changeInfo.reagendadoAt,\n    timezone: CONFIG.TIMEZONE,\n    version: CONFIG.VERSION,\n    \n    // Info del RPC\n    rpcSuccess: rpcResult.success,\n    rpcMessage: rpcResult.message,\n    rpcData: rpcResult.data || null\n  },\n  \n  // Datos de auditor√≠a (para logs/historial)\n  _audit: {\n    ..._audit,\n    responseBuilt: metadata.responseStarted,\n    warnings: warnings.length > 0 ? warnings : null\n  },\n  \n  // Flags √∫tiles para siguientes nodos\n  _flags: {\n    ...(_flags || {}),\n    shouldNotifyWhatsApp: true,\n    hasCalendarLink: newAppointmentData.hasCalendarEvent\n  }\n};\n\n// ========================================================================\n// LOGGING\n// ========================================================================\n\nconsole.log('‚úÖ Respuesta de reagendamiento construida:', JSON.stringify({\n  status: 'RESCHEDULED',\n  patient: patientData.nombre,\n  telefono: patientData.telefono,\n  change: {\n    from: {\n      fecha: oldAppointmentData.fechaLarga,\n      hora: oldAppointmentData.hora12h,\n      sede: oldAppointmentData.sedeDisplay\n    },\n    to: {\n      fecha: newAppointmentData.fechaLarga,\n      hora: newAppointmentData.hora12h,\n      sede: newAppointmentData.sedeDisplay\n    },\n    sedeChanged: changeInfo.sedeChanged,\n    calendarCreated: changeInfo.calendarEventCreated\n  },\n  warnings: warnings.length > 0 ? warnings : null\n}, null, 2));\n\nreturn [{ json: response }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3280,
        224
      ],
      "id": "4087607a-e721-4611-870f-08a2c3ad51d4",
      "name": "Build Success Response"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "d6b0714e-ebb2-40eb-a797-928ef4a30e22",
              "leftValue": "={{ $json._hasCalendarEvent === true }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2160,
        224
      ],
      "id": "29755ad3-ac13-49dc-b298-022ebe6608c8",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "/**\n * ========================================================================\n * NODO DE DEBUGGING TEMPORAL\n * ========================================================================\n * Este nodo muestra TODA la informaci√≥n que llega antes de crear el\n * evento en Google Calendar.\n * \n * IMPORTANTE: Este es un nodo temporal solo para debugging.\n * Elim√≠nalo cuando todo funcione correctamente.\n * ========================================================================\n */\n\nconst input = $input.first()?.json || {};\n\nconsole.log('\\n');\nconsole.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\nconsole.log('üêõ DEBUG: DATOS ANTES DE CREAR EVENTO EN GOOGLE CALENDAR');\nconsole.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\nconsole.log('\\n');\n\n// ========================================================================\n// 1. ESTRUCTURA COMPLETA\n// ========================================================================\n\nconsole.log('üì¶ ESTRUCTURA COMPLETA DE DATOS:');\nconsole.log(JSON.stringify(input, null, 2));\nconsole.log('\\n');\n\n// ========================================================================\n// 2. CAMPOS CR√çTICOS PARA GOOGLE CALENDAR\n// ========================================================================\n\nconsole.log('üéØ CAMPOS CR√çTICOS (los que Google Calendar necesita):');\nconsole.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n\n// Calendar ID\nconst calendarId = input.newAppointment?.calendarId;\nconsole.log('üìÖ Calendar ID:');\nconsole.log('   Valor:', calendarId);\nconsole.log('   Tipo:', typeof calendarId);\nconsole.log('   ¬øEs undefined?', calendarId === undefined);\nconsole.log('   ¬øEs null?', calendarId === null);\nconsole.log('   ¬øEs string vac√≠o?', calendarId === '');\nconsole.log('');\n\n// Start ISO\nconst startISO = input.newAppointment?.startISO;\nconsole.log('‚è∞ Start ISO:');\nconsole.log('   Valor:', startISO);\nconsole.log('   Tipo:', typeof startISO);\nconsole.log('   ¬øEs undefined?', startISO === undefined);\nconsole.log('   ¬øEs null?', startISO === null);\nconsole.log('   ¬øEs v√°lido?', startISO && !isNaN(Date.parse(startISO)));\nconsole.log('');\n\n// End ISO\nconst endISO = input.newAppointment?.endISO;\nconsole.log('‚è∞ End ISO:');\nconsole.log('   Valor:', endISO);\nconsole.log('   Tipo:', typeof endISO);\nconsole.log('   ¬øEs undefined?', endISO === undefined);\nconsole.log('   ¬øEs null?', endISO === null);\nconsole.log('   ¬øEs v√°lido?', endISO && !isNaN(Date.parse(endISO)));\nconsole.log('');\n\n// Paciente Nombre (para Summary)\nconst pacienteNombre = input.oldAppointment?.pacienteNombre;\nconsole.log('üë§ Paciente Nombre:');\nconsole.log('   Valor:', pacienteNombre);\nconsole.log('   Tipo:', typeof pacienteNombre);\nconsole.log('   ¬øEs undefined?', pacienteNombre === undefined);\nconsole.log('   ¬øEs null?', pacienteNombre === null);\nconsole.log('');\n\n// Tel√©fono\nconst telefono = input.oldAppointment?.telefono || input.telefono;\nconsole.log('üìû Tel√©fono:');\nconsole.log('   Valor:', telefono);\nconsole.log('   Tipo:', typeof telefono);\nconsole.log('   ¬øEs undefined?', telefono === undefined);\nconsole.log('');\n\n// Sede\nconst newSede = input.newSede;\nconsole.log('üè• Nueva Sede:');\nconsole.log('   Valor:', newSede);\nconsole.log('   Tipo:', typeof newSede);\nconsole.log('   ¬øEs undefined?', newSede === undefined);\nconsole.log('');\n\n// ========================================================================\n// 3. VERIFICACI√ìN DE OBJETOS ANIDADOS\n// ========================================================================\n\nconsole.log('üìÇ VERIFICACI√ìN DE OBJETOS ANIDADOS:');\nconsole.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n\nconsole.log('¬øExiste input.newAppointment?', !!input.newAppointment);\nif (input.newAppointment) {\n  console.log('  Keys de newAppointment:', Object.keys(input.newAppointment));\n}\nconsole.log('');\n\nconsole.log('¬øExiste input.oldAppointment?', !!input.oldAppointment);\nif (input.oldAppointment) {\n  console.log('  Keys de oldAppointment:', Object.keys(input.oldAppointment));\n}\nconsole.log('');\n\n// ========================================================================\n// 4. CONSTRUCCI√ìN DEL SUMMARY (preview)\n// ========================================================================\n\nconsole.log('üìù PREVIEW DEL SUMMARY:');\nconsole.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n\nconst summaryPreview = `Reagendado ‚Äì ${pacienteNombre || 'UNDEFINED'} ‚Äì ${newSede || 'UNDEFINED'} ‚Äì ${telefono || 'UNDEFINED'}`;\nconsole.log('Summary que se generar√°:', summaryPreview);\nconsole.log('');\n\n// ========================================================================\n// 5. ERRORES DETECTADOS\n// ========================================================================\n\nconst errors = [];\n\nif (!calendarId) errors.push('‚ùå calendarId es undefined/null/vac√≠o');\nif (!startISO) errors.push('‚ùå startISO es undefined/null/vac√≠o');\nif (!endISO) errors.push('‚ùå endISO es undefined/null/vac√≠o');\nif (!pacienteNombre) errors.push('‚ö†Ô∏è  pacienteNombre es undefined (usar√° \"Paciente\" por defecto)');\nif (!telefono) errors.push('‚ö†Ô∏è  telefono es undefined');\nif (!newSede) errors.push('‚ö†Ô∏è  newSede es undefined');\n\nconsole.log('üö® ERRORES/WARNINGS DETECTADOS:');\nconsole.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\nif (errors.length === 0) {\n  console.log('‚úÖ No se detectaron errores cr√≠ticos');\n} else {\n  errors.forEach(error => console.log(error));\n}\nconsole.log('');\n\n// ========================================================================\n// 6. RECOMENDACIONES\n// ========================================================================\n\nconsole.log('üí° RECOMENDACIONES:');\nconsole.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n\nif (!calendarId) {\n  console.log('üîß Problema con calendarId:');\n  console.log('   1. Verifica que el nodo \"Parse New DateTime\" tenga CALENDAR_IDS definido');\n  console.log('   2. Verifica que la sede coincida exactamente (may√∫sculas)');\n  console.log('   3. Revisa que CALENDAR_IDS tenga la key correcta');\n  console.log('');\n}\n\nif (!startISO || !endISO) {\n  console.log('üîß Problema con timestamps:');\n  console.log('   1. Verifica el formato de fecha/hora en \"Parse New DateTime\"');\n  console.log('   2. Aseg√∫rate de usar toISOString()');\n  console.log('   3. Verifica que la conversi√≥n a Date funcione correctamente');\n  console.log('');\n}\n\nif (!pacienteNombre) {\n  console.log('üîß Problema con pacienteNombre:');\n  console.log('   1. Verifica el nodo \"Process Search Result\"');\n  console.log('   2. Revisa que extraiga \"paciente_nombre\" de la consulta');\n  console.log('   3. Verifica el JOIN con la tabla pacientes en la funci√≥n SQL');\n  console.log('');\n}\n\n// ========================================================================\n// 7. SIGUIENTE PASO\n// ========================================================================\n\nconsole.log('üéØ SIGUIENTE PASO:');\nconsole.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n\nif (errors.filter(e => e.startsWith('‚ùå')).length > 0) {\n  console.log('‚ùå HAY ERRORES CR√çTICOS - El nodo de Google Calendar fallar√°');\n  console.log('   Corrige los errores indicados arriba antes de continuar');\n  console.log('');\n  console.log('üõë ABORTANDO para evitar error en Google Calendar...');\n  console.log('   (Elimina este nodo cuando todo funcione correctamente)');\n  console.log('');\n  \n  return [{\n    json: {\n      status: 'DEBUG_ERROR',\n      errors: errors,\n      message: 'Se detectaron errores cr√≠ticos. Revisa los logs.',\n      input: input,\n      _abort: true,\n      _debug: true\n    }\n  }];\n}\n\nconsole.log('‚úÖ DATOS CORRECTOS - Continuando al nodo de Google Calendar...');\nconsole.log('');\nconsole.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');\nconsole.log('\\n');\n\n// Pasar los datos sin modificar\nreturn [{ json: input }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2384,
        320
      ],
      "id": "82aa8ffb-773a-4839-a03b-f371271da8e3",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * CARGAR_HORARIOS v2.0 - MEJORADO\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * \n * CAMBIOS v2.0:\n * ‚úÖ Compatibilidad con nueva estructura (sin params)\n * ‚úÖ Soporte para nuevos filtros (onlyMorning, onlyAfternoon, windowDays)\n * ‚úÖ Validaci√≥n mejorada de horarios\n * ‚úÖ Metadata extendida\n * ‚úÖ Helper functions para otros nodos\n * \n * Fuente √∫nica de verdad de horarios del Dr. Mario Mart√≠nez Thomas\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n */\n\nconst VERSION = '2.0.0';\nconst TZ = 'America/Mexico_City';\n\n// ==================== CONFIGURACI√ìN DE HORARIOS ====================\nconst SCHEDULE = {\n  tz: TZ,\n  version: VERSION,\n  \n  // Ancla para c√°lculo de semanas alternas (s√°bados)\n  anchor: { \n    date: '2025-01-06', \n    type: 'A',\n    description: 'Semana A de referencia para s√°bados alternos'\n  },\n  \n  // D√≠as de descanso\n  rest: { \n    0: 'Domingo - Cerrado' \n  },\n  \n  // Horarios por sede\n  // DOW: 0=Dom, 1=Lun, 2=Mar, 3=Mi√©, 4=Jue, 5=Vie, 6=S√°b\n  sedes: {\n    POLANCO: {\n      1: [['09:00', '13:00', 'Lunes Matutino']],\n      2: [['16:00', '20:00', 'Martes Vespertino']],\n      5: [['15:00', '19:00', 'Viernes Vespertino']],\n    },\n    SATELITE: {\n      3: [['09:00', '13:00', 'Mi√©rcoles Matutino']],\n      4: [\n        ['09:00', '13:00', 'Jueves Matutino'],\n        ['15:00', '20:00', 'Jueves Vespertino'],\n      ],\n      6: { \n        B: [['09:00', '13:00', 'S√°bado Matutino (alterno)']] \n      },\n    },\n  },\n  \n  // Metadata de sedes (incluye calendarId)\n  meta: {\n    POLANCO: {\n      name: 'Hospital √Ångeles Santa M√≥nica, Polanco',\n      fullName: 'Hospital √Ångeles Santa M√≥nica',\n      location: 'Tem√≠stocles 210, Polanco, CDMX',\n      aliases: ['polanco', 'angeles', 'temistocles', 'santa monica', 'POLANCO'],\n      calendarId: '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com',\n      workingDays: [1, 2, 5], // Lun, Mar, Vie\n      hasWeekends: false,\n    },\n    SATELITE: {\n      name: 'Hospital San √Ångel Inn Sat√©lite',\n      fullName: 'Hospital San √Ångel Inn Sat√©lite',\n      location: 'Cto. Centro Comercial 20, Cd. Sat√©lite, Naucalpan',\n      aliases: ['satelite', 'sat√©lite', 'san angel inn', 'naucalpan', 'SATELITE'],\n      calendarId: 'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com',\n      workingDays: [3, 4, 6], // Mi√©, Jue, S√°b (alterno)\n      hasWeekends: true,\n      notes: 'S√°bados alternos (semana B)',\n    },\n  },\n  \n  // (Opcional) duplicado en metadata por compatibilidad con otros nodos\n  metadata: {\n    POLANCO: {\n      name: 'Hospital √Ångeles Santa M√≥nica, Polanco',\n      location: 'Tem√≠stocles 210, Polanco, CDMX',\n      aliases: ['polanco', 'angeles', 'temistocles', 'santa monica', 'POLANCO'],\n      calendarId: '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com',\n    },\n    SATELITE: {\n      name: 'Hospital San √Ångel Inn Sat√©lite',\n      location: 'Cto. Centro Comercial 20, Cd. Sat√©lite, Naucalpan',\n      aliases: ['satelite', 'sat√©lite', 'san angel inn', 'naucalpan', 'SATELITE'],\n      calendarId: 'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com',\n      notes: 'S√°bados alternos (semana B)'\n    }\n  },\n  \n  // Configuraci√≥n global\n  config: {\n    consultationDuration: 30,           // minutos\n    slotAnchors: [0, 30],               // slots en :00 y :30\n    shortNoticeMinutes: 120,            // 2 horas m√≠nimo de aviso\n    confirmationBufferMinutes: 15,      // buffer de confirmaci√≥n\n    defaultWindowDays: 14,              // ventana default de b√∫squeda\n    maxWindowDays: 90,                  // m√°ximo de d√≠as a futuro\n    maxSlots: 50,                       // m√°ximo de slots por respuesta\n    businessDayStart: 8,                // 08:00\n    businessDayEnd: 20,                 // 20:00\n  },\n};\n\n// ==================== VALIDACI√ìN DE ESQUEMA ====================\nconst LOGS = [];\n\nfunction log(level, message, data = {}) {\n  LOGS.push({\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'CARGAR_HORARIOS',\n    version: VERSION,\n    message,\n    ...data\n  });\n}\n\n// Validar formato HH:MM\nconst isHHMM = (s) => {\n  if (typeof s !== 'string') return false;\n  const match = /^(\\d{2}):(\\d{2})$/.exec(s);\n  if (!match) return false;\n  const [, hh, mm] = match;\n  return parseInt(hh) >= 0 && parseInt(hh) <= 23 && parseInt(mm) >= 0 && parseInt(mm) <= 59;\n};\n\n// Validar turno [start, end, label]\nconst validateShift = (shift, sede, dow) => {\n  if (!Array.isArray(shift)) {\n    log('error', 'Shift no es array', { sede, dow, shift });\n    return false;\n  }\n  \n  const [start, end, label] = shift;\n  \n  if (!isHHMM(start)) {\n    log('error', 'Start time inv√°lido', { sede, dow, start });\n    return false;\n  }\n  \n  if (!isHHMM(end)) {\n    log('error', 'End time inv√°lido', { sede, dow, end });\n    return false;\n  }\n  \n  // Validar que start < end\n  const startMinutes = parseInt(start.split(':')[0]) * 60 + parseInt(start.split(':')[1]);\n  const endMinutes = parseInt(end.split(':')[0]) * 60 + parseInt(end.split(':')[1]);\n  \n  if (startMinutes >= endMinutes) {\n    log('error', 'Start time debe ser menor que end time', { sede, dow, start, end });\n    return false;\n  }\n  \n  if (!label || typeof label !== 'string') {\n    log('warn', 'Label faltante o inv√°lido', { sede, dow, label });\n  }\n  \n  return true;\n};\n\n// Validar configuraci√≥n completa\nlog('info', 'Iniciando validaci√≥n de SCHEDULE');\n\nlet totalShifts = 0;\nlet validShifts = 0;\nlet errors = [];\n\nfor (const [sede, days] of Object.entries(SCHEDULE.sedes)) {\n  for (const [dow, conf] of Object.entries(days)) {\n    if (Array.isArray(conf)) {\n      // Formato simple: array de turnos\n      for (const shift of conf) {\n        totalShifts++;\n        if (validateShift(shift, sede, dow)) {\n          validShifts++;\n        } else {\n          errors.push({ sede, dow, shift, error: 'Invalid shift format' });\n        }\n      }\n    } else if (conf && typeof conf === 'object') {\n      // Formato alterno: objeto con semanas A/B\n      for (const [weekType, arr] of Object.entries(conf)) {\n        if (!Array.isArray(arr)) {\n          errors.push({ sede, dow, weekType, error: 'Week type value must be array' });\n          continue;\n        }\n        for (const shift of arr) {\n          totalShifts++;\n          if (validateShift(shift, sede, dow)) {\n            validShifts++;\n          } else {\n            errors.push({ sede, dow, weekType, shift, error: 'Invalid shift format' });\n          }\n        }\n      }\n    } else {\n      errors.push({ sede, dow, error: 'Invalid configuration format' });\n    }\n  }\n}\n\nif (errors.length > 0) {\n  log('error', 'Errores de validaci√≥n encontrados', { errors, totalErrors: errors.length });\n  throw new Error(`SCHEDULE inv√°lido: ${errors.length} errores encontrados. Ver logs.`);\n}\n\nlog('info', 'Validaci√≥n completada exitosamente', { \n  totalShifts, \n  validShifts, \n  sedesCount: Object.keys(SCHEDULE.sedes).length \n});\n\n// ==================== HELPER FUNCTIONS ====================\n\n// Funci√≥n para obtener d√≠a de semana en timezone local\nfunction getDayOfWeekInTZ(dateISO, tz) {\n  const dtf = new Intl.DateTimeFormat('en-US', { \n    timeZone: tz, \n    weekday: 'short' \n  });\n  const dayName = dtf.format(new Date(dateISO));\n  const dayMap = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\n  return dayMap[dayName];\n}\n\n// Funci√≥n para verificar si una sede tiene horarios en un d√≠a espec√≠fico\nfunction sedeHasScheduleOnDay(sede, dow) {\n  const sedeSchedule = SCHEDULE.sedes[sede];\n  if (!sedeSchedule) return false;\n  return dow in sedeSchedule;\n}\n\n// Funci√≥n para obtener rango de horarios (ma√±ana vs tarde)\nfunction classifyTimeRange(timeHHMM) {\n  const hour = parseInt(timeHHMM.split(':')[0]);\n  if (hour < 14) return 'morning';\n  return 'afternoon';\n}\n\n// Funci√≥n para obtener turnos de una sede en un d√≠a\nfunction getShiftsForSedeAndDay(sede, dow, weekType = null) {\n  const sedeSchedule = SCHEDULE.sedes[sede];\n  if (!sedeSchedule || !(dow in sedeSchedule)) return [];\n  \n  const conf = sedeSchedule[dow];\n  \n  if (Array.isArray(conf)) {\n    return conf;\n  }\n  \n  if (conf && typeof conf === 'object' && weekType) {\n    return conf[weekType] || [];\n  }\n  \n  return [];\n}\n\n// ==================== HELPERS EXTENDIDOS ====================\nconst HELPERS = {\n  getDayOfWeekInTZ,\n  sedeHasScheduleOnDay,\n  classifyTimeRange,\n  getShiftsForSedeAndDay,\n  \n  // Obtener todas las sedes disponibles\n  getAllSedes: () => Object.keys(SCHEDULE.sedes),\n  \n  // Verificar si una sede existe\n  sedeExists: (sede) => sede in SCHEDULE.sedes,\n  \n  // Normalizar nombre de sede (aliases)\n  normalizeSede: (input) => {\n    if (!input) return null;\n    const lower = input.toLowerCase().trim();\n    for (const [sede, meta] of Object.entries(SCHEDULE.meta)) {\n      if (meta.aliases.some(alias => alias.toLowerCase() === lower)) {\n        return sede;\n      }\n    }\n    return null;\n  },\n  \n  // Obtener d√≠as laborables de una sede\n  getWorkingDays: (sede) => {\n    return SCHEDULE.meta[sede]?.workingDays || [];\n  },\n  \n  // Verificar si una fecha es d√≠a laboral para una sede\n  isWorkingDay: (sede, dow) => {\n    const workingDays = HELPERS.getWorkingDays(sede);\n    return workingDays.includes(dow);\n  },\n};\n\n// ==================== PERSISTIR EN WORKFLOW STATIC DATA ====================\nlog('info', 'Guardando en Workflow Static Data');\n\nconst store = (typeof $getWorkflowStaticData === 'function')\n  ? $getWorkflowStaticData('global')\n  : this.getWorkflowStaticData('global');\n\nstore.SCHEDULE = SCHEDULE;\nstore.SCHEDULE_HELPERS = HELPERS;\nstore.SCHEDULE_VERSION = VERSION;\nstore.SCHEDULE_UPDATED_AT = new Date().toISOString();\n\nlog('info', 'SCHEDULE guardado exitosamente', { version: VERSION });\n\n// ==================== GENERAR RESUMEN ====================\nconst resume = {};\n\nfor (const [sede, days] of Object.entries(SCHEDULE.sedes)) {\n  resume[sede] = {};\n  for (const [dow, conf] of Object.entries(days)) {\n    if (Array.isArray(conf)) {\n      resume[sede][dow] = conf.map(s => `${s[0]}-${s[1]} (${s[2]})`);\n    } else if (conf && typeof conf === 'object') {\n      resume[sede][dow] = {};\n      for (const [wt, arr] of Object.entries(conf)) {\n        resume[sede][dow][wt] = arr.map(s => `${s[0]}-${s[1]} (${s[2]})`);\n      }\n    }\n  }\n}\n\n// Estad√≠sticas\nconst stats = {\n  totalSedes: Object.keys(SCHEDULE.sedes).length,\n  totalShifts,\n  validShifts,\n  sedesWithWeekends: Object.values(SCHEDULE.meta).filter(m => m.hasWeekends).length,\n};\n\n// ==================== OUTPUT ====================\nreturn [{\n  json: {\n    kind: 'config',\n    component: 'CARGAR_HORARIOS',\n    version: VERSION,\n    updatedAt: store.SCHEDULE_UPDATED_AT,\n    tz: TZ,\n    anchor: SCHEDULE.anchor,\n    config: SCHEDULE.config,\n    stats,\n    resume,\n    sedes: Object.keys(SCHEDULE.sedes),\n    logs: LOGS,\n    message: `‚úÖ SCHEDULE v${VERSION} cargado exitosamente en Workflow Static Data (global)`,\n    success: true,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -528,
        -160
      ],
      "id": "ed1886a5-919e-4e40-b8e0-02c757f365b8",
      "name": "CARGAR_HORARIOS"
    }
  ],
  "pinData": {
    "When executed by another workflow": [
      {
        "json": {
          "telefono": "6673184624",
          "consultaId": "",
          "newDate": "2025-11-07",
          "newTime": "15:00",
          "newSede": "POLANCO",
          "reason": "Reagendamiento solicitado por paciente"
        }
      }
    ]
  },
  "connections": {
    "When executed by another workflow": {
      "main": [
        [
          {
            "node": "CARGAR_HORARIOS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Valid?": {
      "main": [
        [
          {
            "node": "Return Validation Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Buscar Consulta (PostgreSQL)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar Consulta (PostgreSQL)": {
      "main": [
        [
          {
            "node": "Process Search Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Search Result": {
      "main": [
        [
          {
            "node": "Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Found?": {
      "main": [
        [
          {
            "node": "Return Not Found",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse New DateTime",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse New DateTime": {
      "main": [
        [
          {
            "node": "Validate Doctor Schedule",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Doctor Schedule": {
      "main": [
        [
          {
            "node": "Schedule Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Valid?": {
      "main": [
        [
          {
            "node": "Return Invalid Schedule",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Call 'DISPONIBILIDAD_CALENDARIO'",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call 'DISPONIBILIDAD_CALENDARIO'": {
      "main": [
        [
          {
            "node": "Check if Available",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if Available": {
      "main": [
        [
          {
            "node": "Available?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Available?": {
      "main": [
        [
          {
            "node": "Return Unavailable",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Calendar Event": {
      "main": [
        [
          {
            "node": "Create New Calendar Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create New Calendar Event": {
      "main": [
        [
          {
            "node": "Prepare RPC Call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare RPC Call": {
      "main": [
        [
          {
            "node": "Reagendar (PostgreSQL)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reagendar (PostgreSQL)": {
      "main": [
        [
          {
            "node": "Build Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Delete Old Calendar Event",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "Create New Calendar Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CARGAR_HORARIOS": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/Mexico_City",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "adJvsIQtBnYwjl9M"
  },
  "versionId": "55ac5c8f-b57c-488e-8570-24aadcfcfc7b",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "ab2739af75c0bf0ee034fd37e78576df139d0a4fcd48adc710d9ceec11fc12c5"
  },
  "id": "PVMah1xv97jaXawm",
  "tags": []
}