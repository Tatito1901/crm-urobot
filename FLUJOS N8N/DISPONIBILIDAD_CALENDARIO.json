{
  "name": "DISPONIBILIDAD_CALENDARIO",
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"desiredStart\": \"{{ $now.setZone('America/Mexico_City').toISO() }}\",\n  \"userText\": \"\",\n  \"sedePreferida\": \"\",\n  \"timezone\": \"America/Mexico_City\",\n  \"windowDays\": 14,\n  \"maxResults\": 50,\n  \"includeWeekends\": true,\n  \"onlyMorning\": false,\n  \"onlyAfternoon\": false,\n  \"requestId\": \"{{ $now.toMillis() }}-{{ Math.random().toString(36).substr(2, 9) }}\",\n  \"source\": \"urobot_whatsapp\"\n}\n"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1616,
        176
      ],
      "id": "c2799c91-4c27-4fd6-8bef-8bb038b22af0",
      "name": "When Executed by Another Workflow",
      "retryOnFail": true
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * BUILD_RESPONSE v21.0.0 â€” LLM NATIVE + ANTI-HALLUCINATION\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * MEJORAS:\n * 1. Mantiene estructura JSON limpia que te gusta\n * 2. Agrega campo `allowedTimes` con lista PLANA de horarios vÃ¡lidos\n * 3. Agrega `suggestedResponse` pre-armada para el LLM\n * 4. Agrega `rules` que el LLM debe seguir\n */\n\nconst VERSION = '21.0.0';\nconst DEBUG = true;\n\n/* ===================== 1. CONFIGURACIÃ“N ===================== */\n\nconst CONFIG = {\n  MAX_SLOTS_PER_DAY: 20,\n  MAX_BACKUP_DAYS: 3\n};\n\n/* ===================== 2. UTILIDADES DE FORMATO ===================== */\n\nfunction formatTime12(hm24) {\n  if (!hm24) return '';\n  const [H, M] = hm24.split(':').map(Number);\n  const h12 = H % 12 || 12;\n  const ampm = H < 12 ? 'AM' : 'PM';\n  return `${h12}:${String(M).padStart(2, '0')} ${ampm}`;\n}\n\nfunction getFriendlyDate(isoDate, tz) {\n  try {\n    const d = new Date(isoDate);\n    const dayName = new Intl.DateTimeFormat('es-MX', { weekday: 'long', timeZone: tz }).format(d);\n    const dayNum = new Intl.DateTimeFormat('es-MX', { day: 'numeric', month: 'short', timeZone: tz }).format(d);\n    return { dayName, dayNum, full: `${dayName} ${dayNum}` };\n  } catch (e) {\n    return { dayName: 'DÃ­a', dayNum: '', full: isoDate };\n  }\n}\n\nfunction getSedeReadable(sedeKey) {\n  const map = {\n    'POLANCO': 'Polanco',\n    'SATELITE': 'SatÃ©lite'\n  };\n  return map[sedeKey] || sedeKey;\n}\n\nfunction generateSmartSummary(slots, dayLabel, sedeName) {\n  if (!slots.length) return \"No hay disponibilidad.\";\n\n  const morningCount = slots.filter(s => parseInt(s.startHM.split(':')[0]) < 12).length;\n  const afternoonCount = slots.filter(s => parseInt(s.startHM.split(':')[0]) >= 12).length;\n\n  let availabilityDesc = \"\";\n  if (morningCount > 0 && afternoonCount > 0) availabilityDesc = \"en la maÃ±ana y tarde\";\n  else if (morningCount > 0) availabilityDesc = \"solo por la maÃ±ana\";\n  else if (afternoonCount > 0) availabilityDesc = \"solo por la tarde\";\n\n  return `EncontrÃ© disponibilidad para el ${dayLabel} en ${sedeName}. Hay ${slots.length} opciones ${availabilityDesc}.`;\n}\n\n// Genera respuesta sugerida que el LLM puede usar/adaptar\nfunction buildSuggestedResponse(slots, dayLabel, sedeName) {\n  const morning = slots.filter(s => parseInt(s.startHM.split(':')[0]) < 12);\n  const afternoon = slots.filter(s => parseInt(s.startHM.split(':')[0]) >= 12);\n  \n  let response = `Tengo disponibilidad para el ${dayLabel} en ${sedeName} ğŸ™‚\\n\\n`;\n  \n  if (morning.length > 0) {\n    const times = morning.slice(0, 4).map(s => formatTime12(s.startHM)).join(', ');\n    response += `Por la maÃ±ana: ${times}`;\n    if (morning.length > 4) response += ` (y ${morning.length - 4} mÃ¡s)`;\n    response += '\\n';\n  }\n  \n  if (afternoon.length > 0) {\n    const times = afternoon.slice(0, 4).map(s => formatTime12(s.startHM)).join(', ');\n    response += `Por la tarde: ${times}`;\n    if (afternoon.length > 4) response += ` (y ${afternoon.length - 4} mÃ¡s)`;\n    response += '\\n';\n  }\n  \n  response += '\\nÂ¿CuÃ¡l horario te funciona mejor?';\n  \n  return response;\n}\n\n/* ===================== 3. LÃ“GICA PRINCIPAL ===================== */\n\ntry {\n  const tStart = Date.now();\n  \n  const items = $input.all();\n  const jsonData = items[0]?.json || {};\n  \n  if (jsonData.kind !== 'avail') {\n    throw new Error(\"El input debe venir del nodo CALC_AVAILABILITY (kind='avail')\");\n  }\n\n  const rawSlots = jsonData.allowedSlots || [];\n  const TZ = jsonData.tz || 'America/Mexico_City';\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // CASO: SIN DISPONIBILIDAD\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  if (rawSlots.length === 0) {\n    return [{\n      json: {\n        kind: 'llm_response',\n        version: VERSION,\n        status: 'no_availability',\n        \n        executiveSummary: \"No hay horarios disponibles en el rango consultado.\",\n        humanMessage: \"No encontrÃ© horarios disponibles para esa fecha.\",\n        \n        // ğŸ”’ ANTI-ALUCINACIÃ“N\n        allowedTimes: [],\n        rules: [\n          \"NO inventes horarios\",\n          \"Informa que no hay disponibilidad\",\n          \"Ofrece buscar en otras fechas o la otra sede\"\n        ],\n        suggestedResponse: \"No encontrÃ© horarios disponibles para esa fecha ğŸ˜• Â¿Te gustarÃ­a que busque en otros dÃ­as o en la otra sede?\",\n        \n        context: { total_options: 0 }\n      }\n    }];\n  }\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // AGRUPAR POR DÃA\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  const daysMap = {};\n  \n  for (const slot of rawSlots) {\n    const dateKey = slot.start.split('T')[0];\n    \n    if (!daysMap[dateKey]) {\n      const dateInfo = getFriendlyDate(slot.start, TZ);\n      daysMap[dateKey] = {\n        key: dateKey,\n        label: dateInfo.dayName,\n        display: dateInfo.dayNum,\n        fullDate: dateInfo.full,\n        sede: slot.sede,\n        slots: []\n      };\n    }\n    daysMap[dateKey].slots.push(slot);\n  }\n\n  const allDays = Object.values(daysMap).sort((a, b) => a.key.localeCompare(b.key));\n  const primaryDay = allDays[0];\n  const backupDays = allDays.slice(1, CONFIG.MAX_BACKUP_DAYS + 1);\n  \n  const primarySlots = primaryDay.slots.slice(0, CONFIG.MAX_SLOTS_PER_DAY);\n  \n  const formatOptions = (slotList) => slotList.map(s => ({\n    time24: s.startHM,\n    time12: formatTime12(s.startHM),\n    sede: s.sede\n  }));\n\n  const sedeReadable = getSedeReadable(primarySlots[0]?.sede);\n  const summaryText = generateSmartSummary(primarySlots, primaryDay.fullDate, sedeReadable);\n  \n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // ğŸ”’ CAMPOS ANTI-ALUCINACIÃ“N\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  \n  // Lista PLANA de horarios permitidos (fÃ¡cil de validar)\n  const allowedTimes = primarySlots.map(s => formatTime12(s.startHM));\n  \n  // Respuesta pre-armada\n  const suggestedResponse = buildSuggestedResponse(primarySlots, primaryDay.fullDate, sedeReadable);\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // CONSTRUIR RESPUESTA FINAL\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  \n  const finalResponse = {\n    kind: 'llm_response',\n    version: VERSION,\n    status: 'success',\n    \n    executiveSummary: summaryText,\n    humanMessage: summaryText,\n\n    // ğŸ”’ ANTI-ALUCINACIÃ“N: Lista plana de horarios vÃ¡lidos\n    allowedTimes: allowedTimes,\n    \n    // ğŸ”’ ANTI-ALUCINACIÃ“N: Reglas que el LLM debe seguir\n    rules: [\n      \"SOLO menciona horarios de la lista allowedTimes\",\n      \"NO inventes horarios adicionales\",\n      \"Si piden un horario que no estÃ¡, di que no estÃ¡ disponible\",\n      \"Puedes usar suggestedResponse como base\"\n    ],\n    \n    // ğŸ”’ ANTI-ALUCINACIÃ“N: Respuesta pre-armada\n    suggestedResponse: suggestedResponse,\n\n    // Datos estructurados (tu estructura original)\n    llmContext: {\n      summary: summaryText,\n      \n      primaryOption: {\n        date: primaryDay.fullDate,\n        dateKey: primaryDay.key,\n        sede: sedeReadable,\n        sedeKey: primarySlots[0]?.sede,\n        total_slots: primarySlots.length,\n        slots: formatOptions(primarySlots)\n      },\n\n      alternativeDays: backupDays.map(d => ({\n        date: d.fullDate,\n        dateKey: d.key,\n        sede: getSedeReadable(d.sede),\n        total_slots: d.slots.length,\n        preview_slots: formatOptions(d.slots.slice(0, 5))\n      }))\n    },\n\n    meta: {\n      query: jsonData.query,\n      executionTime: Date.now() - tStart,\n      totalSlotsFound: rawSlots.length,\n      timezone: TZ\n    }\n  };\n\n  if (DEBUG) console.log(\"âœ… Build Response Success:\", summaryText);\n\n  return [{ json: finalResponse, pairedItem: { item: 0 } }];\n\n} catch (err) {\n  return [{\n    json: {\n      kind: 'llm_response',\n      version: VERSION,\n      status: 'error',\n      error: err.message,\n      executiveSummary: \"OcurriÃ³ un error tÃ©cnico al procesar los horarios.\",\n      \n      // ğŸ”’ ANTI-ALUCINACIÃ“N incluso en errores\n      allowedTimes: [],\n      rules: [\"NO inventes horarios\", \"Informa del error tÃ©cnico\"],\n      suggestedResponse: \"Tuve un problema al consultar los horarios. Â¿PodrÃ­as intentarlo de nuevo?\"\n    }\n  }];\n}"
      },
      "id": "e7f44ed3-e1c6-4973-9adf-695f6a67c185",
      "name": "Build Response1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        176
      ]
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "c_d699350899d8518308a1887dd162323d055657efd88be2a13a76ba7c44af16dd@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "HOSPITAL ANGELES POLANCO"
        },
        "timeMin": "={{$('SET_DEFAULTS').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "fdf87251-eeab-4f0a-8d40-4701f44416e4",
      "name": "Availability - POLANCO1",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -496,
        80
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "retryOnFail": false,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "Hm8ggB0P1TTFp0A0",
          "name": "GOOGLE UROBOT"
        }
      },
      "notes": "Fallback: Continue On Fail activo. Si falla, Normalize generarÃ¡ sourceStatus=error."
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "c_a78a512ef554a6b130c5475ac2f3ad8dc335b2c57b37004ac4ca3764f29ffd3f@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "SAN ANGEL INN SATELITE"
        },
        "timeMin": "={{$('SET_DEFAULTS').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "be0a82b0-1bd9-4e51-b848-2513c26f112a",
      "name": "Availability - SATELITE1",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -496,
        272
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "Hm8ggB0P1TTFp0A0",
          "name": "GOOGLE UROBOT"
        }
      },
      "notes": "Fallback: Continue On Fail activo."
    },
    {
      "parameters": {},
      "id": "89d6106b-3e48-4687-9bb2-647b48ae697e",
      "name": "Merge Busy (append)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -48,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * COMBINE_BUSY v5.1.0 â€” FIXED (Filtro de OcupaciÃ³n Activado)\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * CORRECCIÃ“N CRÃTICA:\n * - Se agregÃ³ la funciÃ³n filterBusySlots.\n * - Ahora el cÃ³digo cruza los \"Allowed Slots\" contra los \"Busy Slots\" y \n * elimina cualquier coincidencia antes de entregar el resultado.\n */\n\nconst VERSION = '5.1.0-FIXED';\nconst DEBUG = false;\n\n/* ===================== CONFIG ===================== */\n\nconst LIMITS = Object.freeze({\n  MAX_SLOTS_PER_DAY: 20,\n  MAX_BACKUP_DAYS: 5,\n  MAX_TOTAL_SLOTS: 100,\n  MIN_SLOT_DURATION: 15,\n  MAX_SLOT_DURATION: 120,\n  MAX_OPTIONS_PER_DAY: 6\n});\n\n/* ===================== LOGGING ===================== */\n\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = { timestamp: new Date().toISOString(), level: level.toUpperCase(), component: 'COMBINE_BUSY', version: VERSION, message, ...data };\n  LOGS.push(entry);\n  if (DEBUG) console.log(`[${level.toUpperCase()}] ${message}`, data);\n}\n\n/* ===================== TIMEZONE & HELPERS ===================== */\n\nconst _formattersCache = new Map();\nfunction getCachedFormatter(options, tz) {\n  const key = JSON.stringify({ ...options, tz });\n  let formatter = _formattersCache.get(key);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat('es-MX', { timeZone: tz, ...options });\n    _formattersCache.set(key, formatter);\n  }\n  return formatter;\n}\n\nfunction formatLocal(iso, tz) {\n  const formatter = getCachedFormatter({ hour12: false, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }, tz);\n  return formatter.format(new Date(iso));\n}\n\nfunction cropToWindow(interval, startISO, endISO) {\n  const s = (startISO && interval.start < startISO) ? startISO : interval.start;\n  const e = (endISO && interval.end > endISO) ? endISO : interval.end;\n  return (s < e) ? { start: s, end: e } : null;\n}\n\nfunction mergeExclusive(list) {\n  if (!list || !list.length) return [];\n  const sorted = [...list].sort((a, b) => a.start.localeCompare(b.start));\n  const merged = [{ start: sorted[0].start, end: sorted[0].end }];\n  \n  for (let i = 1; i < sorted.length; i++) {\n    const last = merged[merged.length - 1];\n    const current = sorted[i];\n    // Si se tocan o solapan, extender el final\n    if (current.start < last.end) {\n      if (current.end > last.end) last.end = current.end;\n    } else {\n      merged.push({ start: current.start, end: current.end });\n    }\n  }\n  return merged;\n}\n\nfunction djb2Hash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) hash = ((hash << 5) + hash) + str.charCodeAt(i);\n  return 'H' + (hash >>> 0).toString(36);\n}\n\n/* ===================== LOGIC HELPERS ===================== */\n\nfunction loadContext() {\n  let ctx = {}, requestId = `combine-${Date.now()}`;\n  try {\n    const setDefaultsItems = $('SET_DEFAULTS').all();\n    if (setDefaultsItems.length > 0) {\n      ctx = setDefaultsItems[0].json || {};\n      if (ctx.requestId) requestId = ctx.requestId;\n    }\n  } catch (err) {}\n  return { ctx, requestId };\n}\n\nfunction loadSedes() {\n  try {\n    const store = $getWorkflowStaticData('global');\n    if (store?.SCHEDULE?.sedes) return Object.keys(store.SCHEDULE.sedes);\n  } catch(e) {}\n  return ['POLANCO', 'SATELITE']; // Fallback\n}\n\n/* ===================== ğŸ”¥ CORE FIX: FILTER BUSY ===================== */\n// Esta funciÃ³n es la que estaba faltando. Resta los ocupados de los disponibles.\nfunction filterBusySlots(slots, busyBySede) {\n  return slots.filter(slot => {\n    const busyList = busyBySede[slot.sede];\n    if (!busyList || !busyList.length) return true; // No hay bloqueos, pasa.\n\n    // Revisar colisiÃ³n contra todos los intervalos ocupados de esa sede\n    for (const busy of busyList) {\n      // LÃ³gica de solapamiento: (SlotStart < BusyEnd) y (SlotEnd > BusyStart)\n      if (slot.start < busy.end && slot.end > busy.start) {\n        return false; // âŒ CHOCA: Eliminar Slot\n      }\n    }\n    return true; // âœ… SOBREVIVE: No choca con nada\n  });\n}\n\n/* ===================== MAIN EXECUTION ===================== */\n\ntry {\n  const startTime = Date.now();\n  \n  // 1. Inputs y Contexto\n  const rawItems = $input.all().map(x => x.json);\n  const { ctx, requestId } = loadContext();\n  const SEDES = loadSedes();\n  const TZ = ctx.tz || 'America/Mexico_City';\n  const windowStartISO = ctx.windowStart || null;\n  const windowEndISO = ctx.windowEnd || null;\n\n  // 2. Extraer Busy Intervals (Soporta Force Mode y Standard)\n  const groups = Object.fromEntries(SEDES.map(s => [s, []]));\n  \n  for (const item of rawItems) {\n    if (item.kind !== 'busy') continue;\n    \n    // Caso A: Sede explÃ­cita (Force Mode)\n    if (item.sede && groups[item.sede]) {\n      (item.busy || []).forEach(slot => {\n        const clipped = cropToWindow(slot, windowStartISO, windowEndISO);\n        if (clipped) groups[item.sede].push(clipped);\n      });\n    }\n    // Caso B: BusyBySede (Standard)\n    else if (item.busyBySede) {\n      for (const [s, list] of Object.entries(item.busyBySede)) {\n        if (groups[s]) {\n          list.forEach(slot => {\n            const clipped = cropToWindow(slot, windowStartISO, windowEndISO);\n            if (clipped) groups[s].push(clipped);\n          });\n        }\n      }\n    }\n  }\n\n  // 3. Merge Busy (Limpiar solapamientos internos)\n  const busyBySede = Object.fromEntries(SEDES.map(s => [s, mergeExclusive(groups[s])]));\n  \n  // 4. Obtener Allowed Slots (desde Schedule Gate)\n  let allowedSlots = [];\n  try {\n    const gate = $('SCHEDULE_GATE1').first().json;\n    if (gate && gate.allowedSlots) allowedSlots = gate.allowedSlots;\n  } catch(e) {}\n\n  // 5. Filtrar Sedes VÃ¡lidas\n  const preFilterCount = allowedSlots.length;\n  allowedSlots = allowedSlots.filter(s => SEDES.includes(s.sede));\n\n  // 6. ğŸ”¥ APLICAR EL FILTRO DE OCUPACIÃ“N (EL FIX) ğŸ”¥\n  let finalSlots = filterBusySlots(allowedSlots, busyBySede);\n\n  // 7. Aplicar Max Results (Opcional, pero bueno para performance)\n  if (ctx.maxResults && ctx.maxResults > 0) {\n    finalSlots = finalSlots.slice(0, ctx.maxResults);\n  }\n\n  // 8. Generar Salida para Calc Availability\n  const busyBySedeLocal = Object.fromEntries(SEDES.map(s => [s, (busyBySede[s] || []).map(iv => ({ ...iv, startLocal: formatLocal(iv.start, TZ), endLocal: formatLocal(iv.end, TZ) }))]));\n  \n  const result = {\n    kind: 'busy_combined',\n    build: { version: VERSION, generatedAt: new Date().toISOString() },\n    requestId,\n    ctx,\n    \n    // AquÃ­ entregamos los slots YA FILTRADOS\n    scheduleGate: {\n      allowedSlots: finalSlots \n    },\n    \n    busyBySede,\n    busyBySedeLocal,\n    \n    metrics: {\n      totalInputSlots: preFilterCount,\n      totalBusyBlocks: Object.values(busyBySede).flat().length,\n      filteredByBusy: allowedSlots.length - finalSlots.length, // CuÃ¡ntos eliminÃ³ el calendario\n      finalOutput: finalSlots.length\n    },\n    \n    debugLocal: { tz: TZ, sedes: SEDES }\n  };\n  \n  log('SUCCESS', `Finalizado. Slots entregados: ${finalSlots.length}`);\n  \n  return [{\n    json: result,\n    pairedItem: $input.all().map((_, i) => ({ item: i }))\n  }];\n\n} catch (err) {\n  log('ERROR', err.message);\n  return [{ json: { kind: 'error', error: 'COMBINE_FAIL', message: err.message, stack: err.stack } }];\n}"
      },
      "id": "e6fa56b2-5bd8-408a-af8c-80bafe6aa130",
      "name": "Combine Busy1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * CALC_AVAILABILITY v10.0 â€” STRICT & CHRONOLOGICAL\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * CAMBIOS:\n * - Eliminado el sistema de \"puntos\" complejo. Prioridad = CronolÃ³gica.\n * - Limpieza total de validaciones de zona horaria (confÃ­a en inputs ISO).\n * - Estructura de salida garantizada para Build Response.\n */\n\nconst VERSION = '10.0.0-STRICT';\nconst DEFAULT_TZ = 'America/Mexico_City';\n\n// Helper para formato visual (solo display)\nfunction getLocalTime(iso, tz) {\n  try {\n    return new Intl.DateTimeFormat('es-MX', {\n      timeZone: tz, hour: '2-digit', minute: '2-digit', hour12: false\n    }).format(new Date(iso));\n  } catch (e) { return iso.split('T')[1].substring(0, 5); }\n}\n\ntry {\n  // 1. Obtener Input del nodo anterior (Combine Busy)\n  const items = $input.all();\n  const inputData = items[0]?.json || {};\n  \n  // Validar que venga del nodo correcto\n  if (inputData.kind !== 'busy_combined') {\n    // Si llegamos aquÃ­ sin datos, creamos una estructura vacÃ­a segura\n    throw new Error('Input invÃ¡lido: Se esperaba kind=\"busy_combined\"');\n  }\n\n  const ctx = inputData.ctx || {};\n  const TZ = ctx.tz || inputData.debugLocal?.tz || DEFAULT_TZ;\n  const requestId = inputData.requestId || ctx.requestId;\n\n  // 2. Extraer Slots DISPONIBLES (Ya filtrados por Combine Busy)\n  // AquÃ­ confiamos ciegamente en que Combine Busy ya hizo el trabajo sucio.\n  let cleanSlots = [];\n  if (inputData.scheduleGate && Array.isArray(inputData.scheduleGate.allowedSlots)) {\n    cleanSlots = inputData.scheduleGate.allowedSlots;\n  }\n\n  // 3. Ordenamiento Estricto (CronolÃ³gico)\n  // Lo mÃ¡s prÃ³ximo en el tiempo va primero. Sin excepciones.\n  cleanSlots.sort((a, b) => new Date(a.start) - new Date(b.start));\n\n  // 4. Enriquecer datos (Scoring simplificado para compatibilidad)\n  // Solo marcamos \"morning/afternoon\" por si el LLM lo pregunta.\n  const enrichedSlots = cleanSlots.map(slot => {\n    const localTime = getLocalTime(slot.start, TZ);\n    const hour = parseInt(localTime.split(':')[0]);\n    \n    return {\n      ...slot,\n      startHM: localTime, // HH:MM local\n      _score: 1, // Score plano, todos valen igual (el orden lo da el array)\n      shiftLabel: hour < 12 ? 'MaÃ±ana' : 'Tarde'\n    };\n  });\n\n  // 5. Aplicar LÃ­mite Final (Max Results)\n  // Aunque CombineBusy ya lo hace, aseguramos aquÃ­ para el output final.\n  const limit = ctx.maxResults || 50;\n  const finalSlots = enrichedSlots.slice(0, limit);\n\n  // 6. Generar Resumen\n  const summary = {\n    totalAvailable: enrichedSlots.length,\n    returned: finalSlots.length,\n    firstSlot: finalSlots.length > 0 ? finalSlots[0].start : null\n  };\n\n  // 7. Output Final\n  return [{\n    json: {\n      kind: 'avail', // ğŸ‘ˆ Etiqueta vital para el siguiente nodo\n      version: VERSION,\n      requestId,\n      tz: TZ,\n      \n      allowedSlots: finalSlots, // La lista de oro\n      summary,\n      \n      // Pasamos el query original para contexto\n      query: ctx.originalInput || {},\n      \n      timestamp: new Date().toISOString()\n    }\n  }];\n\n} catch (error) {\n  // Manejo de errores seguro (retorna vacÃ­o en lugar de romper)\n  return [{\n    json: {\n      kind: 'avail',\n      version: VERSION,\n      status: 'error',\n      error: error.message,\n      allowedSlots: [], // Lista vacÃ­a segura\n      summary: { totalAvailable: 0 },\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "id": "aa8ee999-c536-4e2f-a0ac-73db937b4a9e",
      "name": "Calc Availability1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n * SCHEDULE_GATE v15.3.0 - Gate de agenda con SCHEDULE centralizado y filtros\n * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n *\n * Mejoras vs 15.2.x:\n * - IteraciÃ³n de dÃ­as usa [windowStart, windowEnd) (sin off-by-one).\n * - slotDuration, anchors y shortNoticeMin vienen de CFG/context (no se re-lee SCHEDULE.config dentro).\n * - Respeta maxSlots desde SCHEDULE.config junto con ctx.maxResults.\n * - dow de cada slot es el DOW local (no UTC desfasado).\n * - Cachea formateador HH:MM por TZ (DTF_HM) para evitar recrearlo por slot.\n * - DEBUG desactivado por defecto; _logs sÃ³lo cuando DEBUG = true.\n */\n\nconst VERSION = '15.3.0';\nconst DEBUG = false;\n\n// ==================== LOGGING ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'SCHEDULE_GATE',\n    version: VERSION,\n    message,\n    ...data,\n  };\n  LOGS.push(entry);\n  if (DEBUG) {\n    const emoji = {\n      INFO: 'â„¹ï¸',\n      WARN: 'âš ï¸',\n      ERROR: 'âŒ',\n      DEBUG: 'ğŸ”',\n      SUCCESS: 'âœ…',\n    }[level.toUpperCase()] || 'ğŸ“';\n    console.log(`${emoji} [${level.toUpperCase()}] ${message}`, data);\n  }\n}\n\n// ==================== TIMEZONE / DATE HELPERS ====================\nlet _formattersCache = {};\nfunction getFormatters(tz) {\n  if (!_formattersCache[tz]) {\n    _formattersCache[tz] = {\n      tz,\n      DTF_FULL: new Intl.DateTimeFormat('en-CA', {\n        timeZone: tz,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false,\n      }),\n      DTF_DISPLAY: new Intl.DateTimeFormat('es-MX', {\n        timeZone: tz,\n        weekday: 'long',\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      }),\n      DTF_HM: new Intl.DateTimeFormat('en-US', {\n        timeZone: tz,\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      }),\n    };\n  }\n  return _formattersCache[tz];\n}\n\nfunction getLocalParts(date, DTF_FULL) {\n  const parts = DTF_FULL.formatToParts(date);\n  const obj = {};\n  for (const p of parts) obj[p.type] = p.value;\n  return {\n    y: +obj.year,\n    m: +obj.month,\n    d: +obj.day,\n    hh: +obj.hour,\n    mm: +obj.minute,\n    ss: +obj.second,\n  };\n}\n\nfunction localToUTC(y, m, d, hh = 0, mm = 0, ss = 0, DTF_FULL) {\n  const naive = Date.UTC(y, m - 1, d, hh, mm, ss);\n  const asLocal = getLocalParts(new Date(naive), DTF_FULL);\n  const localEpoch = Date.UTC(\n    asLocal.y,\n    asLocal.m - 1,\n    asLocal.d,\n    asLocal.hh,\n    asLocal.mm,\n    asLocal.ss,\n  );\n  return naive - (localEpoch - naive);\n}\n\nfunction timeAtDay(date, hhmm, DTF_FULL) {\n  const [hh, mm] = hhmm.split(':').map(Number);\n  const p = getLocalParts(date, DTF_FULL);\n  return new Date(localToUTC(p.y, p.m, p.d, hh, mm, 0, DTF_FULL)).toISOString();\n}\n\nfunction formatLocal(iso, DTF_DISPLAY) {\n  return DTF_DISPLAY.format(new Date(iso));\n}\n\nfunction hhmmToMinutes(hhmm) {\n  const [h, m] = hhmm.split(':').map(Number);\n  return h * 60 + m;\n}\n\nfunction minutesToHHMM(mins) {\n  const h = Math.floor(mins / 60);\n  const m = mins % 60;\n  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;\n}\n\n// HH:MM local reutilizando DTF_HM cacheado\nfunction formatHHMM(iso, DTF_HM) {\n  const parts = DTF_HM.formatToParts(new Date(iso));\n  const hh = parts.find((p) => p.type === 'hour')?.value || '00';\n  const mm = parts.find((p) => p.type === 'minute')?.value || '00';\n  return `${hh}:${mm}`;\n}\n\n// ==================== VALIDACIÃ“N & CONTEXT ====================\nfunction validateContextFromInput(item) {\n  if (!item?.json) {\n    return {\n      valid: false,\n      error: 'EMPTY_INPUT',\n      message: 'Entrada vacÃ­a en SCHEDULE_GATE',\n    };\n  }\n  const ctx = item.json;\n  if (ctx.kind === 'error') {\n    return { valid: false, propagateError: true, originalError: ctx };\n  }\n  if (ctx.kind !== 'context') {\n    return {\n      valid: false,\n      error: 'INVALID_INPUT_KIND',\n      message: `Esperado kind='context', recibiÃ³ '${ctx.kind || 'undefined'}'`,\n    };\n  }\n\n  const required = ['windowStart', 'windowEnd', 'tz'];\n  const missing = required.filter((f) => !ctx[f]);\n  if (missing.length) {\n    return {\n      valid: false,\n      error: 'MISSING_REQUIRED_FIELDS',\n      message: `Faltan campos: ${missing.join(', ')}`,\n    };\n  }\n\n  const startMs = new Date(ctx.windowStart).getTime();\n  const endMs = new Date(ctx.windowEnd).getTime();\n  if (isNaN(startMs) || isNaN(endMs) || startMs >= endMs) {\n    return {\n      valid: false,\n      error: 'INVALID_WINDOW',\n      message: 'windowStart/windowEnd invÃ¡lidos',\n    };\n  }\n\n  return { valid: true, ctx };\n}\n\n// ==================== FALLBACKS (si faltan HELPERS) ====================\nfunction computeWeekTypeFallback(dateKey, anchor) {\n  try {\n    const anchorDate = new Date(\n      anchor?.date ? `${anchor.date}T00:00:00Z` : '2025-01-06T00:00:00Z',\n    );\n    const d = new Date(`${dateKey}T00:00:00Z`);\n    const MS_PER_DAY = 86400000;\n    const days = Math.floor((d - anchorDate) / MS_PER_DAY);\n    const weeks = Math.floor(days / 7);\n    const anchorType = anchor?.type || 'A';\n    const isEven = weeks % 2 === 0; // pares = tipo anchor\n    return isEven ? anchorType : anchorType === 'A' ? 'B' : 'A';\n  } catch (e) {\n    log('WARN', 'computeWeekTypeFallback error', { dateKey, error: e.message });\n    return 'A';\n  }\n}\n\n// ==================== GENERACIÃ“N DE SLOTS ====================\nfunction generateSlots(ctx, SCHEDULE, HELPERS, CFG, DTF_FULL, DTF_DISPLAY, DTF_HM) {\n  log('INFO', 'Iniciando generaciÃ³n de slots', {\n    sedes: ctx.sedes,\n    sedePreferida: ctx.sedePreferida,\n  });\n\n  const windowStartMs = new Date(ctx.windowStart).getTime();\n  const windowEndMs = new Date(ctx.windowEnd).getTime();\n  const now = Date.now();\n\n  // shortNoticeMin: preferir constraints del contexto, luego CFG\n  const shortNoticeMin =\n    (ctx.constraints && ctx.constraints.shortNoticeMin) ?? CFG.SHORT_NOTICE_MIN;\n  const shortNoticeBuffer = now + shortNoticeMin * 60000;\n\n  const slotDurationMin =\n    (ctx.constraints && ctx.constraints.slotMinutes) ?? CFG.CONSULTATION_DURATION_MIN;\n  const slotDurationMs = slotDurationMin * 60000;\n  const anchors = CFG.ANCHORS;\n\n  // Determinar sedes a evaluar\n  let sedesToCheck =\n    Array.isArray(ctx.sedes) && ctx.sedes.length\n      ? ctx.sedes.slice()\n      : Object.keys(SCHEDULE.sedes || {});\n\n  if (ctx.sedePreferida) {\n    const normalized = HELPERS?.normalizeSede\n      ? HELPERS.normalizeSede(ctx.sedePreferida)\n      : ctx.sedePreferida;\n    if (normalized) sedesToCheck = [normalized];\n    log('INFO', 'Sede normalizada', {\n      original: ctx.sedePreferida,\n      normalized,\n    });\n  }\n\n  const includeWeekends = ctx.includeWeekends !== false; // default true\n  const onlyMorning = !!ctx.onlyMorning;\n  const onlyAfternoon = !!ctx.onlyAfternoon;\n  const tw = ctx.timeWindow || null; // {startMin, endMin}\n\n  const allowed = [];\n  const allowedSlots = [];\n  const skipped = {\n    weekends: 0,\n    restDay: 0,\n    noSchedule: 0,\n    wrongWeekType: 0,\n    morningFilter: 0,\n    afternoonFilter: 0,\n    timeWindow: 0,\n    shortNotice: 0,\n    outsideWindow: 0,\n    partialSlot: 0,\n    invalidGrid: 0,\n  };\n\n  const MS_PER_DAY = 86400000;\n  let totalSlotsGenerated = 0;\n\n  for (const sede of sedesToCheck) {\n    const sedeSchedule = (SCHEDULE.sedes || {})[sede];\n    if (!sedeSchedule) {\n      log('WARN', 'Sede no encontrada en SCHEDULE', { sede });\n      continue;\n    }\n\n    // Recorrer dÃ­as: [windowStart, windowEnd)\n    for (\n      let currentMs = windowStartMs;\n      currentMs < windowEndMs;\n      currentMs += MS_PER_DAY\n    ) {\n      const currentDate = new Date(currentMs);\n      const p = getLocalParts(currentDate, DTF_FULL);\n      const localDate = new Date(Date.UTC(p.y, p.m - 1, p.d));\n      const dowLocal = localDate.getUTCDay(); // 0..6\n      const dateKey = `${p.y}-${String(p.m).padStart(2, '0')}-${String(\n        p.d,\n      ).padStart(2, '0')}`;\n\n      // 1) Fines de semana\n      if (!includeWeekends && (dowLocal === 0 || dowLocal === 6)) {\n        skipped.weekends++;\n        continue;\n      }\n\n      // 2) DÃ­a de descanso general\n      if (SCHEDULE.rest && SCHEDULE.rest[dowLocal]) {\n        skipped.restDay++;\n        continue;\n      }\n\n      // 3) DÃ­a laborable por sede\n      if (HELPERS?.isWorkingDay && !HELPERS.isWorkingDay(sede, dowLocal)) {\n        skipped.noSchedule++;\n        continue;\n      }\n\n      // Week type\n      const weekType = HELPERS?.getWeekType\n        ? HELPERS.getWeekType(dateKey, SCHEDULE.anchor)\n        : computeWeekTypeFallback(dateKey, SCHEDULE.anchor);\n\n      // Turnos del dÃ­a\n      let shifts = HELPERS?.getShiftsForSedeAndDay\n        ? HELPERS.getShiftsForSedeAndDay(sede, dowLocal, weekType)\n        : null;\n      if (!shifts || !shifts.length) {\n        skipped.noSchedule++;\n        continue;\n      }\n\n      // Normalizar a objetos {start,end,label,weekType}\n      let normalizedShifts = shifts.map((s) =>\n        Array.isArray(s)\n          ? {\n              start: s[0],\n              end: s[1],\n              label: s[2] || `${s[0]}-${s[1]}`,\n              weekType,\n            }\n          : {\n              start: s.start,\n              end: s.end,\n              label: s.label || `${s.start}-${s.end}`,\n              weekType: s.weekType || weekType,\n            },\n      );\n\n      // 4) Filtro morning / afternoon\n      if (onlyMorning) {\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter(\n          (sh) => parseInt(sh.start.split(':')[0], 10) < 14,\n        );\n        skipped.morningFilter += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n      if (onlyAfternoon) {\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter(\n          (sh) => parseInt(sh.start.split(':')[0], 10) >= 14,\n        );\n        skipped.afternoonFilter += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n\n      // 5) Filtro por ventana horaria (overlap)\n      if (tw && (typeof tw.startMin === 'number' || typeof tw.endMin === 'number')) {\n        const reqStart = typeof tw.startMin === 'number' ? tw.startMin : 0;\n        const reqEnd = typeof tw.endMin === 'number' ? tw.endMin : 24 * 60;\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter((sh) => {\n          const sMin = hhmmToMinutes(sh.start);\n          const eMin = hhmmToMinutes(sh.end);\n          return sMin < reqEnd && eMin > reqStart; // overlap\n        });\n        skipped.timeWindow += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n\n      // 6) GeneraciÃ³n de slots\n      for (const sh of normalizedShifts) {\n        const shiftStartMs = new Date(timeAtDay(currentDate, sh.start, DTF_FULL)).getTime();\n        const shiftEndMs = new Date(timeAtDay(currentDate, sh.end, DTF_FULL)).getTime();\n\n        for (let cursor = shiftStartMs; cursor < shiftEndMs; cursor += slotDurationMs) {\n          const slotStartMs = cursor;\n          const slotEndMs = cursor + slotDurationMs;\n\n          if (slotEndMs > shiftEndMs) {\n            skipped.partialSlot++;\n            break;\n          }\n\n          // anclajes (:00/:30)\n          const mins = new Date(slotStartMs).getUTCMinutes();\n          if (!anchors.includes(mins)) {\n            skipped.invalidGrid++;\n            continue;\n          }\n\n          // short notice\n          if (slotStartMs < shortNoticeBuffer) {\n            skipped.shortNotice++;\n            continue;\n          }\n\n          // ventana global [windowStart, windowEnd)\n          if (slotStartMs < windowStartMs || slotStartMs >= windowEndMs) {\n            skipped.outsideWindow++;\n            continue;\n          }\n\n          const startIso = new Date(slotStartMs).toISOString();\n          const endIso = new Date(slotEndMs).toISOString();\n\n          allowed.push({ start: startIso, end: endIso });\n\n          allowedSlots.push({\n            sede,\n            start: startIso,\n            end: endIso,\n            durationMinutes: slotDurationMin,\n            label: sh.label,\n            weekType: sh.weekType || weekType || null,\n            startLocal: formatLocal(startIso, DTF_DISPLAY),\n            endLocal: formatLocal(endIso, DTF_DISPLAY),\n            startHM: formatHHMM(startIso, DTF_HM),\n            dayKey: dateKey,\n            dow: dowLocal, // DOW local (0..6)\n          });\n\n          totalSlotsGenerated++;\n        }\n      }\n    }\n  }\n\n  // Ordenar por fecha\n  allowed.sort((a, b) => new Date(a.start) - new Date(b.start));\n  allowedSlots.sort((a, b) => new Date(a.start) - new Date(b.start));\n\n  log('SUCCESS', 'GeneraciÃ³n de slots completada', {\n    totalSlotsGenerated,\n    skipped,\n  });\n\n  return {\n    allowed,\n    allowedSlots,\n    skipped,\n    totalSlotsGenerated,\n    shortNoticeMin,\n  };\n}\n\n// ==================== MAIN ====================\ntry {\n  log('INFO', `SCHEDULE_GATE v${VERSION} iniciando`);\n\n  // (1) Cargar SCHEDULE/HELPERS desde Static Data\n  const store =\n    typeof $getWorkflowStaticData === 'function'\n      ? $getWorkflowStaticData('global')\n      : this.getWorkflowStaticData('global');\n\n  const SCHEDULE = store.SCHEDULE;\n  const HELPERS = store.SCHEDULE_HELPERS;\n\n  if (!SCHEDULE) {\n    const guidance = {\n      tip: 'Ejecute primero CARGAR_HORARIOS en este mismo workflow para poblar Workflow Static Data (global).',\n      expectedKeys: [\n        'SCHEDULE',\n        'SCHEDULE_VERSION',\n        'SCHEDULE_UPDATED_AT',\n        'SCHEDULE_HELPERS (opcional)',\n      ],\n      foundKeys: Object.keys(store || {}),\n    };\n    log('ERROR', 'SCHEDULE ausente en Static Data', guidance);\n    return [\n      {\n        json: {\n          kind: 'error',\n          component: 'SCHEDULE_GATE',\n          version: VERSION,\n          error: 'SCHEDULE_NOT_LOADED',\n          message:\n            'SCHEDULE no cargado. Â¿EjecutÃ³ CARGAR_HORARIOS primero?',\n          details: guidance,\n          logs: DEBUG ? LOGS : undefined,\n        },\n      },\n    ];\n  }\n\n  log('INFO', 'SCHEDULE cargado desde Static Data', {\n    version: store.SCHEDULE_VERSION,\n    updatedAt: store.SCHEDULE_UPDATED_AT,\n    tz: SCHEDULE.tz,\n    sedes: Object.keys(SCHEDULE.sedes || {}),\n    hasHelpers: !!HELPERS,\n  });\n\n  // (2) Tomar context del input\n  const input = $input.first();\n  const validation = validateContextFromInput(input);\n  if (!validation.valid) {\n    if (validation.propagateError) {\n      log('INFO', 'Propagando error upstream');\n      return [input];\n    }\n    log('ERROR', 'Entrada invÃ¡lida', validation);\n    return [\n      {\n        json: {\n          kind: 'error',\n          component: 'SCHEDULE_GATE',\n          version: VERSION,\n          error: validation.error,\n          message: validation.message,\n          details: validation,\n          logs: DEBUG ? LOGS : undefined,\n        },\n      },\n    ];\n  }\n  const ctx = validation.ctx;\n\n  // (3) CFG derivado de SCHEDULE.config + contexto\n  const baseTZ = SCHEDULE.tz || 'America/Mexico_City';\n  const cfgFromSchedule = SCHEDULE.config || {};\n  const CFG = {\n    TZ: ctx.tz || baseTZ,\n    CONSULTATION_DURATION_MIN: cfgFromSchedule.consultationDuration || 30,\n    ANCHORS: cfgFromSchedule.slotAnchors || [0, 30],\n    SHORT_NOTICE_MIN: cfgFromSchedule.shortNoticeMinutes || 120,\n    MAX_SLOTS: cfgFromSchedule.maxSlots || 50,\n  };\n\n  const { DTF_FULL, DTF_DISPLAY, DTF_HM } = getFormatters(CFG.TZ);\n\n  // (4) Generar slots\n  const result = generateSlots(ctx, SCHEDULE, HELPERS, CFG, DTF_FULL, DTF_DISPLAY, DTF_HM);\n\n  // (5) Aplicar caps: ctx.maxResults + SCHEDULE.config.maxSlots\n  const ctxMax = Number.isFinite(Number(ctx.maxResults))\n    ? Number(ctx.maxResults)\n    : Infinity;\n  const scheduleMax = Number.isFinite(Number(CFG.MAX_SLOTS))\n    ? Number(CFG.MAX_SLOTS)\n    : Infinity;\n  const hardCap = Math.min(ctxMax, scheduleMax);\n\n  let prunedAllowed = result.allowed;\n  let prunedAllowedSlots = result.allowedSlots;\n\n  if (Number.isFinite(hardCap) && hardCap > 0 && hardCap !== Infinity) {\n    prunedAllowed = prunedAllowed.slice(0, hardCap);\n    prunedAllowedSlots = prunedAllowedSlots.slice(0, hardCap);\n  }\n\n  // (6) Resumen y respuesta\n  const summaryBySede = prunedAllowedSlots.reduce((acc, slot) => {\n    acc[slot.sede] = (acc[slot.sede] || 0) + 1;\n    return acc;\n  }, {});\n\n  const summaryByDay = prunedAllowedSlots.reduce((acc, s) => {\n    acc[s.dayKey] = (acc[s.dayKey] || 0) + 1;\n    return acc;\n  }, {});\n\n  const response = {\n    kind: 'scheduleGate',\n    version: VERSION,\n    tz: CFG.TZ,\n    request: {\n      windowStart: ctx.windowStart,\n      windowEnd: ctx.windowEnd,\n      sedes: ctx.sedes,\n      sedePreferida: ctx.sedePreferida,\n      timeWindow: ctx.timeWindow || {},\n      includeWeekends: ctx.includeWeekends !== false,\n      onlyMorning: !!ctx.onlyMorning,\n      onlyAfternoon: !!ctx.onlyAfternoon,\n      maxResults: ctx.maxResults,\n      consultationDuration: CFG.CONSULTATION_DURATION_MIN,\n      requestId: ctx.requestId,\n    },\n    decision: {\n      isOpen: prunedAllowedSlots.length > 0,\n      reason: prunedAllowedSlots.length\n        ? `${prunedAllowedSlots.length} opciones disponibles`\n        : 'Sin horarios en el rango solicitado',\n      shortNoticeMinutes: result.shortNoticeMin,\n    },\n    allowed: prunedAllowed,\n    allowedSlots: prunedAllowedSlots, // slots enriquecidos\n    skipped: result.skipped,\n    summary: {\n      totalSlots: prunedAllowedSlots.length,\n      bySede: summaryBySede,\n      byDay: summaryByDay,\n    },\n    meta: {\n      scheduleVersion: store.SCHEDULE_VERSION,\n      scheduleUpdatedAt: store.SCHEDULE_UPDATED_AT,\n      grid: {\n        stepMinutes: CFG.CONSULTATION_DURATION_MIN,\n        anchors: CFG.ANCHORS,\n      },\n    },\n    _logs: DEBUG ? LOGS : undefined,\n  };\n\n  log('SUCCESS', 'SCHEDULE_GATE completado', {\n    total: response.summary.totalSlots,\n    bySede: summaryBySede,\n  });\n\n  return [{ json: response }];\n} catch (error) {\n  log('ERROR', 'Error fatal', { error: error.message, stack: error.stack });\n  return [\n    {\n      json: {\n        kind: 'error',\n        component: 'SCHEDULE_GATE',\n        version: VERSION,\n        error: 'UNEXPECTED_ERROR',\n        message: error.message || String(error),\n        stack: DEBUG ? error.stack : undefined,\n        logs: DEBUG ? LOGS : undefined,\n      },\n    },\n  ];\n}\n"
      },
      "id": "318b3f62-6442-43c7-b97d-593c60aba641",
      "name": "SCHEDULE_GATE1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n// ==========================================\n// MODO FUERZA BRUTA - SEDE: POLANCO\n// ==========================================\nconst SEDE_OBJETIVO = 'POLANCO'; // <--- AquÃ­ forzamos el nombre\n// ==========================================\n\nconst DEFAULT_TZ = 'America/Mexico_City';\n\n// Helper simple para obtener milisegundos\nconst toMs = (v) => new Date(v).getTime();\nconst toISO = (ms) => new Date(ms).toISOString();\n\ntry {\n  const items = $input.all();\n  const rawPairs = [];\n\n  // 1. Extraer TODOS los intervalos 'busy' sin importar de quÃ© ID vengan\n  for (const item of items) {\n    const json = item.json;\n    \n    // OpciÃ³n A: Estructura Raw de Google (calendars -> id -> busy)\n    if (json && json.calendars) {\n      for (const calId of Object.keys(json.calendars)) {\n        const busyList = json.calendars[calId].busy || [];\n        for (const slot of busyList) {\n          if (slot.start && slot.end) {\n            rawPairs.push([toMs(slot.start), toMs(slot.end)]);\n          }\n        }\n      }\n    }\n    // OpciÃ³n B: Estructura simple (busy array directo)\n    else if (json && Array.isArray(json.busy)) {\n      for (const slot of json.busy) {\n        if (slot.start && slot.end) {\n          rawPairs.push([toMs(slot.start), toMs(slot.end)]);\n        }\n      }\n    }\n  }\n\n  // 2. Unificar los bloqueos (Merge) para limpiar la salida\n  rawPairs.sort((a, b) => a[0] - b[0]);\n  const merged = [];\n  \n  if (rawPairs.length > 0) {\n    let [currStart, currEnd] = rawPairs[0];\n    \n    for (let i = 1; i < rawPairs.length; i++) {\n      const [nextStart, nextEnd] = rawPairs[i];\n      if (nextStart < currEnd) {\n        currEnd = Math.max(currEnd, nextEnd); // Se solapan, extendemos el final\n      } else {\n        // No se solapan, guardamos el anterior y empezamos uno nuevo\n        merged.push({ sede: SEDE_OBJETIVO, start: toISO(currStart), end: toISO(currEnd) });\n        currStart = nextStart;\n        currEnd = nextEnd;\n      }\n    }\n    // Guardar el Ãºltimo\n    merged.push({ sede: SEDE_OBJETIVO, start: toISO(currStart), end: toISO(currEnd) });\n  }\n\n  // 3. Resultado final forzado\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE_OBJETIVO,\n      busy: merged,\n      busyBySede: { [SEDE_OBJETIVO]: merged },\n      sourceStatus: { ok: true, source: 'force_mode_active' }\n    }\n  }];\n\n} catch (err) {\n  // Si falla algo catastrÃ³fico, devolvemos error limpio\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE_OBJETIVO,\n      busy: [],\n      sourceStatus: { ok: false, error: err.message }\n    }\n  }];\n}"
      },
      "id": "71a3b9b2-49df-4d69-8bca-2c9fd5d39fec",
      "name": "Normalize Busy POLANCO1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n// ==========================================\n// MODO FUERZA BRUTA - SEDE: POLANCO\n// ==========================================\nconst SEDE_OBJETIVO = 'SATELITE'; // <--- AquÃ­ forzamos el nombre\n// ==========================================\n\nconst DEFAULT_TZ = 'America/Mexico_City';\n\n// Helper simple para obtener milisegundos\nconst toMs = (v) => new Date(v).getTime();\nconst toISO = (ms) => new Date(ms).toISOString();\n\ntry {\n  const items = $input.all();\n  const rawPairs = [];\n\n  // 1. Extraer TODOS los intervalos 'busy' sin importar de quÃ© ID vengan\n  for (const item of items) {\n    const json = item.json;\n    \n    // OpciÃ³n A: Estructura Raw de Google (calendars -> id -> busy)\n    if (json && json.calendars) {\n      for (const calId of Object.keys(json.calendars)) {\n        const busyList = json.calendars[calId].busy || [];\n        for (const slot of busyList) {\n          if (slot.start && slot.end) {\n            rawPairs.push([toMs(slot.start), toMs(slot.end)]);\n          }\n        }\n      }\n    }\n    // OpciÃ³n B: Estructura simple (busy array directo)\n    else if (json && Array.isArray(json.busy)) {\n      for (const slot of json.busy) {\n        if (slot.start && slot.end) {\n          rawPairs.push([toMs(slot.start), toMs(slot.end)]);\n        }\n      }\n    }\n  }\n\n  // 2. Unificar los bloqueos (Merge) para limpiar la salida\n  rawPairs.sort((a, b) => a[0] - b[0]);\n  const merged = [];\n  \n  if (rawPairs.length > 0) {\n    let [currStart, currEnd] = rawPairs[0];\n    \n    for (let i = 1; i < rawPairs.length; i++) {\n      const [nextStart, nextEnd] = rawPairs[i];\n      if (nextStart < currEnd) {\n        currEnd = Math.max(currEnd, nextEnd); // Se solapan, extendemos el final\n      } else {\n        // No se solapan, guardamos el anterior y empezamos uno nuevo\n        merged.push({ sede: SEDE_OBJETIVO, start: toISO(currStart), end: toISO(currEnd) });\n        currStart = nextStart;\n        currEnd = nextEnd;\n      }\n    }\n    // Guardar el Ãºltimo\n    merged.push({ sede: SEDE_OBJETIVO, start: toISO(currStart), end: toISO(currEnd) });\n  }\n\n  // 3. Resultado final forzado\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE_OBJETIVO,\n      busy: merged,\n      busyBySede: { [SEDE_OBJETIVO]: merged },\n      sourceStatus: { ok: true, source: 'force_mode_active' }\n    }\n  }];\n\n} catch (err) {\n  // Si falla algo catastrÃ³fico, devolvemos error limpio\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE_OBJETIVO,\n      busy: [],\n      sourceStatus: { ok: false, error: err.message }\n    }\n  }];\n}"
      },
      "id": "507c34ec-8170-4825-8920-3fb6241f83e8",
      "name": "Normalize Busy SATELITE1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        272
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  sede,\n  horario_json,\n  calendar_id,\n  display_name,\n  direccion,\n  maps_url,\n  anchor_date,\n  anchor_week_type\nFROM public.sedes\nWHERE horario_json IS NOT NULL;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1392,
        176
      ],
      "id": "bd19c208-2d3c-4be5-a2e3-dd5f4a447828",
      "name": "VERIFICAR HORARIOS DE SEDES1",
      "credentials": {
        "postgres": {
          "id": "LZyK5sbzVT7Dy3RU",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * CARGAR_HORARIOS v3.0.0\n * ---------------------------------\n * - Recibe filas desde un nodo previo (SELECT sobre public.sedes en Supabase/Postgres)\n * - Construye el objeto SCHEDULE:\n *   - sedes: horarios por sede y dÃ­a\n *   - meta: metadatos por sede (nombre, direcciÃ³n, calendarId, etc.)\n *   - config: parÃ¡metros globales de agenda\n *   - anchor: semana de referencia\n * - Guarda SCHEDULE y HELPERS en Workflow Static Data (global)\n * - Devuelve un resumen legible para depuraciÃ³n\n */\n\nconst VERSION = '3.0.0';\nconst DEFAULT_TZ = 'America/Mexico_City';\nconst LOGS = [];\nconst DEBUG = true;\n\n// ---------- LOGGING ----------\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'CARGAR_HORARIOS',\n    version: VERSION,\n    message,\n    ...data,\n  };\n  LOGS.push(entry);\n  if (DEBUG) {\n    console.log(`[${entry.level}] ${entry.component} :: ${entry.message}`, data);\n  }\n}\n\n// ---------- VALIDACIÃ“N DE HORARIOS ----------\nconst isHHMM = (s) => {\n  if (typeof s !== 'string') return false;\n  const m = /^(\\d{2}):(\\d{2})$/.exec(s);\n  if (!m) return false;\n  const hh = +m[1];\n  const mm = +m[2];\n  return hh >= 0 && hh <= 23 && mm >= 0 && mm <= 59;\n};\n\nconst validateShift = (shift, sede, dow, ctx = {}) => {\n  if (!Array.isArray(shift) || shift.length < 2) {\n    log('error', 'Shift invÃ¡lido (no es array o faltan elementos)', { sede, dow, shift, ctx });\n    return false;\n  }\n  const [start, end, label] = shift;\n\n  if (!isHHMM(start)) {\n    log('error', 'Start time invÃ¡lido', { sede, dow, start, ctx });\n    return false;\n  }\n  if (!isHHMM(end)) {\n    log('error', 'End time invÃ¡lido', { sede, dow, end, ctx });\n    return false;\n  }\n\n  const toMin = (s) => {\n    const [h, m] = s.split(':').map(Number);\n    return h * 60 + m;\n  };\n\n  if (toMin(start) >= toMin(end)) {\n    log('error', 'start >= end', { sede, dow, start, end, ctx });\n    return false;\n  }\n\n  if (!label || typeof label !== 'string') {\n    log('warn', 'Label faltante o invÃ¡lido', { sede, dow, label, ctx });\n  }\n\n  return true;\n};\n\n// ---------- HELPERS PARA SCHEDULE ----------\nfunction getDayOfWeekInTZ(dateISO, tz) {\n  const dayName = new Intl.DateTimeFormat('en-US', {\n    timeZone: tz,\n    weekday: 'short',\n  }).format(new Date(dateISO));\n  const map = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\n  return map[dayName];\n}\n\nfunction sedeHasScheduleOnDay(SCHEDULE, sede, dow) {\n  const sedeSchedule = SCHEDULE.sedes[sede];\n  if (!sedeSchedule) return false;\n  return Object.prototype.hasOwnProperty.call(sedeSchedule, dow);\n}\n\nfunction classifyTimeRange(hhmm) {\n  const hour = Number(hhmm.split(':')[0] || '0');\n  return hour < 14 ? 'morning' : 'afternoon';\n}\n\nfunction getShiftsForSedeAndDay(SCHEDULE, sede, dow, weekType = null) {\n  const sedeSchedule = SCHEDULE.sedes[sede];\n  if (!sedeSchedule) return [];\n  if (!Object.prototype.hasOwnProperty.call(sedeSchedule, dow)) return [];\n\n  const conf = sedeSchedule[dow];\n\n  // Caso simple: array de turnos\n  if (Array.isArray(conf)) return conf;\n\n  // Caso alterno: { A: [...], B: [...] }\n  if (conf && typeof conf === 'object') {\n    if (!weekType) {\n      return Object.values(conf).flat();\n    }\n    return conf[weekType] || [];\n  }\n\n  return [];\n}\n\nfunction getWorkingDays(SCHEDULE, sede) {\n  return SCHEDULE.meta[sede]?.workingDays || [];\n}\n\nfunction isWorkingDay(SCHEDULE, sede, dow) {\n  return getWorkingDays(SCHEDULE, sede).includes(dow);\n}\n\nfunction buildHelpers(SCHEDULE) {\n  return {\n    getDayOfWeekInTZ: (dateISO, tz = SCHEDULE.tz) => getDayOfWeekInTZ(dateISO, tz),\n    sedeHasScheduleOnDay: (sede, dow) => sedeHasScheduleOnDay(SCHEDULE, sede, dow),\n    classifyTimeRange,\n    getShiftsForSedeAndDay: (sede, dow, weekType) =>\n      getShiftsForSedeAndDay(SCHEDULE, sede, dow, weekType),\n    getAllSedes: () => Object.keys(SCHEDULE.sedes),\n    sedeExists: (sede) => Object.prototype.hasOwnProperty.call(SCHEDULE.sedes, sede),\n    normalizeSede: (input) => {\n      if (!input) return null;\n      const lower = String(input).toLowerCase().trim();\n      // Omitimos la clave especial \"sedes\" en meta\n      for (const [sede, meta] of Object.entries(SCHEDULE.meta)) {\n        if (sede === 'sedes') continue;\n        if (\n          meta.aliases &&\n          meta.aliases.some((a) => String(a).toLowerCase().trim() === lower)\n        ) {\n          return sede;\n        }\n      }\n      return null;\n    },\n    getWorkingDays: (sede) => getWorkingDays(SCHEDULE, sede),\n    isWorkingDay: (sede, dow) => isWorkingDay(SCHEDULE, sede, dow),\n  };\n}\n\n// ---------- MAIN ----------\n\nlog('info', `CARGAR_HORARIOS v${VERSION} iniciando`);\n\n// 1) LEER INPUT DEL NODO SQL / HTTP ANTERIOR\nconst rows = $input.all().map((item) => item.json || item);\n\nif (!rows || rows.length === 0) {\n  log('error', 'No se recibieron filas desde el nodo de BD (input vacÃ­o)');\n  throw new Error(\n    'CARGAR_HORARIOS: input vacÃ­o. AsegÃºrate de conectar el nodo que hace SELECT/HTTP sobre la tabla \"sedes\".'\n  );\n}\n\nlog('info', 'Filas recibidas desde nodo BD', { count: rows.length });\n\n// 2) CONSTRUIR SCHEDULE\nconst SCHEDULE = {\n  tz: DEFAULT_TZ,\n  version: VERSION,\n  anchor: null,\n  rest: { 0: 'Domingo - Cerrado' },\n  sedes: {},\n  meta: { sedes: {} }, // meta por sede + mapa agrupado en meta.sedes\n  config: {\n    consultationDuration: 30,\n    slotAnchors: [0, 30],\n    shortNoticeMinutes: 120,\n    confirmationBufferMinutes: 15,\n    defaultWindowDays: 14,\n    maxWindowDays: 90,\n    maxSlots: 50,\n    businessDayStart: 8,\n    businessDayEnd: 20,\n  },\n};\n\nlet totalShifts = 0;\nlet validShifts = 0;\nconst errors = [];\n\n// 2.1 Anchor global: tomamos la primera fila con anchor_date\nfor (const row of rows) {\n  if (row.anchor_date) {\n    SCHEDULE.anchor = {\n      date: row.anchor_date,\n      type: row.anchor_week_type || 'A',\n      description: 'Semana de referencia (desde sedes)',\n    };\n    break;\n  }\n}\n\nif (!SCHEDULE.anchor) {\n  SCHEDULE.anchor = {\n    date: '2025-01-06',\n    type: 'A',\n    description: 'Anchor por defecto (no definido en DB)',\n  };\n  log('warn', 'No se encontrÃ³ anchor_date en sedes; usando anchor por defecto', {\n    anchor: SCHEDULE.anchor,\n  });\n}\n\n// 2.2 Procesar cada sede\nfor (const row of rows) {\n  const sedeKey = (row.sede || '').toUpperCase().trim();\n  if (!sedeKey) {\n    log('warn', 'Fila sin sede, se omite', { row });\n    continue;\n  }\n\n  let horarioJson = row.horario_json;\n  if (!horarioJson) {\n    log('warn', `Sede ${sedeKey} sin horario_json, se omite`);\n    continue;\n  }\n\n  // Si viene como string, lo parseamos\n  if (typeof horarioJson === 'string') {\n    try {\n      horarioJson = JSON.parse(horarioJson);\n    } catch (e) {\n      log('error', `No se pudo parsear horario_json de sede ${sedeKey}`, {\n        raw: row.horario_json,\n        error: e.message,\n      });\n      continue;\n    }\n  }\n\n  if (typeof horarioJson !== 'object' || Array.isArray(horarioJson)) {\n    log('error', `horario_json de sede ${sedeKey} no es un objeto`, { horarioJson });\n    continue;\n  }\n\n  const sedeSchedule = {};\n\n  for (const [dowStr, conf] of Object.entries(horarioJson)) {\n    const dow = Number(dowStr);\n    if (Number.isNaN(dow) || dow < 0 || dow > 6) {\n      log('warn', `DÃ­a de semana invÃ¡lido ${dowStr} en sede ${sedeKey}, se omite`);\n      continue;\n    }\n\n    // Caso simple: [[\"09:00\",\"13:00\",\"Label\"], ...]\n    if (Array.isArray(conf)) {\n      const validatedShifts = [];\n      for (const shift of conf) {\n        totalShifts++;\n        if (validateShift(shift, sedeKey, dow, { mode: 'simple' })) {\n          validShifts++;\n          validatedShifts.push(shift);\n        } else {\n          errors.push({ sede: sedeKey, dow, shift });\n        }\n      }\n      if (validatedShifts.length > 0) {\n        sedeSchedule[dow] = validatedShifts;\n      }\n      continue;\n    }\n\n    // Caso alterno: { \"A\": [...], \"B\": [...] }\n    if (conf && typeof conf === 'object') {\n      const weekTypeSchedule = {};\n      for (const [weekType, arr] of Object.entries(conf)) {\n        if (!Array.isArray(arr)) {\n          log('warn', `weekType ${weekType} no es array en sede ${sedeKey} dow ${dow}`, {\n            conf,\n          });\n          continue;\n        }\n        const validatedShifts = [];\n        for (const shift of arr) {\n          totalShifts++;\n          if (validateShift(shift, sedeKey, dow, { mode: 'alterno', weekType })) {\n            validShifts++;\n            validatedShifts.push(shift);\n          } else {\n            errors.push({ sede: sedeKey, dow, weekType, shift });\n          }\n        }\n        if (validatedShifts.length > 0) {\n          weekTypeSchedule[weekType] = validatedShifts;\n        }\n      }\n      if (Object.keys(weekTypeSchedule).length > 0) {\n        sedeSchedule[dow] = weekTypeSchedule;\n      }\n      continue;\n    }\n\n    log('warn', `Config de dÃ­a ${dowStr} en sede ${sedeKey} no es array ni objeto, se omite`, {\n      conf,\n    });\n  }\n\n  if (Object.keys(sedeSchedule).length === 0) {\n    log('warn', `Sede ${sedeKey} no tiene horarios vÃ¡lidos despuÃ©s de la validaciÃ³n`);\n    continue;\n  }\n\n  // Guardar horarios vÃ¡lidos\n  SCHEDULE.sedes[sedeKey] = sedeSchedule;\n\n  const workingDays = Object.keys(sedeSchedule)\n    .map((d) => Number(d))\n    .filter((d) => !Number.isNaN(d))\n    .sort((a, b) => a - b);\n\n  const metaForSede = {\n    name: row.display_name || sedeKey,\n    fullName: row.display_name || sedeKey,\n    location: row.direccion || '',\n    aliases: [\n      sedeKey,\n      sedeKey.toLowerCase(),\n      ...(row.display_name ? [String(row.display_name).toLowerCase()] : []),\n    ],\n    calendarId: row.calendar_id,\n    workingDays,\n    hasWeekends: workingDays.includes(6),\n    timezone: row.timezone || DEFAULT_TZ,\n    maps_url: row.maps_url || null,\n    telefono: row.telefono || null,\n    whatsapp: row.whatsapp || null,\n  };\n\n  // Meta accesible por clave directa (SCHEDULE.meta['POLANCO'])\n  SCHEDULE.meta[sedeKey] = metaForSede;\n  // Y tambiÃ©n agrupada bajo meta.sedes['POLANCO'] (para nodos que lean asÃ­)\n  SCHEDULE.meta.sedes[sedeKey] = metaForSede;\n}\n\n// Alias de conveniencia\nSCHEDULE.metadata = SCHEDULE.meta;\n\nconst stats = {\n  totalSedes: Object.keys(SCHEDULE.sedes).length,\n  totalShifts,\n  validShifts,\n  sedesWithWeekends: Object.values(SCHEDULE.meta)\n    .filter((m) => m && typeof m === 'object' && m.hasWeekends)\n    .length,\n  errors: errors.length,\n};\n\nlog('info', 'TransformaciÃ³n a SCHEDULE completada', stats);\n\nif (stats.totalSedes === 0) {\n  log('error', 'Ninguna sede vÃ¡lida despuÃ©s de procesar horarios');\n  throw new Error(\n    'CARGAR_HORARIOS: no hay sedes vÃ¡lidas. Revisa horario_json en la tabla \"sedes\".'\n  );\n}\n\n// 3) HELPERS\nconst HELPERS = buildHelpers(SCHEDULE);\n\n// 4) GUARDAR EN WORKFLOW STATIC DATA\nconst store =\n  typeof $getWorkflowStaticData === 'function'\n    ? $getWorkflowStaticData('global')\n    : this.getWorkflowStaticData('global');\n\nstore.SCHEDULE = SCHEDULE;\nstore.SCHEDULE_HELPERS = HELPERS;\nstore.SCHEDULE_VERSION = SCHEDULE.version || VERSION;\nstore.SCHEDULE_SOURCE = 'SUPABASE';\nstore.SCHEDULE_UPDATED_AT = new Date().toISOString();\n\nlog('info', 'SCHEDULE guardado en Workflow Static Data', {\n  version: store.SCHEDULE_VERSION,\n  source: store.SCHEDULE_SOURCE,\n});\n\n// 5) RESUMEN LEGIBLE PARA VER EN LA SALIDA DEL NODO\nconst resume = {};\nfor (const [sede, days] of Object.entries(SCHEDULE.sedes)) {\n  resume[sede] = {};\n  for (const [dow, conf] of Object.entries(days)) {\n    if (Array.isArray(conf)) {\n      resume[sede][dow] = conf.map((s) => `${s[0]}-${s[1]} (${s[2] || ''})`);\n    } else if (conf && typeof conf === 'object') {\n      resume[sede][dow] = {};\n      for (const [wt, arr] of Object.entries(conf)) {\n        resume[sede][dow][wt] = arr.map((s) => `${s[0]}-${s[1]} (${s[2] || ''})`);\n      }\n    }\n  }\n}\n\n// 6) OUTPUT\nreturn [\n  {\n    json: {\n      kind: 'config',\n      component: 'CARGAR_HORARIOS',\n      version: store.SCHEDULE_VERSION,\n      source: 'SUPABASE',\n      dbRowCount: rows.length,\n      updatedAt: store.SCHEDULE_UPDATED_AT,\n      tz: SCHEDULE.tz,\n      anchor: SCHEDULE.anchor,\n      config: SCHEDULE.config,\n      meta: SCHEDULE.meta,\n      sedesMap: SCHEDULE.sedes,\n      stats,\n      resume,\n      sedeKeys: Object.keys(SCHEDULE.sedes),\n      logs: LOGS,\n      success: true,\n      message: `âœ… SCHEDULE v${store.SCHEDULE_VERSION} cargado desde BD (${rows.length} filas)`,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        176
      ],
      "id": "cc591c7a-aeac-4ebc-b056-cb92785bb447",
      "name": "CARGAR_HORARIOS"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * SET_DEFAULTS v5.4.0 â€” production ready\n * - Carga SCHEDULE en este orden: input (CARGAR_HORARIOS) â†’ nodo CARGAR_HORARIOS â†’ WorkflowStaticData\n * - Usa sedesMap (objeto real) y meta (aliases) si estÃ¡n presentes\n * - Config efectiva viene de SCHEDULE.config con fallback a CONFIG local\n * - Soporta â€œprÃ³ximo {dÃ­a}â€, â€œeste {dÃ­a}â€, dÃ­a suelto y relativos (hoy/maÃ±ana/pasado maÃ±ana)\n * - Limita fÃ­sicamente la ventana a maxWindowDays\n * - Normaliza windowDays y maxResults del input\n * - Devuelve windowStart/windowEnd en ISO local 00:00 y llaves YMD para compatibilidad\n */\n\nconst VERSION = '5.4.0';\nconst DEBUG = false;\n\n/* ===================== CONFIG BASE ===================== */\nconst CONFIG = Object.freeze({\n  DEFAULT_WINDOW_DAYS: 14,\n  MAX_WINDOW_DAYS: 90,\n  MAX_INPUT_LENGTH: 500,\n  SLOT_MINUTES: 30,\n  SHORT_NOTICE_MIN: 120,\n  CONFIRMATION_BUFFER_MIN: 15,\n  TZ: 'America/Mexico_City',\n  DAY_NAME_TO_DOW: {\n    'domingo': 0,\n    'lunes': 1,\n    'martes': 2,\n    'miercoles': 3,\n    'miÃ©rcoles': 3,\n    'jueves': 4,\n    'viernes': 5,\n    'sabado': 6,\n    'sÃ¡bado': 6,\n  },\n  RELATIVE_BASE: ['hoy', 'maÃ±ana', 'manana', 'pasado', 'pasado maÃ±ana', 'pasado manana'],\n});\n\nconst LOGS = [];\nconst log = (lvl, msg, data = {}) => {\n  if (!DEBUG && lvl === 'DEBUG') return;\n  LOGS.push({\n    timestamp: new Date().toISOString(),\n    level: lvl,\n    component: 'SET_DEFAULTS',\n    version: VERSION,\n    message: msg,\n    ...data,\n  });\n  if (DEBUG) console.log(`[${lvl}] ${msg}`, data);\n};\n\n/* ===================== FECHAS / TZ ===================== */\nfunction dtPartsInTZ(d, tz) {\n  const dtf = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n  const p = dtf.formatToParts(d).reduce((A, x) => ((A[x.type] = x.value), A), {});\n  return { y: +p.year, m: +p.month, d: +p.day, hh: +p.hour, mm: +p.minute, ss: +p.second };\n}\nfunction ymdInTZ(d, tz) {\n  const p = dtPartsInTZ(d, tz);\n  return `${p.y}-${String(p.m).padStart(2, '0')}-${String(p.d).padStart(2, '0')}`;\n}\nfunction isoStartOfDayLocal(dateKey, tz) {\n  const [y, m, d] = dateKey.split('-').map(Number);\n  // construir 00:00:00 local en tz (corrigiendo DST)\n  const guess = new Date(Date.UTC(y, m - 1, d, 0, 0, 0));\n  const seen = dtPartsInTZ(guess, tz);\n  // queremos y-m-d 00:00 locales\n  const want = Date.UTC(y, m - 1, d, 0, 0, 0);\n  const seenMs = Date.UTC(seen.y, seen.m - 1, seen.d, seen.hh, seen.mm, seen.ss);\n  const corrected = new Date(guess.getTime() + (want - seenMs));\n  return corrected.toISOString();\n}\nfunction addDaysYMD(dateKey, days) {\n  const [y, m, d] = dateKey.split('-').map(Number);\n  const u = Date.UTC(y, m - 1, d, 12, 0, 0);\n  const n = new Date(u + days * 86400000);\n  return `${n.getUTCFullYear()}-${String(n.getUTCMonth() + 1).padStart(2, '0')}-${String(\n    n.getUTCDate(),\n  ).padStart(2, '0')}`;\n}\nfunction getUTCDayFromYMD(dateKey) {\n  const [y, m, d] = dateKey.split('-').map(Number);\n  return new Date(Date.UTC(y, m - 1, d, 12, 0, 0)).getUTCDay();\n}\nfunction findNextDow(fromYMD, targetDow, strict) {\n  // strict=true: mÃ­nimo +1 dÃ­a; strict=false: puede ser el mismo dÃ­a\n  let cur = fromYMD;\n  for (let i = 0; i < 8; i++) {\n    const dow = getUTCDayFromYMD(cur);\n    if (dow === targetDow && (!strict ? true : i > 0)) return cur;\n    cur = addDaysYMD(cur, 1);\n  }\n  return cur;\n}\n\n/* ===================== SCHEDULE LOADER ===================== */\nfunction pickSedesFromInput(inputJson) {\n  // Preferir sedesMap (objeto real con turnos), nunca resume (strings)\n  if (inputJson?.sedesMap && typeof inputJson.sedesMap === 'object') return inputJson.sedesMap;\n  if (inputJson?.sedes && typeof inputJson.sedes === 'object' && !Array.isArray(inputJson.sedes))\n    return inputJson.sedes;\n  return null;\n}\nfunction loadSchedule(json) {\n  // 1) Input directo del caller (CARGAR_HORARIOS)\n  if (json?.kind === 'config' && json?.component === 'CARGAR_HORARIOS') {\n    const sedes = pickSedesFromInput(json) || {};\n    const schedule = {\n      tz: json.tz || CONFIG.TZ,\n      anchor: json.anchor,\n      rest: json.rest || {},\n      sedes,\n      meta: json.meta || {},\n      config: json.config || {},\n    };\n    log('SUCCESS', 'SCHEDULE desde input', {\n      version: json.version,\n      sedes: Object.keys(schedule.sedes),\n    });\n    return { schedule, version: json.version, updatedAt: json.updatedAt };\n  }\n\n  // 2) Intentar leer la salida del nodo CARGAR_HORARIOS (si existe en el grafo)\n  try {\n    const n = $('CARGAR_HORARIOS').first().json;\n    if (n?.kind === 'config') {\n      const sedes = pickSedesFromInput(n) || {};\n      const schedule = {\n        tz: n.tz || CONFIG.TZ,\n        anchor: n.anchor,\n        rest: n.rest || {},\n        sedes,\n        meta: n.meta || {},\n        config: n.config || {},\n      };\n      log('SUCCESS', 'SCHEDULE desde nodo CARGAR_HORARIOS', {\n        version: n.version,\n        sedes: Object.keys(schedule.sedes),\n      });\n      return { schedule, version: n.version, updatedAt: n.updatedAt };\n    }\n  } catch (e) {\n    /* no-op */\n  }\n\n  // 3) WorkflowStaticData (global)\n  try {\n    const store =\n      typeof $getWorkflowStaticData === 'function'\n        ? $getWorkflowStaticData('global')\n        : this.getWorkflowStaticData('global');\n    if (store?.SCHEDULE?.sedes) {\n      const S = store.SCHEDULE;\n      const schedule = {\n        tz: S.tz || CONFIG.TZ,\n        anchor: S.anchor,\n        rest: S.rest || {},\n        sedes: S.sedes,\n        meta: S.meta || {},\n        config: S.config || {},\n      };\n      log('SUCCESS', 'SCHEDULE desde WorkflowStaticData', {\n        version: store.SCHEDULE_VERSION,\n        sedes: Object.keys(schedule.sedes),\n      });\n      return {\n        schedule,\n        version: store.SCHEDULE_VERSION,\n        updatedAt: store.SCHEDULE_UPDATED_AT,\n      };\n    }\n  } catch (e) {\n    /* no-op */\n  }\n\n  throw new Error('SCHEDULE no disponible. Ejecuta CARGAR_HORARIOS o publica al static data.');\n}\n\n/* ===================== PARSERS ===================== */\nconst norm = (s) =>\n  (s || '')\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n\nfunction extractUserText(json) {\n  const raw =\n    json.userText ||\n    json.query ||\n    json.text ||\n    json.message ||\n    json.user_query ||\n    json.content ||\n    (json.__intent && json.__intent.userText) ||\n    '';\n  const t = String(raw).trim();\n  if (!t) return { ok: false, raw: '', normalized: '' };\n  if (t.length > CONFIG.MAX_INPUT_LENGTH) {\n    const cut = t.slice(0, CONFIG.MAX_INPUT_LENGTH);\n    return { ok: true, raw: cut, normalized: norm(cut) };\n  }\n  return { ok: true, raw: t, normalized: norm(t) };\n}\n\nfunction fuzzySedeFromText(text, meta) {\n  if (!text) return { sedePreferida: '', strict: false };\n  const found = [];\n  const metas = meta && typeof meta === 'object' ? meta : {};\n  for (const [sede, m] of Object.entries(metas)) {\n    const aliases = (m.aliases || []).map((a) => String(a).toLowerCase());\n    if (aliases.some((a) => text.includes(a))) found.push(sede);\n  }\n  if (found.length === 1) return { sedePreferida: found[0], strict: true };\n  if (found.length > 1) return { sedePreferida: found[0], strict: false };\n  return { sedePreferida: '', strict: false };\n}\n\nfunction parseDatesFromText(text, tz, referenceYMD, defaultWindowDays, maxWindowDays) {\n  // Detecta â€œprÃ³ximo {dÃ­a}â€, â€œsiguiente {dÃ­a}â€, â€œeste {dÃ­a}â€, o dÃ­a suelto\n  // Prioridad: prÃ³ximo/siguiente > este > dÃ­a suelto\n  const explicit = [];\n  const lower = text;\n\n  const dowMap = CONFIG.DAY_NAME_TO_DOW;\n  const dowNames = Object.keys(dowMap).sort((a, b) => b.length - a.length); // evita colisiones (miÃ© vs miercoles)\n  const findDowIn = (s) => {\n    for (const name of dowNames) if (s.includes(name)) return dowMap[name];\n    return null;\n  };\n\n  // prÃ³ximo/siguiente\n  if (/\\b(prox|proximo|prÃ³ximo|siguiente)\\b/.test(lower)) {\n    const d = findDowIn(lower);\n    if (d != null) {\n      explicit.push(findNextDow(referenceYMD, d, /*strict*/ true));\n    }\n  }\n  // este\n  else if (/\\b(este)\\b/.test(lower)) {\n    const d = findDowIn(lower);\n    if (d != null) {\n      explicit.push(findNextDow(referenceYMD, d, /*strict*/ false));\n    }\n  }\n  // dÃ­a suelto\n  else {\n    const d = findDowIn(lower);\n    if (d != null) {\n      explicit.push(findNextDow(referenceYMD, d, /*strict*/ false));\n    }\n  }\n\n  // Relativos base (hoy/maÃ±ana/pasado)\n  const rel = [\n    { re: /\\bhoy\\b/, add: 0 },\n    { re: /\\b(ma[Ã±n]ana)\\b/, add: 1 },\n    { re: /\\b(pasado(\\s+ma[Ã±n]ana)?)\\b/, add: 2 },\n  ];\n  for (const r of rel) if (r.re.test(lower)) explicit.push(addDaysYMD(referenceYMD, r.add));\n\n  const unique = Array.from(new Set(explicit)).sort();\n\n  // Ventana candidata\n  let windowStartYMD = referenceYMD;\n  let windowEndCandidateYMD = addDaysYMD(referenceYMD, defaultWindowDays);\n\n  if (unique.length > 0) {\n    windowStartYMD = unique[0];\n    windowEndCandidateYMD =\n      unique.length > 1 ? unique[unique.length - 1] : addDaysYMD(unique[0], 1);\n  }\n\n  // Clamp fÃ­sico de la ventana a maxWindowDays\n  const maxSpan = Math.max(1, maxWindowDays || defaultWindowDays || 1);\n\n  const [sy, sm, sd] = windowStartYMD.split('-').map(Number);\n  const [ey, em, ed] = windowEndCandidateYMD.split('-').map(Number);\n  const startUTC = Date.UTC(sy, sm - 1, sd, 12, 0, 0);\n  const endUTC = Date.UTC(ey, em - 1, ed, 12, 0, 0);\n\n  let diffDays = Math.round((endUTC - startUTC) / 86400000);\n  if (!Number.isFinite(diffDays) || diffDays < 1) diffDays = 1;\n  if (diffDays > maxSpan) {\n    windowEndCandidateYMD = addDaysYMD(windowStartYMD, maxSpan);\n  }\n\n  const windowEndYMD = windowEndCandidateYMD;\n\n  return {\n    explicitDates: unique,\n    windowStartYMD,\n    windowEndYMD,\n    dateIntent: unique.length > 0 ? 'specific' : 'flexible',\n  };\n}\n\n/* ===================== MAIN ===================== */\ntry {\n  const t0 = Date.now();\n\n  // 1) Cargar schedule\n  const scheduleData = loadSchedule($json);\n  const SCHEDULE = scheduleData.schedule;\n  const TZ = SCHEDULE.tz || CONFIG.TZ;\n\n  // 1.1) Config efectiva tomada de SCHEDULE.config\n  const SCFG = SCHEDULE.config || {};\n  const EFFECTIVE = {\n    windowDefaultDays: SCFG.defaultWindowDays ?? CONFIG.DEFAULT_WINDOW_DAYS,\n    maxWindowDays: SCFG.maxWindowDays ?? CONFIG.MAX_WINDOW_DAYS,\n    slotMinutes: SCFG.consultationDuration ?? CONFIG.SLOT_MINUTES,\n    shortNoticeMin: SCFG.shortNoticeMinutes ?? CONFIG.SHORT_NOTICE_MIN,\n    confirmationBufferMin: SCFG.confirmationBufferMinutes ?? CONFIG.CONFIRMATION_BUFFER_MIN,\n  };\n\n  // 2) â€œAhoraâ€ en tz\n  const now = new Date();\n  const todayYMD = ymdInTZ(now, TZ);\n\n  // 3) Intento de texto\n  const textInfo = extractUserText($json);\n  const textNorm = textInfo.normalized;\n\n  // 4) Sede fuzzy desde meta\n  const sedeInfo = fuzzySedeFromText(textNorm, SCHEDULE.meta);\n\n  // 5) Punto de referencia para fechas\n  const hasDateWords =\n    CONFIG.RELATIVE_BASE.some((w) => textNorm.includes(w)) ||\n    Object.keys(CONFIG.DAY_NAME_TO_DOW).some((k) => textNorm.includes(k)) ||\n    /\\b(prox|proximo|prÃ³ximo|siguiente|este)\\b/.test(textNorm);\n\n  let referenceYMD = todayYMD;\n  if (!hasDateWords && $json.desiredStart) {\n    const ms = Date.parse($json.desiredStart);\n    if (Number.isFinite(ms)) referenceYMD = ymdInTZ(new Date(ms), TZ);\n  }\n\n  // 6) Parseo de fechas con lÃ­mites de ventana\n  const dInfo = parseDatesFromText(\n    textNorm,\n    TZ,\n    referenceYMD,\n    EFFECTIVE.windowDefaultDays,\n    EFFECTIVE.maxWindowDays,\n  );\n\n  // 7) Construir ventana ISO (inicio/fin a medianoche local)\n  const windowStartISO = isoStartOfDayLocal(dInfo.windowStartYMD, TZ);\n  const windowEndISO = isoStartOfDayLocal(dInfo.windowEndYMD, TZ);\n\n  // 8) CÃ¡lculo de dÃ­as reales de ventana (clamp contra maxWindowDays)\n  const rawWindowDays = Math.ceil(\n    (new Date(windowEndISO) - new Date(windowStartISO)) / 86400000,\n  );\n  const computedWindowDays = Math.min(\n    Math.max(1, rawWindowDays || 1),\n    EFFECTIVE.maxWindowDays,\n  );\n\n  // 9) Normalizar windowDays y maxResults del input\n  const inWindowDays = Number.parseInt($json.windowDays, 10);\n  const safeWindowDays = Number.isFinite(inWindowDays)\n    ? Math.min(Math.max(1, inWindowDays), EFFECTIVE.maxWindowDays)\n    : EFFECTIVE.windowDefaultDays;\n\n  const inMaxResults = Number.parseInt($json.maxResults, 10);\n  const safeMaxResults = Number.isFinite(inMaxResults)\n    ? Math.min(Math.max(1, inMaxResults), 200)\n    : 50;\n\n  // 10) Sedes\n  let sedePreferida = sedeInfo.sedePreferida;\n  if (sedePreferida && !SCHEDULE.sedes[sedePreferida]) {\n    // defensa extra (en teorÃ­a no deberÃ­a pasar si CARGAR_HORARIOS validÃ³ bien)\n    log('WARN', 'Sede preferida sin horarios en SCHEDULE.sedes', { sedePreferida });\n    sedePreferida = '';\n  }\n  const sedesDisponibles = Object.keys(SCHEDULE.sedes || {});\n  const sedesFiltro =\n    sedePreferida && sedesDisponibles.includes(sedePreferida)\n      ? [sedePreferida]\n      : sedesDisponibles.length\n      ? sedesDisponibles\n      : [];\n\n  // 11) Contexto final\n  const context = {\n    kind: 'context',\n    version: VERSION,\n\n    originalInput: { raw: textInfo.raw || '', normalized: textNorm || '' },\n    locale: 'es-MX',\n    tz: TZ,\n\n    // Ventana (ISO + YMD para compatibilidad)\n    windowStart: windowStartISO,\n    windowEnd: windowEndISO,\n    windowStartDateKey: dInfo.windowStartYMD,\n    windowEndDateKey: dInfo.windowEndYMD,\n    computedWindowDays,\n\n    // IntenciÃ³n y filtros\n    dateIntent: dInfo.dateIntent,\n    explicitDates: dInfo.explicitDates, // YMDs\n    timeWindow: null,\n\n    // Sede\n    sedePreferida,\n    sedes: sedesFiltro,\n    strictSede: !!sedeInfo.strict,\n\n    // LÃ­mites operativos (solicitados por el caller)\n    windowDays: safeWindowDays,\n    maxResults: safeMaxResults,\n    includeWeekends: $json.includeWeekends !== false,\n    onlyMorning: !!$json.onlyMorning,\n    onlyAfternoon: !!$json.onlyAfternoon,\n    requestId:\n      $json.requestId || `req-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,\n    source: $json.source || 'unknown',\n\n    // Restricciones derivadas de la configuraciÃ³n efectiva\n    constraints: {\n      shortNoticeMin: EFFECTIVE.shortNoticeMin,\n      confirmationBufferMin: EFFECTIVE.confirmationBufferMin,\n      slotMinutes: EFFECTIVE.slotMinutes,\n      maxWindowDays: EFFECTIVE.maxWindowDays,\n    },\n\n    scheduleMetadata: {\n      version: scheduleData.version,\n      updatedAt: scheduleData.updatedAt,\n      anchor: SCHEDULE.anchor,\n      sedes: sedesDisponibles,\n      config: {\n        consultationDuration: SCHEDULE.config?.consultationDuration,\n        slotAnchors: SCHEDULE.config?.slotAnchors,\n        defaultWindowDays: SCHEDULE.config?.defaultWindowDays,\n        maxWindowDays: SCHEDULE.config?.maxWindowDays,\n        maxSlots: SCHEDULE.config?.maxSlots,\n        businessDayStart: SCHEDULE.config?.businessDayStart,\n        businessDayEnd: SCHEDULE.config?.businessDayEnd,\n      },\n    },\n\n    metadata: {\n      executionTimeMs: Date.now() - t0,\n      logsCount: LOGS.length,\n    },\n  };\n\n  if (DEBUG) context._logs = LOGS;\n\n  log('SUCCESS', 'SET_DEFAULTS completado', {\n    dateIntent: context.dateIntent,\n    sede: context.sedePreferida,\n    start: context.windowStart,\n    end: context.windowEnd,\n  });\n\n  return [{ json: context }];\n} catch (error) {\n  log('ERROR', 'Error fatal', { error: error.message, stack: error.stack });\n  return [\n    {\n      json: {\n        kind: 'error',\n        component: 'SET_DEFAULTS',\n        version: VERSION,\n        error: 'UNEXPECTED_ERROR',\n        message: error.message || String(error),\n        timestamp: new Date().toISOString(),\n        logs: DEBUG ? LOGS : undefined,\n      },\n    },\n  ];\n}\n"
      },
      "id": "7b01d2dd-2c49-49e0-a25b-d630c5b46a44",
      "name": "SET_DEFAULTS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        176
      ]
    }
  ],
  "pinData": {
    "When Executed by Another Workflow": [
      {
        "json": {
          "desiredStart": "2025-12-01T00:00:00",
          "userText": "Hola quiero agendar una cita con el dr mario en polanco el lunes",
          "sedePreferida": "POLANCO",
          "timezone": "America/Mexico_City",
          "windowDays": 14,
          "maxResults": 50,
          "includeWeekends": false,
          "onlyMorning": false,
          "onlyAfternoon": false,
          "requestId": "1764380321649-kj8m0vs7g",
          "source": "urobot_whatsapp"
        }
      }
    ]
  },
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "VERIFICAR HORARIOS DE SEDES1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - POLANCO1": {
      "main": [
        [
          {
            "node": "Normalize Busy POLANCO1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - SATELITE1": {
      "main": [
        [
          {
            "node": "Normalize Busy SATELITE1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Busy (append)": {
      "main": [
        [
          {
            "node": "Combine Busy1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Busy1": {
      "main": [
        [
          {
            "node": "Calc Availability1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calc Availability1": {
      "main": [
        [
          {
            "node": "Build Response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SCHEDULE_GATE1": {
      "main": [
        [
          {
            "node": "Availability - POLANCO1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Availability - SATELITE1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy POLANCO1": {
      "main": [
        [
          {
            "node": "Merge Busy (append)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy SATELITE1": {
      "main": [
        [
          {
            "node": "Merge Busy (append)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "VERIFICAR HORARIOS DE SEDES1": {
      "main": [
        [
          {
            "node": "CARGAR_HORARIOS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CARGAR_HORARIOS": {
      "main": [
        [
          {
            "node": "SET_DEFAULTS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SET_DEFAULTS": {
      "main": [
        [
          {
            "node": "SCHEDULE_GATE1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/Mexico_City",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "dfa262ab-6005-463a-84cc-c7ff5d298ac7",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "8c33c5b047d489bd000bdf4aabe6e4981a2da591f7a11d61031348a2fe3ef66c"
  },
  "id": "9mpErXIgA9uOnzrE",
  "tags": []
}