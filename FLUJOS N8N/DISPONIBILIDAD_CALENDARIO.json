{
  "name": "DISPONIBILIDAD_CALENDARIO",
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"desiredStart\": \"{{ $now.setZone('America/Mexico_City').toISO() }}\",\n  \"userText\": \"\",\n  \"sedePreferida\": \"\",\n  \"timezone\": \"America/Mexico_City\",\n  \"windowDays\": 14,\n  \"maxResults\": 50,\n  \"includeWeekends\": true,\n  \"onlyMorning\": false,\n  \"onlyAfternoon\": false,\n  \"requestId\": \"{{ $now.toMillis() }}-{{ Math.random().toString(36).substr(2, 9) }}\",\n  \"source\": \"urobot_whatsapp\"\n}\n"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1616,
        176
      ],
      "id": "c2799c91-4c27-4fd6-8bef-8bb038b22af0",
      "name": "When Executed by Another Workflow",
      "retryOnFail": true
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * BUILD_RESPONSE v19.1.0 ‚Äî Optimizado para UroBot (LLM-friendly)\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n *\n * - Consume salida de CALC_AVAILABILITY (kind:\"avail\").\n * - Valida y normaliza slots.\n * - NO usa sedes hardcodeadas:\n *   - Las sedes v√°lidas y sus nombres legibles se derivan de:\n *     - SCHEDULE en Workflow Static Data (cargado desde BD), o\n *     - Nodo CARGAR_HORARIOS, o\n *     - En √∫ltimo caso, de los propios slots.\n * - Agrupa por d√≠a y arma contexto ligero para el LLM:\n *   - llmContext.summary       ‚Üí frase ejecutiva corta\n *   - llmContext.primary       ‚Üí d√≠a principal + opciones\n *   - llmContext.backups[]     ‚Üí d√≠as alternativos + opciones\n *   - llmContext.filters       ‚Üí hint de filtros usados\n */\n\nconst VERSION = '19.1.0';\nconst DEBUG = true;\n\n/* ===================== CONFIG ===================== */\n\nconst LIMITS = {\n  MAX_SLOTS_PER_DAY: 20,     // m√°ximo slots a considerar por d√≠a (antes de compactar)\n  MAX_BACKUP_DAYS: 5,        // m√°ximo n√∫mero de d√≠as alternativos\n  MAX_TOTAL_SLOTS: 100,      // m√°ximo slots a procesar\n  MIN_SLOT_DURATION: 15,\n  MAX_SLOT_DURATION: 120,\n  MAX_OPTIONS_PER_DAY: 6     // cu√°ntas opciones compactas enviamos al LLM por d√≠a\n};\n\nconst REQUIRED_SLOT_FIELDS = [\n  'sede', 'start', 'end', 'startLocal', 'endLocal',\n  'durationMinutes', 'dayKey', 'startHM'\n];\n\n/* ===================== UTILIDADES GENERALES ===================== */\n\nfunction isEmpty(value) {\n  if (value === null || value === undefined) return true;\n  if (typeof value === 'string' && value.trim() === '') return true;\n  if (Array.isArray(value) && value.length === 0) return true;\n  if (typeof value === 'object' && Object.keys(value).length === 0) return true;\n  return false;\n}\n\nfunction safeGet(obj, path, defaultValue = null) {\n  try {\n    if (!obj) return defaultValue;\n    const keys = path.split('.');\n    let cur = obj;\n    for (const k of keys) {\n      if (cur == null) return defaultValue;\n      cur = cur[k];\n    }\n    return cur === undefined ? defaultValue : cur;\n  } catch (e) {\n    if (DEBUG) console.warn(`‚ö†Ô∏è safeGet error en \"${path}\":`, e.message);\n    return defaultValue;\n  }\n}\n\n/* ===================== CONFIG DIN√ÅMICA DE SEDES ===================== */\n\n/**\n * Intenta leer la configuraci√≥n de sedes desde:\n *  1) Workflow Static Data: store.SCHEDULE (cargado desde BD)\n *  2) Nodo \"CARGAR_HORARIOS\" (config componente)\n *  3) Fallback: deduce sedes desde los propios slots\n *\n * Devuelve:\n *  {\n *    validSedes: ['POLANCO', 'SATELITE', ...],\n *    sedeDisplay: { POLANCO: 'Polanco', SATELITE: 'Sat√©lite', ... }\n *  }\n */\nfunction buildDynamicSedeConfig(allowedSlotsRaw) {\n  const result = {\n    validSedes: [],\n    sedeDisplay: {}\n  };\n\n  const sedeSet = new Set();\n  let schedule = null;\n\n  // 1) Intentar leer SCHEDULE desde Workflow Static Data\n  try {\n    const store = $getWorkflowStaticData('global');\n    if (store && store.SCHEDULE && typeof store.SCHEDULE === 'object') {\n      schedule = store.SCHEDULE;\n      if (DEBUG) console.log('üì¶ SCHEDULE encontrado en static data.');\n    }\n  } catch (e) {\n    if (DEBUG) console.warn('‚ö†Ô∏è No se pudo leer SCHEDULE de static data:', e.message);\n  }\n\n  // 2) Si no hay SCHEDULE, intentar usar nodo CARGAR_HORARIOS\n  if (!schedule) {\n    try {\n      const cfgNode = $('CARGAR_HORARIOS').first();\n      if (cfgNode && cfgNode.json && typeof cfgNode.json === 'object') {\n        const cfgJson = cfgNode.json;\n        schedule = {\n          sedes: cfgJson.sedesMap || cfgJson.sedes || {},\n          meta: cfgJson.meta || {}\n        };\n        if (DEBUG) console.log('üì¶ Config de sedes tomada desde nodo CARGAR_HORARIOS.');\n      }\n    } catch (e) {\n      if (DEBUG) console.warn('‚ö†Ô∏è No se pudo leer config desde CARGAR_HORARIOS:', e.message);\n    }\n  }\n\n  // 3) Extraer sedes desde schedule (si existe)\n  let metaSedes = {};\n  if (schedule && typeof schedule === 'object') {\n    const sedesConfig = schedule.sedes || {};\n    metaSedes = (schedule.meta && (schedule.meta.sedes || schedule.meta.SEDES)) || {};\n\n    for (const key of Object.keys(sedesConfig)) {\n      const upper = String(key).toUpperCase();\n      sedeSet.add(upper);\n\n      const meta = metaSedes[key] || metaSedes[upper] || {};\n      const display =\n        meta.displayName ||\n        meta.name ||\n        meta.alias ||\n        upper;\n\n      result.sedeDisplay[upper] = display;\n    }\n  }\n\n  // 4) Fallback: deducir sedes desde los slots crudos si no se obtuvo nada de schedule\n  if (!sedeSet.size && Array.isArray(allowedSlotsRaw)) {\n    for (const raw of allowedSlotsRaw) {\n      if (!raw) continue;\n      const sedeRaw = raw.sede || raw.Sede || '';\n      if (!sedeRaw) continue;\n      const upper = String(sedeRaw).toUpperCase().trim();\n      if (!upper) continue;\n\n      if (!sedeSet.has(upper)) {\n        sedeSet.add(upper);\n        result.sedeDisplay[upper] = upper;\n      }\n    }\n  }\n\n  result.validSedes = Array.from(sedeSet);\n\n  if (DEBUG) {\n    console.log('üè• Sedes din√°micas detectadas:', result.validSedes);\n    console.log('üè∑Ô∏è  Mapa display sedes:', result.sedeDisplay);\n  }\n\n  return result;\n}\n\n/**\n * Nombre legible de sede basado en el mapa din√°mico\n */\nfunction sedeName(s, sedeDisplayMap) {\n  const key = String(s || '').toUpperCase();\n  return sedeDisplayMap[key] || String(s || '');\n}\n\n/* ===================== FORMATO Y UX ===================== */\n\n/**\n * Convierte HH:MM (24h) ‚Üí \"h:mm AM/PM\"\n */\nfunction hm24to12(hm) {\n  if (!hm || !/^\\d{2}:\\d{2}$/.test(hm)) return hm || '';\n  const [H, M] = hm.split(':').map(n => parseInt(n, 10));\n  const am = H < 12;\n  const h12 = H % 12 === 0 ? 12 : H % 12;\n  return `${h12}:${String(M).padStart(2, '0')} ${am ? 'AM' : 'PM'}`;\n}\n\n/**\n * Ordena slots por startHM (lexicogr√°fico HH:MM)\n */\nfunction sortByHM(slots) {\n  return (slots || []).sort((a, b) =>\n    (a.startHM || '').localeCompare(b.startHM || '')\n  );\n}\n\n/* ===================== VALIDACI√ìN DE SLOTS ===================== */\n\nfunction isValidSlot(slot, validSedes) {\n  if (!slot || typeof slot !== 'object') {\n    return { valid: false, reason: 'Slot es null o no es objeto' };\n  }\n\n  for (const field of REQUIRED_SLOT_FIELDS) {\n    if (isEmpty(slot[field])) {\n      return { valid: false, reason: `Campo obligatorio faltante: ${field}` };\n    }\n  }\n\n  const sede = String(slot.sede || '').toUpperCase();\n\n  // Si tenemos una lista de sedes v√°lidas, validar contra ella.\n  // Si la lista est√° vac√≠a (no pudimos inferir sedes), NO bloqueamos por sede.\n  if (Array.isArray(validSedes) && validSedes.length > 0) {\n    if (!validSedes.includes(sede)) {\n      return { valid: false, reason: `Sede inv√°lida o no configurada: ${slot.sede}` };\n    }\n  }\n\n  const duration = parseInt(slot.durationMinutes);\n  if (isNaN(duration) ||\n      duration < LIMITS.MIN_SLOT_DURATION ||\n      duration > LIMITS.MAX_SLOT_DURATION) {\n    return { valid: false, reason: `Duraci√≥n inv√°lida: ${duration} minutos` };\n  }\n\n  const startMs = Date.parse(slot.start);\n  const endMs = Date.parse(slot.end);\n  if (Number.isNaN(startMs) || Number.isNaN(endMs)) {\n    return { valid: false, reason: 'Formato de fecha inv√°lido' };\n  }\n  if (endMs <= startMs) {\n    return { valid: false, reason: 'Hora de fin no es posterior a hora de inicio' };\n  }\n\n  if (!/^\\d{2}:\\d{2}$/.test(slot.startHM)) {\n    return { valid: false, reason: 'startHM inv√°lido (debe ser HH:MM)' };\n  }\n\n  return { valid: true };\n}\n\nfunction sanitizeSlot(slot) {\n  try {\n    return {\n      sede: String(slot.sede || '').toUpperCase().trim(),\n      start: String(slot.start || '').trim(),\n      end: String(slot.end || '').trim(),\n      durationMinutes: parseInt(slot.durationMinutes) || 30,\n      label: String(slot.label || 'Consulta').trim(),\n      weekType: String(slot.weekType || 'A').trim(),\n      startLocal: String(slot.startLocal || '').trim(),\n      endLocal: String(slot.endLocal || '').trim(),\n      startHM: String(slot.startHM || '00:00').trim(),\n      dayKey: String(slot.dayKey || '').trim(),\n      dow: parseInt(slot.dow) || 0,\n      _score: parseFloat(slot._score) || 0\n    };\n  } catch (e) {\n    if (DEBUG) console.error('‚ùå Error sanitizando slot:', e);\n    return null;\n  }\n}\n\n/* ===================== AGRUPAMIENTO POR D√çA ===================== */\n\nfunction getDayName(dayKey) {\n  try {\n    const date = new Date(dayKey + 'T12:00:00Z'); // seguro para day-of-week\n    const days = ['domingo', 'lunes', 'martes', 'mi√©rcoles', 'jueves', 'viernes', 's√°bado'];\n    return days[date.getUTCDay()] || 'd√≠a';\n  } catch (e) {\n    if (DEBUG) console.warn('‚ö†Ô∏è Error obteniendo nombre de d√≠a:', e);\n    return 'd√≠a';\n  }\n}\n\nfunction formatDateDisplay(dayKey) {\n  try {\n    const date = new Date(dayKey + 'T12:00:00Z');\n    const day = date.getUTCDate();\n    const months = ['ene', 'feb', 'mar', 'abr', 'may', 'jun',\n                    'jul', 'ago', 'sep', 'oct', 'nov', 'dic'];\n    const month = months[date.getUTCMonth()];\n    return `${day} ${month}`;\n  } catch (e) {\n    if (DEBUG) console.warn('‚ö†Ô∏è Error formateando fecha:', e);\n    return dayKey;\n  }\n}\n\n/**\n * Agrupa slots por dayKey y los ordena por hora local (startHM)\n */\nfunction groupSlotsByDay(slots) {\n  try {\n    if (!Array.isArray(slots) || !slots.length) return [];\n\n    const grouped = {};\n\n    for (const slot of slots) {\n      const dayKey = slot.dayKey || 'unknown';\n      if (!grouped[dayKey]) {\n        grouped[dayKey] = {\n          dayKey,\n          dayLabel: getDayName(dayKey),\n          dateDisplay: formatDateDisplay(dayKey),\n          slots: []\n        };\n      }\n      grouped[dayKey].slots.push(slot);\n    }\n\n    // ordenar cada grupo por hora\n    for (const g of Object.values(grouped)) {\n      sortByHM(g.slots);\n    }\n\n    // ordenar d√≠as por fecha\n    return Object.values(grouped).sort((a, b) => a.dayKey.localeCompare(b.dayKey));\n  } catch (e) {\n    if (DEBUG) console.error('‚ùå Error agrupando slots por d√≠a:', e);\n    return [];\n  }\n}\n\n/* ===================== CONSTRUCCI√ìN DEL CONTEXTO PARA EL LLM ===================== */\n\n/**\n * Construye el objeto llmContext (ligero) para UroBot\n * primary/backups contienen s√≥lo opciones compactas.\n */\nfunction buildLlmContext(primaryDay, backupDays, query, sedeDisplayMap) {\n  // 1) Summary ejecutivo\n  const parts = [];\n\n  if (primaryDay && primaryDay.slots && primaryDay.slots.length > 0) {\n    const totalSlots = primaryDay.slots.length;\n    const firstSlot = primaryDay.slots[0];\n    const sede = firstSlot.sede || 'sede';\n    const dayLabel = primaryDay.dayLabel || 'd√≠a';\n    const dateDisplay = primaryDay.dateDisplay || '';\n\n    parts.push(\n      `Disponibilidad para ${dayLabel} ${dateDisplay} en ${sedeName(sede, sedeDisplayMap)}: ${totalSlots} horarios`\n    );\n\n    const destacados = primaryDay.slots\n      .slice(0, 3)\n      .map(s => hm24to12(s.startHM))\n      .filter(Boolean);\n\n    if (destacados.length) {\n      parts.push(`Horarios destacados: ${destacados.join(', ')}`);\n    }\n  }\n\n  if (backupDays && backupDays.length > 0) {\n    parts.push(`Tambi√©n hay disponibilidad en ${backupDays.length} d√≠a(s) adicional(es).`);\n  }\n\n  const summary = parts.join(' ');\n\n  // 2) Primary options (compactas)\n  const primaryOptions = (primaryDay?.slots || [])\n    .slice(0, LIMITS.MAX_OPTIONS_PER_DAY)\n    .map(s => ({\n      sede: s.sede,\n      sedeName: sedeName(s.sede, sedeDisplayMap),\n      dayKey: primaryDay.dayKey,\n      time24: s.startHM,\n      time12: hm24to12(s.startHM)\n    }));\n\n  // 3) Backup days (compactos)\n  const backups = (backupDays || []).map(day => {\n    const opts = (day.slots || [])\n      .slice(0, LIMITS.MAX_OPTIONS_PER_DAY)\n      .map(s => ({\n        sede: s.sede,\n        sedeName: sedeName(s.sede, sedeDisplayMap),\n        dayKey: day.dayKey,\n        time24: s.startHM,\n        time12: hm24to12(s.startHM)\n      }));\n\n    return {\n      dayKey: day.dayKey,\n      dayLabel: day.dayLabel,\n      dateDisplay: day.dateDisplay,\n      options: opts\n    };\n  });\n\n  // 4) Filtros (para contexto del modelo)\n  const filters = {\n    sedePreferida: query?.sedePreferida || null,\n    onlyMorning: !!query?.onlyMorning,\n    onlyAfternoon: !!query?.onlyAfternoon,\n    includeWeekends: query?.includeWeekends !== false\n  };\n\n  return {\n    summary,\n    primary: {\n      dayKey: primaryDay?.dayKey || null,\n      dayLabel: primaryDay?.dayLabel || null,\n      dateDisplay: primaryDay?.dateDisplay || null,\n      options: primaryOptions\n    },\n    backups,\n    filters\n  };\n}\n\n/* ===================== MAIN ===================== */\n\ntry {\n  const t0 = Date.now();\n  if (DEBUG) console.log('üöÄ BUILD_RESPONSE v19.1.0 - INICIANDO');\n\n  const inputItems = $input.all();\n  if (!inputItems || !inputItems.length) {\n    throw new Error('No hay items de entrada');\n  }\n\n  const firstItem = inputItems[0];\n  const jsonData = safeGet(firstItem, 'json', {});\n\n  if (jsonData.kind !== 'avail') {\n    throw new Error(`Entrada inv√°lida: se esperaba kind=\"avail\", recibido \"${jsonData.kind}\"`);\n  }\n\n  const allowedSlotsRaw = safeGet(jsonData, 'allowedSlots', []);\n  if (!Array.isArray(allowedSlotsRaw)) {\n    throw new Error('Formato inv√°lido: allowedSlots debe ser un array');\n  }\n\n  if (DEBUG) console.log(`üìä Slots recibidos (raw): ${allowedSlotsRaw.length}`);\n\n  // === Config din√°mica de sedes (desde BD / CARGAR_HORARIOS / slots) ===\n  const sedeConfig = buildDynamicSedeConfig(allowedSlotsRaw);\n  const validSedes = sedeConfig.validSedes || [];\n  const sedeDisplayMap = sedeConfig.sedeDisplay || {};\n\n  // === Validar y sanitizar slots ===\n  const validSlots = [];\n  const invalidSlots = [];\n\n  for (let i = 0; i < allowedSlotsRaw.length; i++) {\n    if (validSlots.length >= LIMITS.MAX_TOTAL_SLOTS) {\n      if (DEBUG) console.warn(`‚ö†Ô∏è L√≠mite de slots alcanzado (${LIMITS.MAX_TOTAL_SLOTS}), ignorando resto`);\n      break;\n    }\n\n    const sanitized = sanitizeSlot(allowedSlotsRaw[i]);\n    if (!sanitized) {\n      invalidSlots.push({ index: i, reason: 'Error en sanitizaci√≥n' });\n      continue;\n    }\n\n    const v = isValidSlot(sanitized, validSedes);\n    if (!v.valid) {\n      invalidSlots.push({ index: i, reason: v.reason });\n      if (DEBUG) console.log(`‚ö†Ô∏è Slot ${i} inv√°lido: ${v.reason}`);\n      continue;\n    }\n\n    validSlots.push(sanitized);\n  }\n\n  if (DEBUG) {\n    console.log(`‚úÖ Slots v√°lidos: ${validSlots.length}`);\n    console.log(`‚ùå Slots inv√°lidos: ${invalidSlots.length}`);\n  }\n\n  // === Sin disponibilidad ===\n  if (!validSlots.length) {\n    const noAvailMsg = 'No hay disponibilidad para las fechas solicitadas. Ofrece buscar otras fechas o la otra sede.';\n\n    const llmBrief = {\n      kind: 'llm_brief',\n      version: VERSION,\n      status: 'no_availability',\n      executiveSummary: noAvailMsg,\n      humanMessage: noAvailMsg,\n      whatsappMessage: noAvailMsg,\n      llmContext: {\n        summary: noAvailMsg,\n        primary: null,\n        backups: [],\n        filters: {}\n      },\n      availableSlots: 0,\n      availableDays: 0,\n      query: {},\n      timestamp: new Date().toISOString()\n    };\n\n    const auditPayload = {\n      kind: 'audit_payload',\n      version: VERSION,\n      status: 'no_availability',\n      metrics: {\n        executionTimeMs: Date.now() - t0,\n        totalSlotsReceived: allowedSlotsRaw.length,\n        validSlots: 0,\n        invalidSlots: invalidSlots.length,\n        daysWithAvailability: 0,\n        primaryDaySlots: 0,\n        backupDaysCount: 0\n      },\n      timestamp: new Date().toISOString()\n    };\n\n    return [\n      { json: llmBrief, pairedItem: { item: 0 } },\n      { json: auditPayload, pairedItem: { item: 0 } }\n    ];\n  }\n\n  // === Agrupar por d√≠a ===\n  const dayGroups = groupSlotsByDay(validSlots);\n  if (!dayGroups.length) {\n    throw new Error('Error agrupando slots por d√≠a');\n  }\n\n  // D√≠a principal y backups\n  const primaryDay = dayGroups[0];\n  const backupDays = dayGroups.slice(1, LIMITS.MAX_BACKUP_DAYS + 1);\n\n  // Recortar slots por d√≠a seg√∫n l√≠mite\n  primaryDay.slots = primaryDay.slots.slice(0, LIMITS.MAX_SLOTS_PER_DAY);\n  for (const d of backupDays) {\n    if (d.slots && d.slots.length > LIMITS.MAX_SLOTS_PER_DAY) {\n      d.slots = d.slots.slice(0, LIMITS.MAX_SLOTS_PER_DAY);\n    }\n  }\n\n  if (DEBUG) {\n    console.log(`üéØ D√≠a principal: ${primaryDay.dayLabel} ${primaryDay.dateDisplay} (${primaryDay.slots.length} slots)`);\n    console.log(`üîÑ D√≠as de respaldo: ${backupDays.length}`);\n  }\n\n  // === Query / filtros (ligero) ===\n  const query = {\n    desiredStart: safeGet(jsonData, 'desiredStart', ''),\n    userText: safeGet(jsonData, 'userText', ''),\n    sedePreferida: safeGet(jsonData, 'sedePreferida', ''),\n    timezone: safeGet(jsonData, 'timezone', safeGet(jsonData, 'tz', 'America/Mexico_City')),\n    onlyMorning: safeGet(jsonData, 'onlyMorning', false),\n    onlyAfternoon: safeGet(jsonData, 'onlyAfternoon', false),\n    includeWeekends: safeGet(jsonData, 'includeWeekends', true)\n  };\n\n  // === Construir llmContext (compacto) ===\n  const llmContext = buildLlmContext(primaryDay, backupDays, query, sedeDisplayMap);\n  const executiveSummary = llmContext.summary || 'Disponibilidad encontrada.';\n\n  if (DEBUG) {\n    console.log(`üìù Executive summary: ${executiveSummary}`);\n  }\n\n  // === LLM BRIEF (para el modelo) ===\n  const llmBrief = {\n    kind: 'llm_brief',\n    version: VERSION,\n    status: 'success',\n\n    executiveSummary,\n    humanMessage: executiveSummary,\n    whatsappMessage: executiveSummary, // alias/fallback\n\n    llmContext,\n\n    availableSlots: validSlots.length,\n    availableDays: dayGroups.length,\n\n    primaryDay: {\n      dayKey: primaryDay.dayKey,\n      dayLabel: primaryDay.dayLabel,\n      dateDisplay: primaryDay.dateDisplay,\n      totalSlots: primaryDay.slots.length\n    },\n    backupDays: backupDays.map(d => ({\n      dayKey: d.dayKey,\n      dayLabel: d.dayLabel,\n      dateDisplay: d.dateDisplay,\n      totalSlots: d.slots.length\n    })),\n\n    query,\n    timestamp: new Date().toISOString()\n  };\n\n  // === AUDIT PAYLOAD (para logs/monitoring) ===\n  const auditPayload = {\n    kind: 'audit_payload',\n    version: VERSION,\n    status: 'success',\n    metrics: {\n      executionTimeMs: Date.now() - t0,\n      totalSlotsReceived: allowedSlotsRaw.length,\n      validSlots: validSlots.length,\n      invalidSlots: invalidSlots.length,\n      daysWithAvailability: dayGroups.length,\n      primaryDaySlots: primaryDay.slots.length,\n      backupDaysCount: backupDays.length\n    },\n    allDays: dayGroups.map(d => ({\n      dayKey: d.dayKey,\n      dayLabel: d.dayLabel,\n      totalSlots: d.slots.length\n    })),\n    query,\n    requestId: safeGet(jsonData, 'requestId', 'unknown'),\n    timestamp: new Date().toISOString()\n  };\n\n  if (DEBUG) {\n    console.log('‚úÖ BUILD_RESPONSE v19.1.0 - COMPLETADO');\n    console.log(`üìä Slots v√°lidos: ${validSlots.length}/${allowedSlotsRaw.length}`);\n  }\n\n  return [\n    { json: llmBrief, pairedItem: { item: 0 } },\n    { json: auditPayload, pairedItem: { item: 0 } }\n  ];\n\n} catch (error) {\n  console.error('‚ùå ERROR CR√çTICO EN BUILD_RESPONSE:', error);\n  console.error('Stack:', error.stack);\n\n  const errorMsg = 'Ocurri√≥ un error al procesar la disponibilidad. Ofrece intentar nuevamente o buscar otras fechas.';\n\n  const errorLlmBrief = {\n    kind: 'llm_brief',\n    version: VERSION,\n    status: 'error',\n    error: true,\n    executiveSummary: errorMsg,\n    humanMessage: errorMsg,\n    whatsappMessage: errorMsg,\n    llmContext: {\n      summary: errorMsg,\n      primary: null,\n      backups: [],\n      filters: {}\n    },\n    errorDetails: DEBUG ? { message: error.message, type: error.name } : undefined,\n    timestamp: new Date().toISOString()\n  };\n\n  const errorAuditPayload = {\n    kind: 'audit_payload',\n    version: VERSION,\n    status: 'error',\n    error: {\n      message: error.message,\n      type: error.name,\n      stack: DEBUG ? error.stack : undefined\n    },\n    timestamp: new Date().toISOString()\n  };\n\n  return [\n    { json: errorLlmBrief, pairedItem: { item: 0 } },\n    { json: errorAuditPayload, pairedItem: { item: 0 } }\n  ];\n}\n"
      },
      "id": "e7f44ed3-e1c6-4973-9adf-695f6a67c185",
      "name": "Build Response1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        176
      ]
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "Hospital Angeles Polanco"
        },
        "timeMin": "={{$('SET_DEFAULTS').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "fdf87251-eeab-4f0a-8d40-4701f44416e4",
      "name": "Availability - POLANCO1",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -496,
        80
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "retryOnFail": false,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "Hm8ggB0P1TTFp0A0",
          "name": "GOOGLE UROBOT"
        }
      },
      "notes": "Fallback: Continue On Fail activo. Si falla, Normalize generar√° sourceStatus=error."
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "San Angel Inn Satelite"
        },
        "timeMin": "={{$('SET_DEFAULTS').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "be0a82b0-1bd9-4e51-b848-2513c26f112a",
      "name": "Availability - SATELITE1",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -496,
        272
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "Hm8ggB0P1TTFp0A0",
          "name": "GOOGLE UROBOT"
        }
      },
      "notes": "Fallback: Continue On Fail activo."
    },
    {
      "parameters": {},
      "id": "89d6106b-3e48-4687-9bb2-647b48ae697e",
      "name": "Merge Busy (append)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -48,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * COMBINE_BUSY v5.0.0 ‚Äî Refactorizado y Mejorado\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n *\n * CAMBIOS vs v4.6.1:\n * - ‚úÖ Refactorizado en funciones modulares (reducci√≥n de complejidad)\n * - ‚úÖ filterToVerifiedSedes ahora TRUE por defecto (seguridad)\n * - ‚úÖ Mejor manejo de errores y logging estructurado\n * - ‚úÖ Validaci√≥n estricta de sedes antes de ofrecer slots\n * - ‚úÖ Documentaci√≥n mejorada\n * - ‚úÖ Performance optimizations (cache de formatters)\n */\n\nconst VERSION = '5.0.0';\nconst DEBUG = false; // ‚öôÔ∏è Cambiar a true solo en desarrollo\n\n/* ===================== CONFIG ===================== */\n\nconst LIMITS = Object.freeze({\n  MAX_SLOTS_PER_DAY: 20,\n  MAX_BACKUP_DAYS: 5,\n  MAX_TOTAL_SLOTS: 100,\n  MIN_SLOT_DURATION: 15,\n  MAX_SLOT_DURATION: 120,\n  MAX_OPTIONS_PER_DAY: 6\n});\n\nconst REQUIRED_SLOT_FIELDS = Object.freeze([\n  'sede', 'start', 'end', 'startLocal', 'endLocal',\n  'durationMinutes', 'dayKey', 'startHM'\n]);\n\n// ‚ö†Ô∏è CAMBIO CR√çTICO: filterToVerifiedSedes ahora TRUE por defecto\nconst POLICY_DEFAULTS = Object.freeze({\n  mergeTouching: true,\n  filterToVerifiedSedes: true, // ‚úÖ NUEVO: Seguridad mejorada\n  strictVerification: true,\n  requireBusyData: true // ‚úÖ NUEVO: Requiere datos de calendario\n});\n\n/* ===================== LOGGING ===================== */\n\nconst LOGS = [];\n\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'COMBINE_BUSY',\n    version: VERSION,\n    message,\n    ...data\n  };\n  LOGS.push(entry);\n  \n  if (DEBUG) {\n    const emoji = {\n      INFO: '‚ÑπÔ∏è', WARN: '‚ö†Ô∏è', ERROR: '‚ùå', \n      DEBUG: 'üîç', SUCCESS: '‚úÖ'\n    }[level.toUpperCase()] || 'üìù';\n    console.log(`${emoji} [${level}] ${message}`, data);\n  }\n}\n\n/* ===================== UTILITIES ===================== */\n\nfunction safeGet(obj, path, defaultValue = null) {\n  try {\n    if (!obj) return defaultValue;\n    const keys = path.split('.');\n    let current = obj;\n    for (const key of keys) {\n      if (current == null) return defaultValue;\n      current = current[key];\n    }\n    return current === undefined ? defaultValue : current;\n  } catch (e) {\n    log('WARN', `safeGet error on \"${path}\"`, { error: e.message });\n    return defaultValue;\n  }\n}\n\nfunction isEmpty(value) {\n  if (value === null || value === undefined) return true;\n  if (typeof value === 'string' && value.trim() === '') return true;\n  if (Array.isArray(value) && value.length === 0) return true;\n  if (typeof value === 'object' && Object.keys(value).length === 0) return true;\n  return false;\n}\n\n/* ===================== TIMEZONE HELPERS ===================== */\n\n// Cache de formatters para evitar recreaci√≥n\nconst _formattersCache = new Map();\n\nfunction getCachedFormatter(options, tz) {\n  const key = JSON.stringify({ ...options, tz });\n  let formatter = _formattersCache.get(key);\n  \n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat('es-MX', { \n      timeZone: tz, \n      ...options \n    });\n    _formattersCache.set(key, formatter);\n  }\n  \n  return formatter;\n}\n\nfunction getLocalParts(date, tz) {\n  const formatter = getCachedFormatter({\n    year: 'numeric', month: '2-digit', day: '2-digit',\n    hour: '2-digit', minute: '2-digit', second: '2-digit', \n    hour12: false\n  }, tz);\n  \n  const parts = formatter.formatToParts(date).reduce((acc, part) => {\n    acc[part.type] = part.value;\n    return acc;\n  }, {});\n  \n  return {\n    y: +parts.year, m: +parts.month, d: +parts.day,\n    hh: +parts.hour, mm: +parts.minute, ss: +parts.second\n  };\n}\n\nfunction localToUTC(y, m, d, hh = 0, mm = 0, ss = 0, tz) {\n  const formatter = getCachedFormatter({\n    year: 'numeric', month: '2-digit', day: '2-digit',\n    hour: '2-digit', minute: '2-digit', second: '2-digit',\n    hour12: false\n  }, tz);\n  \n  const naive = Date.UTC(y, m - 1, d, hh, mm, ss);\n  const seen = getLocalParts(new Date(naive), tz);\n  const seenMs = Date.UTC(seen.y, seen.m - 1, seen.d, seen.hh, seen.mm, seen.ss);\n  \n  return naive - (seenMs - naive);\n}\n\nfunction ymdLocal(iso, tz) {\n  const parts = getLocalParts(new Date(iso), tz);\n  return `${parts.y}-${String(parts.m).padStart(2, '0')}-${String(parts.d).padStart(2, '0')}`;\n}\n\nfunction hmLocal(iso, tz) {\n  const parts = getLocalParts(new Date(iso), tz);\n  return `${String(parts.hh).padStart(2, '0')}:${String(parts.mm).padStart(2, '0')}`;\n}\n\nfunction formatLocal(iso, tz) {\n  const formatter = getCachedFormatter({\n    hour12: false,\n    year: 'numeric', month: '2-digit', day: '2-digit',\n    hour: '2-digit', minute: '2-digit'\n  }, tz);\n  return formatter.format(new Date(iso));\n}\n\n/* ===================== INTERVAL OPERATIONS ===================== */\n\nfunction isAlignedLocal(iso, anchors, tz) {\n  const parts = getLocalParts(new Date(iso), tz);\n  return anchors.includes(parts.mm);\n}\n\nfunction alignUpLocal(iso, anchors, tz) {\n  const parts = getLocalParts(new Date(iso), tz);\n  const sorted = [...anchors].sort((a, b) => a - b);\n  \n  if (sorted.includes(parts.mm)) {\n    return new Date(localToUTC(parts.y, parts.m, parts.d, parts.hh, parts.mm, 0, tz)).toISOString();\n  }\n  \n  const next = sorted.find(a => a > parts.mm);\n  let hh = parts.hh;\n  let mm = next !== undefined ? next : sorted[0];\n  \n  if (next === undefined) {\n    hh = (hh + 1) % 24;\n  }\n  \n  return new Date(localToUTC(parts.y, parts.m, parts.d, hh, mm, 0, tz)).toISOString();\n}\n\nfunction alignDownLocal(iso, anchors, tz) {\n  const parts = getLocalParts(new Date(iso), tz);\n  const sorted = [...anchors].sort((a, b) => a - b);\n  \n  if (sorted.includes(parts.mm)) {\n    return new Date(localToUTC(parts.y, parts.m, parts.d, parts.hh, parts.mm, 0, tz)).toISOString();\n  }\n  \n  const prev = [...sorted].reverse().find(a => a < parts.mm);\n  let hh = parts.hh;\n  let mm = prev !== undefined ? prev : sorted[sorted.length - 1];\n  \n  if (prev === undefined) {\n    hh = (hh + 24 - 1) % 24;\n  }\n  \n  return new Date(localToUTC(parts.y, parts.m, parts.d, hh, mm, 0, tz)).toISOString();\n}\n\nfunction cropToWindow(interval, startISO, endISO) {\n  const s = (startISO && interval.start < startISO) ? startISO : interval.start;\n  const e = (endISO && interval.end > endISO) ? endISO : interval.end;\n  return (s < e) ? { start: s, end: e } : null;\n}\n\nfunction mergeExclusive(list, mergeTouching = true) {\n  if (!list || !list.length) return [];\n  \n  const sorted = [...list].sort((a, b) => {\n    const cmp = a.start.localeCompare(b.start);\n    return cmp !== 0 ? cmp : a.end.localeCompare(b.end);\n  });\n  \n  const merged = [{ start: sorted[0].start, end: sorted[0].end }];\n  \n  for (let i = 1; i < sorted.length; i++) {\n    const last = merged[merged.length - 1];\n    const current = sorted[i];\n    \n    const overlaps = current.start < last.end;\n    const touches = mergeTouching && current.start === last.end;\n    \n    if (overlaps || touches) {\n      if (current.end > last.end) {\n        last.end = current.end;\n      }\n    } else {\n      merged.push({ start: current.start, end: current.end });\n    }\n  }\n  \n  return merged;\n}\n\n/* ===================== HASH FUNCTIONS ===================== */\n\nfunction djb2Hash(str) {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) + hash) + str.charCodeAt(i);\n  }\n  return 'H' + (hash >>> 0).toString(36);\n}\n\n/* ===================== SEDE MANAGEMENT ===================== */\n\nfunction loadSedesFromSchedule() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function')\n      ? $getWorkflowStaticData('global')\n      : this.getWorkflowStaticData('global');\n\n    const SCHEDULE = store.SCHEDULE;\n\n    if (SCHEDULE?.sedes) {\n      const sedes = Object.keys(SCHEDULE.sedes);\n      log('SUCCESS', 'Sedes cargadas desde SCHEDULE', {\n        sedes,\n        version: store.SCHEDULE_VERSION\n      });\n      return {\n        sedes,\n        source: 'schedule',\n        version: store.SCHEDULE_VERSION\n      };\n    }\n    \n    log('WARN', 'SCHEDULE.sedes no disponible, usando fallback');\n  } catch (e) {\n    log('WARN', 'Error cargando sedes desde SCHEDULE', { error: e.message });\n  }\n  \n  // Fallback\n  return {\n    sedes: ['POLANCO', 'SATELITE'],\n    source: 'fallback'\n  };\n}\n\n/* ===================== CONTEXT LOADING ===================== */\n\nfunction loadContext() {\n  let ctx = {};\n  let requestId = `combine-${Date.now()}`;\n  \n  try {\n    const setDefaultsItems = $('SET_DEFAULTS').all();\n    \n    if (setDefaultsItems && setDefaultsItems.length > 0) {\n      ctx = setDefaultsItems[0].json || {};\n      \n      if (ctx?.kind !== 'context') {\n        log('WARN', 'SET_DEFAULTS no retorn√≥ context v√°lido', { kind: ctx?.kind });\n        ctx = {};\n      } else {\n        if (ctx.requestId) requestId = ctx.requestId;\n        \n        log('SUCCESS', 'Context cargado desde SET_DEFAULTS', {\n          windowStart: ctx.windowStart,\n          windowEnd: ctx.windowEnd,\n          requestId,\n          tz: ctx.tz,\n          maxResults: ctx.maxResults\n        });\n      }\n    } else {\n      log('WARN', 'No se encontr√≥ SET_DEFAULTS');\n    }\n  } catch (err) {\n    log('ERROR', 'Error obteniendo SET_DEFAULTS', { error: err.message });\n  }\n  \n  return { ctx, requestId };\n}\n\nfunction loadScheduleGate() {\n  let gate = {};\n  \n  try {\n    const gateItems = $('SCHEDULE_GATE1').all();\n    \n    if (gateItems && gateItems.length > 0) {\n      gate = gateItems[0].json || {};\n      \n      if (gate?.kind !== 'scheduleGate') {\n        log('WARN', 'SCHEDULE_GATE no retorn√≥ respuesta v√°lida', { kind: gate?.kind });\n        gate = {};\n      } else {\n        log('SUCCESS', 'SCHEDULE_GATE cargado', {\n          hasAllowed: gate.allowed?.length || 0,\n          hasSlots: gate.allowedSlots?.length || 0\n        });\n      }\n    } else {\n      log('WARN', 'No se encontr√≥ SCHEDULE_GATE');\n    }\n  } catch (err) {\n    log('ERROR', 'Error obteniendo SCHEDULE_GATE', { error: err.message });\n  }\n  \n  return gate;\n}\n\n/* ===================== BUSY INTERVALS PROCESSING ===================== */\n\nfunction extractBusyIntervals(rawItems, SEDES, windowStartISO, windowEndISO) {\n  const groups = Object.fromEntries(SEDES.map(s => [s, []]));\n  const sources = Object.fromEntries(SEDES.map(s => [s, { ok: false }]));\n  \n  const busyInputs = rawItems.filter(j => j && j.kind === 'busy');\n  \n  for (const busyItem of busyInputs) {\n    const sedeRaw = busyItem.sede ? String(busyItem.sede).toUpperCase() : null;\n    \n    const applyIntervals = (sede, intervals = []) => {\n      for (const interval of intervals) {\n        if (!interval?.start || !interval?.end || !(interval.start < interval.end)) {\n          continue;\n        }\n        \n        // Skip intervals outside window\n        if (windowStartISO && interval.end <= windowStartISO) continue;\n        if (windowEndISO && interval.start >= windowEndISO) continue;\n        \n        const clipped = cropToWindow(interval, windowStartISO, windowEndISO);\n        if (clipped) {\n          groups[sede].push({ start: clipped.start, end: clipped.end });\n        }\n      }\n    };\n    \n    // Procesar busy directo por sede\n    if (sedeRaw && SEDES.includes(sedeRaw)) {\n      // ‚úÖ Actualizar status solo si a√∫n no est√° OK\n      if (sources[sedeRaw].ok !== true) {\n        sources[sedeRaw] = busyItem.sourceStatus || { \n          ok: true, \n          reason: 'present_no_status' \n        };\n      }\n      applyIntervals(sedeRaw, busyItem.busy);\n    }\n    \n    // Procesar busyBySede (m√∫ltiples sedes en un item)\n    if (busyItem.busyBySede && typeof busyItem.busyBySede === 'object') {\n      for (const sede of SEDES) {\n        const intervals = busyItem.busyBySede[sede];\n        if (!Array.isArray(intervals) || !intervals.length) continue;\n        \n        // Skip si ya procesamos esta sede con busy directo\n        if (sede === sedeRaw && busyItem.busy && busyItem.busy.length) continue;\n        \n        if (sources[sede].ok !== true) {\n          sources[sede] = busyItem.sourceStatus || { \n            ok: true, \n            reason: 'present_no_status' \n          };\n        }\n        \n        applyIntervals(sede, intervals);\n      }\n    }\n  }\n  \n  return { groups, sources };\n}\n\n/* ===================== SLOT PROCESSING ===================== */\n\nfunction processAllowedSlots(gate, ctx, SEDES, ANCHORS, STEP, TZ, windowStartISO, windowEndISO, dayWhitelist) {\n  let allowedSlots = [];\n  \n  const allowedBands = Array.isArray(gate.allowed) ? gate.allowed : [];\n  const allowedSlotsFromGate = Array.isArray(gate.allowedSlots) ? gate.allowedSlots : [];\n  \n  // Ruta 1: Slots pre-generados desde SCHEDULE_GATE\n  if (allowedSlotsFromGate.length) {\n    allowedSlots = allowedSlotsFromGate\n      .map(s => ({\n        ...s,\n        sede: String(s.sede || '').toUpperCase(),\n        twHit: typeof s.twHit === 'boolean' ? s.twHit : undefined\n      }))\n      .filter(s => SEDES.includes(s.sede));\n      \n    log('INFO', 'Usando slots pre-generados de SCHEDULE_GATE', { \n      count: allowedSlots.length \n    });\n  }\n  // Ruta 2: Generar desde bands\n  else if (allowedBands.length) {\n    const stepMs = STEP * 60000;\n    \n    for (const band of allowedBands) {\n      const sede = String(band.sede || '').toUpperCase();\n      if (!SEDES.includes(sede) || !band.start || !band.end) continue;\n      \n      const bandStartISO = alignUpLocal(band.start, ANCHORS, TZ);\n      const bandEndISO = alignDownLocal(band.end, ANCHORS, TZ);\n      \n      let t = new Date(bandStartISO).getTime();\n      const end = new Date(bandEndISO).getTime();\n      \n      if (t >= end) continue;\n      \n      while (t < end) {\n        const next = t + stepMs;\n        const startISO = new Date(t).toISOString();\n        const endISO = new Date(next).toISOString();\n        \n        allowedSlots.push({\n          sede,\n          start: startISO,\n          end: endISO,\n          label: band.label || null,\n          weekType: band.weekType || null,\n          startLocal: formatLocal(startISO, TZ),\n          endLocal: formatLocal(endISO, TZ),\n          startHM: hmLocal(startISO, TZ),\n          dayKey: ymdLocal(startISO, TZ),\n          dow: new Date(startISO).getUTCDay(),\n          durationMinutes: STEP\n        });\n        \n        t = next;\n      }\n    }\n    \n    log('INFO', 'Slots generados desde bands', { count: allowedSlots.length });\n  }\n  \n  // Filtrado y deduplicaci√≥n\n  if (allowedSlots.length) {\n    const seen = new Set();\n    \n    const inWindow = s =>\n      (!windowStartISO || s.start >= windowStartISO) &&\n      (!windowEndISO || s.end <= windowEndISO);\n    \n    const inDayWhitelist = s =>\n      !dayWhitelist || dayWhitelist.has(ymdLocal(s.start, TZ));\n    \n    const onGrid = s =>\n      isAlignedLocal(s.start, ANCHORS, TZ) &&\n      isAlignedLocal(s.end, ANCHORS, TZ) &&\n      Math.abs((new Date(s.end) - new Date(s.start)) / 60000 - STEP) <= 0.5;\n    \n    allowedSlots = allowedSlots\n      .filter(s => onGrid(s) && inWindow(s) && inDayWhitelist(s))\n      .filter(s => {\n        const key = `${s.sede}|${s.start}|${s.end}`;\n        if (seen.has(key)) return false;\n        seen.add(key);\n        return true;\n      })\n      .sort((a, b) => {\n        const cmp = a.start.localeCompare(b.start);\n        return cmp !== 0 ? cmp : a.sede.localeCompare(b.sede);\n      });\n  }\n  \n  return allowedSlots;\n}\n\n/* ===================== VERIFICATION ===================== */\n\nfunction verifySedesAndFilter(allowedSlots, sources, policy, SEDES) {\n  // ‚úÖ NUEVO: Determinar sedes verificadas basado en datos reales\n  const busyCountsBySede = Object.fromEntries(\n    SEDES.map(s => {\n      const source = sources[s];\n      // Una sede est√° verificada si:\n      // 1. Tiene sourceStatus.ok === true, O\n      // 2. Tiene busy intervals (aunque sea 0, confirma que el calendario respondi√≥)\n      const isVerified = source?.ok === true;\n      return [s, isVerified];\n    })\n  );\n  \n  const verifiedSedes = SEDES.filter(s => busyCountsBySede[s]);\n  const skippedSedes = SEDES.filter(s => !busyCountsBySede[s]);\n  \n  log('INFO', 'Verificaci√≥n de sedes', {\n    verified: verifiedSedes,\n    skipped: skippedSedes,\n    filterEnabled: policy.filterToVerifiedSedes\n  });\n  \n  // ‚úÖ CAMBIO CR√çTICO: Aplicar filtro si est√° habilitado\n  let filteredSlots = allowedSlots;\n  \n  if (policy.filterToVerifiedSedes) {\n    const beforeCount = allowedSlots.length;\n    filteredSlots = allowedSlots.filter(s => verifiedSedes.includes(s.sede));\n    \n    if (beforeCount !== filteredSlots.length) {\n      log('WARN', 'Slots filtrados por sedes no verificadas', {\n        before: beforeCount,\n        after: filteredSlots.length,\n        removed: beforeCount - filteredSlots.length,\n        skippedSedes\n      });\n    }\n  }\n  \n  // ‚úÖ NUEVO: Validaci√≥n adicional si requireBusyData est√° activo\n  if (policy.requireBusyData && verifiedSedes.length === 0) {\n    log('ERROR', 'Ninguna sede tiene datos verificados', {\n      policy: policy,\n      sources: sources\n    });\n  }\n  \n  const degraded = skippedSedes.length > 0;\n  \n  return {\n    filteredSlots,\n    verifiedSedes,\n    skippedSedes,\n    degraded\n  };\n}\n\n/* ===================== MAIN EXECUTION ===================== */\n\ntry {\n  const startTime = Date.now();\n  log('INFO', `COMBINE_BUSY v${VERSION} iniciando`);\n  \n  // 1. Cargar inputs\n  const rawItems = $input.all().map(x => x.json);\n  const { ctx, requestId } = loadContext();\n  const sedesData = loadSedesFromSchedule();\n  const SEDES = sedesData.sedes;\n  const gate = loadScheduleGate();\n  \n  // 2. Determinar par√°metros efectivos\n  const TZ = ctx.tz || 'America/Mexico_City';\n  const windowStartISO = ctx.windowStart || null;\n  const windowEndISO = ctx.windowEnd || null;\n  \n  // Config desde gate/context/schedule\n  const gridFromGate = gate?.meta?.grid || {};\n  const stepFromGate = Number.isFinite(gridFromGate.stepMinutes) \n    ? gridFromGate.stepMinutes \n    : undefined;\n  const anchorsFromGate = Array.isArray(gridFromGate.anchors) \n    ? gridFromGate.anchors \n    : undefined;\n  \n  const scheduleCfg = (ctx.scheduleMetadata && ctx.scheduleMetadata.config) || {};\n  const stepFromSchedule = Number.isFinite(scheduleCfg.consultationDuration)\n    ? scheduleCfg.consultationDuration\n    : undefined;\n  const anchorsFromSchedule = Array.isArray(scheduleCfg.slotAnchors)\n    ? scheduleCfg.slotAnchors\n    : undefined;\n  \n  const stepFromConstraints = Number.isFinite(ctx.constraints?.slotMinutes)\n    ? ctx.constraints.slotMinutes\n    : undefined;\n  \n  const STEP = Math.max(10, Math.min(120, \n    stepFromGate ?? stepFromSchedule ?? stepFromConstraints ?? 30\n  ));\n  \n  const rawAnchors = anchorsFromGate ?? anchorsFromSchedule ?? [0, 30];\n  let ANCHORS = Array.from(\n    new Set(\n      rawAnchors\n        .map(Number)\n        .filter(n => Number.isFinite(n) && n >= 0 && n < 60)\n    )\n  ).sort((a, b) => a - b);\n  \n  if (!ANCHORS.length) ANCHORS = [0, 30];\n  \n  // 3. Day whitelist\n  let dayWhitelist = null;\n  if (ctx?.filters?.dayWhitelist && Array.isArray(ctx.filters.dayWhitelist)) {\n    dayWhitelist = new Set(ctx.filters.dayWhitelist);\n  } else if (\n    (ctx?.policyHints?.hasExplicitDate ||\n     ctx?.search?.intent === 'specific_day' ||\n     ctx?.search?.intent === 'explicit_range') &&\n    Number(ctx?.windowDays) === 1 &&\n    windowStartISO\n  ) {\n    dayWhitelist = new Set([ymdLocal(windowStartISO, TZ)]);\n  }\n  \n  // 4. Pol√≠tica efectiva con defaults mejorados\n  const policy = { \n    ...POLICY_DEFAULTS, \n    ...(ctx.policy || {}) \n  };\n  \n  log('INFO', 'Configuraci√≥n efectiva', {\n    TZ, STEP, ANCHORS, policy,\n    windowStart: windowStartISO,\n    windowEnd: windowEndISO\n  });\n  \n  // 5. Extraer y procesar busy intervals\n  const { groups, sources } = extractBusyIntervals(\n    rawItems, SEDES, windowStartISO, windowEndISO\n  );\n  \n  // 6. Merge busy por sede\n  const busyBySede = Object.fromEntries(\n    SEDES.map(s => [s, mergeExclusive(groups[s], policy.mergeTouching)])\n  );\n  \n  const hashBusyBySede = Object.fromEntries(\n    SEDES.map(s => [s, djb2Hash(JSON.stringify(busyBySede[s] || []))])\n  );\n  \n  const hashBusy = djb2Hash(JSON.stringify(hashBusyBySede));\n  \n  // 7. Procesar allowed slots\n  let allowedSlots = processAllowedSlots(\n    gate, ctx, SEDES, ANCHORS, STEP, TZ, \n    windowStartISO, windowEndISO, dayWhitelist\n  );\n  \n  // 8. ‚úÖ NUEVO: Verificar sedes y filtrar\n  const verification = verifySedesAndFilter(\n    allowedSlots, sources, policy, SEDES\n  );\n  \n  let finalSlots = verification.filteredSlots;\n  \n  // 9. Aplicar maxResults\n  if (ctx.maxResults && typeof ctx.maxResults === 'number' && ctx.maxResults > 0) {\n    const originalCount = finalSlots.length;\n    finalSlots = finalSlots.slice(0, ctx.maxResults);\n    \n    if (originalCount > finalSlots.length) {\n      log('INFO', 'maxResults aplicado', {\n        original: originalCount,\n        final: finalSlots.length\n      });\n    }\n  }\n  \n  // 10. Formato de salida local\n  const busyBySedeLocal = Object.fromEntries(\n    SEDES.map(s => [\n      s,\n      (busyBySede[s] || []).map(iv => ({\n        start: iv.start,\n        end: iv.end,\n        startLocal: formatLocal(iv.start, TZ),\n        endLocal: formatLocal(iv.end, TZ)\n      }))\n    ])\n  );\n  \n  // 11. Off-grid detection\n  const offGridBusy = Object.fromEntries(\n    SEDES.map(s => [\n      s,\n      (busyBySede[s] || []).filter(\n        iv => !isAlignedLocal(iv.start, ANCHORS, TZ) || \n              !isAlignedLocal(iv.end, ANCHORS, TZ)\n      ).length\n    ])\n  );\n  \n  // 12. Whitelist y hashes\n  const slotKey = s => `${s.sede}|${s.start}|${s.end}`;\n  const slotWhitelist = finalSlots.map(slotKey);\n  const hashAllowedSlots = djb2Hash(JSON.stringify(finalSlots));\n  const hashWhitelist = djb2Hash(slotWhitelist.join(','));\n  \n  // 13. M√©tricas\n  const busyCountsBySede = Object.fromEntries(\n    SEDES.map(s => [s, (busyBySede[s] || []).length])\n  );\n  \n  const totals = {\n    busyBlocks: {\n      all: Object.values(busyCountsBySede).reduce((a, b) => a + b, 0),\n      ...busyCountsBySede\n    },\n    allowedSlots: finalSlots.length\n  };\n  \n  const metrics = {\n    allowedBySede: finalSlots.reduce((acc, s) => {\n      acc[s.sede] = (acc[s.sede] || 0) + 1;\n      return acc;\n    }, {}),\n    twHitCount: finalSlots.filter(s => s.twHit === true).length,\n    hashBusyBySede,\n    maxResultsApplied: !!(ctx.maxResults && allowedSlots.length > ctx.maxResults),\n    filteredByVerification: allowedSlots.length !== finalSlots.length\n  };\n  \n  // 14. Resultado final\n  const result = {\n    kind: 'busy_combined',\n    \n    build: {\n      version: VERSION,\n      generatedAt: new Date().toISOString(),\n      scheduleVersion: sedesData.version,\n      sedesSource: sedesData.source\n    },\n    \n    requestId,\n    ctx,\n    \n    scheduleGate: {\n      decision: gate.decision || null,\n      notes: gate.notes || null,\n      meta: gate.meta || null,\n      allowed: Array.isArray(gate.allowed) ? gate.allowed : [],\n      allowedSlots: finalSlots\n    },\n    \n    busyBySede,\n    busyBySedeLocal,\n    offGridBusy,\n    hashBusy,\n    \n    // ‚úÖ NUEVO: Informaci√≥n de verificaci√≥n\n    coverage: {\n      verifiedSedes: verification.verifiedSedes,\n      skippedSedes: verification.skippedSedes\n    },\n    degraded: verification.degraded,\n    sources,\n    \n    totals,\n    metrics,\n    \n    slotWhitelist,\n    hashAllowedSlots,\n    hashWhitelist,\n    \n    policy: {\n      strictVerification: policy.strictVerification,\n      neverInventTimes: true,\n      mergeTouching: policy.mergeTouching,\n      filterToVerifiedSedes: policy.filterToVerifiedSedes,\n      requireBusyData: policy.requireBusyData\n    },\n    \n    debugLocal: {\n      tz: TZ,\n      anchors: ANCHORS,\n      step: STEP,\n      sedes: SEDES,\n      sedesSource: sedesData.source\n    },\n    \n    _logs: DEBUG ? LOGS : undefined\n  };\n  \n  const executionTime = Date.now() - startTime;\n  \n  log('SUCCESS', `COMBINE_BUSY v${VERSION} completado`, {\n    executionMs: executionTime,\n    totalSlots: finalSlots.length,\n    verifiedSedes: verification.verifiedSedes.length,\n    degraded: verification.degraded\n  });\n  \n  return [{\n    json: result,\n    pairedItem: $input.all().map((_, i) => ({ item: i }))\n  }];\n\n} catch (err) {\n  log('ERROR', 'Error fatal en COMBINE_BUSY', {\n    error: err.message,\n    stack: err.stack\n  });\n  \n  return [{\n    json: {\n      kind: 'error',\n      error: 'COMBINE_FAIL',\n      message: String(err && err.message || err),\n      stack: DEBUG ? err.stack : undefined,\n      logs: DEBUG ? LOGS : undefined\n    }\n  }];\n}"
      },
      "id": "e6fa56b2-5bd8-408a-af8c-80bafe6aa130",
      "name": "Combine Busy1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * CALC_AVAILABILITY v9.1.0 ‚Äî Consume COMBINE_BUSY con TZ consistente CDMX\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * Cambios vs v9.0:\n * - Introduce DEFAULT_TZ = 'America/Mexico_City'.\n * - Usa ctx.tz (o debugLocal.tz de COMBINE_BUSY) para calcular hora local y DOW.\n * - Ranking basado en hora local usando Intl.DateTimeFormat('es-MX', { timeZone: tz }).\n * - DEBUG desactivado por defecto para producci√≥n.\n */\n\nconst VERSION = '9.1.0';\nconst DEBUG = false;\nconst DEFAULT_TZ = 'America/Mexico_City';\n\n// ==================== OBTENER DATOS DE COMBINE_BUSY ====================\nfunction getCombineBusyData() {\n  try {\n    const items = $input.all();\n    const busyItem = items.find((it) => it?.json?.kind === 'busy_combined');\n\n    if (busyItem?.json) {\n      if (DEBUG) {\n        console.log('‚úÖ COMBINE_BUSY data encontrado', {\n          hasAllowedSlots: busyItem.json?.scheduleGate?.allowedSlots?.length || 0,\n          requestId: busyItem.json?.requestId,\n        });\n      }\n      return busyItem.json;\n    }\n\n    console.warn('‚ö†Ô∏è No se encontr√≥ item con kind=busy_combined en $input');\n  } catch (e) {\n    console.error('‚ùå Error obteniendo COMBINE_BUSY:', e.message);\n  }\n\n  // Fallback seguro\n  return {\n    kind: 'busy_combined',\n    ctx: {},\n    scheduleGate: {\n      allowedSlots: [],\n      decision: { isOpen: false, reason: 'No data from COMBINE_BUSY' },\n    },\n    requestId: `calc-${Date.now()}`,\n    build: { version: 'unknown', generatedAt: new Date().toISOString() },\n  };\n}\n\n// ==================== HELPERS LOCAL TIME ====================\n\n// Obtiene {hour, minute} en horario local de la sede\nfunction getLocalHM(slot, tz) {\n  // 1) startHM ya viene local desde SCHEDULE_GATE/COMBINE_BUSY\n  if (typeof slot.startHM === 'string' && /^\\d{2}:\\d{2}$/.test(slot.startHM)) {\n    const [h, m] = slot.startHM.split(':').map(Number);\n    return { hour: h, minute: m };\n  }\n\n  // 2) Intentar parsear HH:MM al final de startLocal (ej: \"lunes, 10/11/2025, 09:00\")\n  if (typeof slot.startLocal === 'string') {\n    const m = /(\\d{2}):(\\d{2})$/.exec(slot.startLocal);\n    if (m) return { hour: Number(m[1]), minute: Number(m[2]) };\n  }\n\n  // 3) Fallback: usar Intl con tz sobre slot.start\n  if (slot.start) {\n    const dtf = new Intl.DateTimeFormat('es-MX', {\n      timeZone: tz,\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: false,\n    });\n    const parts = dtf.formatToParts(new Date(slot.start));\n    const h = Number(parts.find((p) => p.type === 'hour')?.value || '0');\n    const m = Number(parts.find((p) => p.type === 'minute')?.value || '0');\n    return { hour: h, minute: m };\n  }\n\n  // 4) √öltimo recurso\n  return { hour: 0, minute: 0 };\n}\n\n// Obtiene DOW (0..6) preferentemente desde slot.dow, fallback con tz\nfunction getDow(slot, tz) {\n  if (slot.dow != null) return slot.dow;\n\n  if (slot.start) {\n    try {\n      const dtf = new Intl.DateTimeFormat('en-US', {\n        timeZone: tz,\n        weekday: 'short',\n      });\n      const name = dtf.format(new Date(slot.start)); // Sun, Mon, ...\n      const map = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\n      if (map[name] != null) return map[name];\n    } catch (e) {\n      // no-op, fallback abajo\n    }\n    return new Date(slot.start).getUTCDay();\n  }\n\n  return null;\n}\n\n// ==================== RANKING ====================\nfunction rankSlots(slots, ctx, tz) {\n  if (!Array.isArray(slots) || slots.length === 0) return [];\n\n  return slots\n    .map((slot) => {\n      let score = 0;\n\n      // Hora/minuto local\n      const { hour: hourLocal, minute: minuteLocal } = getLocalHM(slot, tz);\n      const dow = getDow(slot, tz);\n\n      // ‚úÖ 1) Preferencia por horas locales\n      if (hourLocal >= 9 && hourLocal <= 11) {\n        score += 3; // ma√±ana media\n      } else if (hourLocal >= 8 && hourLocal < 9) {\n        score += 2; // temprano\n      } else if (hourLocal >= 14 && hourLocal <= 16) {\n        score += 2; // tarde temprana\n      } else {\n        score += 1; // otros\n      }\n\n      // ‚úÖ 2) Sede preferida\n      if (\n        ctx?.sedePreferida &&\n        String(ctx.sedePreferida).toUpperCase() === String(slot.sede).toUpperCase()\n      ) {\n        score += 5;\n      }\n\n      // ‚úÖ 3) TimeWindow hit (si upstream marc√≥)\n      if (slot.twHit === true) {\n        score += 4;\n      }\n\n      // ‚úÖ 4) Proximidad temporal (independiente de tz porque usa epoch)\n      if (slot.start) {\n        const daysAway = Math.floor((new Date(slot.start) - Date.now()) / 86_400_000);\n        if (Number.isFinite(daysAway)) {\n          if (daysAway <= 2) score += 2;\n          else if (daysAway <= 5) score += 1;\n        }\n      }\n\n      // ‚úÖ 5) Penalizar s√°bados ligeramente\n      if (dow === 6) score -= 1;\n\n      // ‚úÖ 6) Bonus :00\n      if (minuteLocal === 0) score += 0.5;\n\n      // ‚úÖ 7) WeekType (bonus ligero para A)\n      if (slot.weekType === 'A') score += 0.3;\n\n      return {\n        ...slot,\n        label: slot.label || slot.shiftLabel || slot.title || null,\n        _score: Number(score.toFixed(2)),\n      };\n    })\n    .sort((a, b) => {\n      if (b._score !== a._score) return b._score - a._score;\n      return new Date(a.start) - new Date(b.start);\n    });\n}\n\n// ==================== MAIN ====================\ntry {\n  const startTime = Date.now();\n  if (DEBUG) console.log('üöÄ CALC_AVAILABILITY v9.1.0 iniciando...');\n\n  // 1) Obtener datos de COMBINE_BUSY\n  const combineBusy = getCombineBusyData();\n  const ctx = combineBusy.ctx || {};\n  const requestId = combineBusy.requestId || ctx.requestId || `calc-${Date.now()}`;\n\n  // TZ efectivo: contexto ‚Üí debugLocal ‚Üí CDMX por defecto\n  const tz =\n    ctx.tz ||\n    combineBusy.debugLocal?.tz ||\n    DEFAULT_TZ;\n\n  // 2) Extraer slots YA filtrados por SCHEDULE_GATE + COMBINE_BUSY\n  const allowedSlots = Array.isArray(combineBusy?.scheduleGate?.allowedSlots)\n    ? combineBusy.scheduleGate.allowedSlots\n    : [];\n\n  if (DEBUG) {\n    console.log('üìä Input data:', {\n      requestId,\n      tz,\n      allowedSlots: allowedSlots.length,\n      sedes: [...new Set(allowedSlots.map((s) => s.sede))],\n      windowStart: ctx.windowStart,\n      windowEnd: ctx.windowEnd,\n    });\n  }\n\n  // 3) Si no hay slots ‚Üí salida temprana\n  if (allowedSlots.length === 0) {\n    const gateDecision = combineBusy.scheduleGate?.decision || null;\n\n    return [\n      {\n        json: {\n          kind: 'avail',\n          version: VERSION,\n          requestId,\n          tz,\n          allowedSlots: [],\n          summary: {\n            totalAvailable: 0,\n            bySede: {},\n            byDay: {},\n            firstAvailable: null,\n          },\n          message: gateDecision?.reason || 'No hay slots disponibles en la ventana solicitada',\n          gateDecision,\n          metrics: {\n            executionTimeMs: Date.now() - startTime,\n            inputSlots: 0,\n            rankedSlots: 0,\n            finalReturned: 0,\n          },\n          build: {\n            version: VERSION,\n            generatedAt: new Date().toISOString(),\n            combineBusyVersion: combineBusy.build?.version,\n            scheduleVersion: combineBusy.build?.scheduleVersion,\n          },\n          timestamp: new Date().toISOString(),\n        },\n      },\n    ];\n  }\n\n  // 4) Ranking/scoring\n  if (DEBUG) console.log('üéØ Aplicando ranking con tz:', tz);\n  const ranked = rankSlots(allowedSlots, ctx, tz);\n\n  // 5) maxResults del context (fallback 50)\n  const MAX_OUTPUT_SLOTS = 50;\n  const limit = Number.isFinite(Number(ctx.maxResults)) ? Number(ctx.maxResults) : MAX_OUTPUT_SLOTS;\n  const topK = ranked.slice(0, Math.max(0, limit));\n\n  if (DEBUG) console.log(`üìã Resultados: ${ranked.length} rankeados, top ${topK.length} retornados`);\n\n  // 6) Summary\n  const summary = {\n    totalAvailable: ranked.length,\n    bySede: {},\n    byDay: {},\n    firstAvailable: topK[0]\n      ? {\n          start: topK[0].start,\n          startLocal: topK[0].startLocal || null,\n          sede: topK[0].sede,\n          label: topK[0].label || null,\n        }\n      : null,\n  };\n\n  for (const slot of ranked) {\n    summary.bySede[slot.sede] = (summary.bySede[slot.sede] || 0) + 1;\n    const dayKey = slot.dayKey || (slot.start ? String(slot.start).split('T')[0] : 'unknown');\n    summary.byDay[dayKey] = (summary.byDay[dayKey] || 0) + 1;\n  }\n\n  // 7) M√©tricas\n  const metrics = {\n    executionTimeMs: Date.now() - startTime,\n    inputSlots: allowedSlots.length,\n    rankedSlots: ranked.length,\n    finalReturned: topK.length,\n    limitApplied: limit,\n    maxResultsFromContext: !!ctx.maxResults,\n    topScore: topK[0]?._score || 0,\n    averageScore:\n      ranked.length > 0\n        ? Number((ranked.reduce((sum, s) => sum + s._score, 0) / ranked.length).toFixed(2))\n        : 0,\n  };\n\n  // 8) Output final\n  const output = {\n    kind: 'avail',\n    version: VERSION,\n    requestId,\n    tz,\n\n    allowedSlots: topK,\n    summary,\n    metrics,\n\n    query: ctx.originalInput || {},\n\n    filters: {\n      sedePreferida: ctx.sedePreferida || null,\n      timeWindow: ctx.timeWindow || null,\n      windowDays: ctx.windowDays || null,\n      onlyMorning: !!ctx.onlyMorning,\n      onlyAfternoon: !!ctx.onlyAfternoon,\n      includeWeekends: ctx.includeWeekends !== false,\n    },\n\n    gateDecision: combineBusy.scheduleGate?.decision || null,\n\n    build: {\n      version: VERSION,\n      generatedAt: new Date().toISOString(),\n      combineBusyVersion: combineBusy.build?.version,\n      scheduleVersion: combineBusy.build?.scheduleVersion,\n    },\n\n    timestamp: new Date().toISOString(),\n  };\n\n  if (DEBUG) {\n    console.log('‚úÖ CALC_AVAILABILITY v9.1.0 completado', {\n      topSlot: topK[0] ? `${topK[0].sede} ${topK[0].startLocal || topK[0].start}` : 'none',\n      score: topK[0]?._score,\n      executionMs: metrics.executionTimeMs,\n    });\n  }\n\n  return [{ json: output }];\n} catch (error) {\n  console.error('‚ùå Error en CALC_AVAILABILITY:', error);\n  return [\n    {\n      json: {\n        kind: 'error',\n        component: 'CALC_AVAILABILITY',\n        version: VERSION,\n        error: error.message || String(error),\n        stack: DEBUG ? error.stack : undefined,\n        timestamp: new Date().toISOString(),\n      },\n    },\n  ];\n}"
      },
      "id": "aa8ee999-c536-4e2f-a0ac-73db937b4a9e",
      "name": "Calc Availability1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * SCHEDULE_GATE v15.3.0 - Gate de agenda con SCHEDULE centralizado y filtros\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n *\n * Mejoras vs 15.2.x:\n * - Iteraci√≥n de d√≠as usa [windowStart, windowEnd) (sin off-by-one).\n * - slotDuration, anchors y shortNoticeMin vienen de CFG/context (no se re-lee SCHEDULE.config dentro).\n * - Respeta maxSlots desde SCHEDULE.config junto con ctx.maxResults.\n * - dow de cada slot es el DOW local (no UTC desfasado).\n * - Cachea formateador HH:MM por TZ (DTF_HM) para evitar recrearlo por slot.\n * - DEBUG desactivado por defecto; _logs s√≥lo cuando DEBUG = true.\n */\n\nconst VERSION = '15.3.0';\nconst DEBUG = false;\n\n// ==================== LOGGING ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'SCHEDULE_GATE',\n    version: VERSION,\n    message,\n    ...data,\n  };\n  LOGS.push(entry);\n  if (DEBUG) {\n    const emoji = {\n      INFO: '‚ÑπÔ∏è',\n      WARN: '‚ö†Ô∏è',\n      ERROR: '‚ùå',\n      DEBUG: 'üîç',\n      SUCCESS: '‚úÖ',\n    }[level.toUpperCase()] || 'üìù';\n    console.log(`${emoji} [${level.toUpperCase()}] ${message}`, data);\n  }\n}\n\n// ==================== TIMEZONE / DATE HELPERS ====================\nlet _formattersCache = {};\nfunction getFormatters(tz) {\n  if (!_formattersCache[tz]) {\n    _formattersCache[tz] = {\n      tz,\n      DTF_FULL: new Intl.DateTimeFormat('en-CA', {\n        timeZone: tz,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false,\n      }),\n      DTF_DISPLAY: new Intl.DateTimeFormat('es-MX', {\n        timeZone: tz,\n        weekday: 'long',\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      }),\n      DTF_HM: new Intl.DateTimeFormat('en-US', {\n        timeZone: tz,\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      }),\n    };\n  }\n  return _formattersCache[tz];\n}\n\nfunction getLocalParts(date, DTF_FULL) {\n  const parts = DTF_FULL.formatToParts(date);\n  const obj = {};\n  for (const p of parts) obj[p.type] = p.value;\n  return {\n    y: +obj.year,\n    m: +obj.month,\n    d: +obj.day,\n    hh: +obj.hour,\n    mm: +obj.minute,\n    ss: +obj.second,\n  };\n}\n\nfunction localToUTC(y, m, d, hh = 0, mm = 0, ss = 0, DTF_FULL) {\n  const naive = Date.UTC(y, m - 1, d, hh, mm, ss);\n  const asLocal = getLocalParts(new Date(naive), DTF_FULL);\n  const localEpoch = Date.UTC(\n    asLocal.y,\n    asLocal.m - 1,\n    asLocal.d,\n    asLocal.hh,\n    asLocal.mm,\n    asLocal.ss,\n  );\n  return naive - (localEpoch - naive);\n}\n\nfunction timeAtDay(date, hhmm, DTF_FULL) {\n  const [hh, mm] = hhmm.split(':').map(Number);\n  const p = getLocalParts(date, DTF_FULL);\n  return new Date(localToUTC(p.y, p.m, p.d, hh, mm, 0, DTF_FULL)).toISOString();\n}\n\nfunction formatLocal(iso, DTF_DISPLAY) {\n  return DTF_DISPLAY.format(new Date(iso));\n}\n\nfunction hhmmToMinutes(hhmm) {\n  const [h, m] = hhmm.split(':').map(Number);\n  return h * 60 + m;\n}\n\nfunction minutesToHHMM(mins) {\n  const h = Math.floor(mins / 60);\n  const m = mins % 60;\n  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;\n}\n\n// HH:MM local reutilizando DTF_HM cacheado\nfunction formatHHMM(iso, DTF_HM) {\n  const parts = DTF_HM.formatToParts(new Date(iso));\n  const hh = parts.find((p) => p.type === 'hour')?.value || '00';\n  const mm = parts.find((p) => p.type === 'minute')?.value || '00';\n  return `${hh}:${mm}`;\n}\n\n// ==================== VALIDACI√ìN & CONTEXT ====================\nfunction validateContextFromInput(item) {\n  if (!item?.json) {\n    return {\n      valid: false,\n      error: 'EMPTY_INPUT',\n      message: 'Entrada vac√≠a en SCHEDULE_GATE',\n    };\n  }\n  const ctx = item.json;\n  if (ctx.kind === 'error') {\n    return { valid: false, propagateError: true, originalError: ctx };\n  }\n  if (ctx.kind !== 'context') {\n    return {\n      valid: false,\n      error: 'INVALID_INPUT_KIND',\n      message: `Esperado kind='context', recibi√≥ '${ctx.kind || 'undefined'}'`,\n    };\n  }\n\n  const required = ['windowStart', 'windowEnd', 'tz'];\n  const missing = required.filter((f) => !ctx[f]);\n  if (missing.length) {\n    return {\n      valid: false,\n      error: 'MISSING_REQUIRED_FIELDS',\n      message: `Faltan campos: ${missing.join(', ')}`,\n    };\n  }\n\n  const startMs = new Date(ctx.windowStart).getTime();\n  const endMs = new Date(ctx.windowEnd).getTime();\n  if (isNaN(startMs) || isNaN(endMs) || startMs >= endMs) {\n    return {\n      valid: false,\n      error: 'INVALID_WINDOW',\n      message: 'windowStart/windowEnd inv√°lidos',\n    };\n  }\n\n  return { valid: true, ctx };\n}\n\n// ==================== FALLBACKS (si faltan HELPERS) ====================\nfunction computeWeekTypeFallback(dateKey, anchor) {\n  try {\n    const anchorDate = new Date(\n      anchor?.date ? `${anchor.date}T00:00:00Z` : '2025-01-06T00:00:00Z',\n    );\n    const d = new Date(`${dateKey}T00:00:00Z`);\n    const MS_PER_DAY = 86400000;\n    const days = Math.floor((d - anchorDate) / MS_PER_DAY);\n    const weeks = Math.floor(days / 7);\n    const anchorType = anchor?.type || 'A';\n    const isEven = weeks % 2 === 0; // pares = tipo anchor\n    return isEven ? anchorType : anchorType === 'A' ? 'B' : 'A';\n  } catch (e) {\n    log('WARN', 'computeWeekTypeFallback error', { dateKey, error: e.message });\n    return 'A';\n  }\n}\n\n// ==================== GENERACI√ìN DE SLOTS ====================\nfunction generateSlots(ctx, SCHEDULE, HELPERS, CFG, DTF_FULL, DTF_DISPLAY, DTF_HM) {\n  log('INFO', 'Iniciando generaci√≥n de slots', {\n    sedes: ctx.sedes,\n    sedePreferida: ctx.sedePreferida,\n  });\n\n  const windowStartMs = new Date(ctx.windowStart).getTime();\n  const windowEndMs = new Date(ctx.windowEnd).getTime();\n  const now = Date.now();\n\n  // shortNoticeMin: preferir constraints del contexto, luego CFG\n  const shortNoticeMin =\n    (ctx.constraints && ctx.constraints.shortNoticeMin) ?? CFG.SHORT_NOTICE_MIN;\n  const shortNoticeBuffer = now + shortNoticeMin * 60000;\n\n  const slotDurationMin =\n    (ctx.constraints && ctx.constraints.slotMinutes) ?? CFG.CONSULTATION_DURATION_MIN;\n  const slotDurationMs = slotDurationMin * 60000;\n  const anchors = CFG.ANCHORS;\n\n  // Determinar sedes a evaluar\n  let sedesToCheck =\n    Array.isArray(ctx.sedes) && ctx.sedes.length\n      ? ctx.sedes.slice()\n      : Object.keys(SCHEDULE.sedes || {});\n\n  if (ctx.sedePreferida) {\n    const normalized = HELPERS?.normalizeSede\n      ? HELPERS.normalizeSede(ctx.sedePreferida)\n      : ctx.sedePreferida;\n    if (normalized) sedesToCheck = [normalized];\n    log('INFO', 'Sede normalizada', {\n      original: ctx.sedePreferida,\n      normalized,\n    });\n  }\n\n  const includeWeekends = ctx.includeWeekends !== false; // default true\n  const onlyMorning = !!ctx.onlyMorning;\n  const onlyAfternoon = !!ctx.onlyAfternoon;\n  const tw = ctx.timeWindow || null; // {startMin, endMin}\n\n  const allowed = [];\n  const allowedSlots = [];\n  const skipped = {\n    weekends: 0,\n    restDay: 0,\n    noSchedule: 0,\n    wrongWeekType: 0,\n    morningFilter: 0,\n    afternoonFilter: 0,\n    timeWindow: 0,\n    shortNotice: 0,\n    outsideWindow: 0,\n    partialSlot: 0,\n    invalidGrid: 0,\n  };\n\n  const MS_PER_DAY = 86400000;\n  let totalSlotsGenerated = 0;\n\n  for (const sede of sedesToCheck) {\n    const sedeSchedule = (SCHEDULE.sedes || {})[sede];\n    if (!sedeSchedule) {\n      log('WARN', 'Sede no encontrada en SCHEDULE', { sede });\n      continue;\n    }\n\n    // Recorrer d√≠as: [windowStart, windowEnd)\n    for (\n      let currentMs = windowStartMs;\n      currentMs < windowEndMs;\n      currentMs += MS_PER_DAY\n    ) {\n      const currentDate = new Date(currentMs);\n      const p = getLocalParts(currentDate, DTF_FULL);\n      const localDate = new Date(Date.UTC(p.y, p.m - 1, p.d));\n      const dowLocal = localDate.getUTCDay(); // 0..6\n      const dateKey = `${p.y}-${String(p.m).padStart(2, '0')}-${String(\n        p.d,\n      ).padStart(2, '0')}`;\n\n      // 1) Fines de semana\n      if (!includeWeekends && (dowLocal === 0 || dowLocal === 6)) {\n        skipped.weekends++;\n        continue;\n      }\n\n      // 2) D√≠a de descanso general\n      if (SCHEDULE.rest && SCHEDULE.rest[dowLocal]) {\n        skipped.restDay++;\n        continue;\n      }\n\n      // 3) D√≠a laborable por sede\n      if (HELPERS?.isWorkingDay && !HELPERS.isWorkingDay(sede, dowLocal)) {\n        skipped.noSchedule++;\n        continue;\n      }\n\n      // Week type\n      const weekType = HELPERS?.getWeekType\n        ? HELPERS.getWeekType(dateKey, SCHEDULE.anchor)\n        : computeWeekTypeFallback(dateKey, SCHEDULE.anchor);\n\n      // Turnos del d√≠a\n      let shifts = HELPERS?.getShiftsForSedeAndDay\n        ? HELPERS.getShiftsForSedeAndDay(sede, dowLocal, weekType)\n        : null;\n      if (!shifts || !shifts.length) {\n        skipped.noSchedule++;\n        continue;\n      }\n\n      // Normalizar a objetos {start,end,label,weekType}\n      let normalizedShifts = shifts.map((s) =>\n        Array.isArray(s)\n          ? {\n              start: s[0],\n              end: s[1],\n              label: s[2] || `${s[0]}-${s[1]}`,\n              weekType,\n            }\n          : {\n              start: s.start,\n              end: s.end,\n              label: s.label || `${s.start}-${s.end}`,\n              weekType: s.weekType || weekType,\n            },\n      );\n\n      // 4) Filtro morning / afternoon\n      if (onlyMorning) {\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter(\n          (sh) => parseInt(sh.start.split(':')[0], 10) < 14,\n        );\n        skipped.morningFilter += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n      if (onlyAfternoon) {\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter(\n          (sh) => parseInt(sh.start.split(':')[0], 10) >= 14,\n        );\n        skipped.afternoonFilter += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n\n      // 5) Filtro por ventana horaria (overlap)\n      if (tw && (typeof tw.startMin === 'number' || typeof tw.endMin === 'number')) {\n        const reqStart = typeof tw.startMin === 'number' ? tw.startMin : 0;\n        const reqEnd = typeof tw.endMin === 'number' ? tw.endMin : 24 * 60;\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter((sh) => {\n          const sMin = hhmmToMinutes(sh.start);\n          const eMin = hhmmToMinutes(sh.end);\n          return sMin < reqEnd && eMin > reqStart; // overlap\n        });\n        skipped.timeWindow += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n\n      // 6) Generaci√≥n de slots\n      for (const sh of normalizedShifts) {\n        const shiftStartMs = new Date(timeAtDay(currentDate, sh.start, DTF_FULL)).getTime();\n        const shiftEndMs = new Date(timeAtDay(currentDate, sh.end, DTF_FULL)).getTime();\n\n        for (let cursor = shiftStartMs; cursor < shiftEndMs; cursor += slotDurationMs) {\n          const slotStartMs = cursor;\n          const slotEndMs = cursor + slotDurationMs;\n\n          if (slotEndMs > shiftEndMs) {\n            skipped.partialSlot++;\n            break;\n          }\n\n          // anclajes (:00/:30)\n          const mins = new Date(slotStartMs).getUTCMinutes();\n          if (!anchors.includes(mins)) {\n            skipped.invalidGrid++;\n            continue;\n          }\n\n          // short notice\n          if (slotStartMs < shortNoticeBuffer) {\n            skipped.shortNotice++;\n            continue;\n          }\n\n          // ventana global [windowStart, windowEnd)\n          if (slotStartMs < windowStartMs || slotStartMs >= windowEndMs) {\n            skipped.outsideWindow++;\n            continue;\n          }\n\n          const startIso = new Date(slotStartMs).toISOString();\n          const endIso = new Date(slotEndMs).toISOString();\n\n          allowed.push({ start: startIso, end: endIso });\n\n          allowedSlots.push({\n            sede,\n            start: startIso,\n            end: endIso,\n            durationMinutes: slotDurationMin,\n            label: sh.label,\n            weekType: sh.weekType || weekType || null,\n            startLocal: formatLocal(startIso, DTF_DISPLAY),\n            endLocal: formatLocal(endIso, DTF_DISPLAY),\n            startHM: formatHHMM(startIso, DTF_HM),\n            dayKey: dateKey,\n            dow: dowLocal, // DOW local (0..6)\n          });\n\n          totalSlotsGenerated++;\n        }\n      }\n    }\n  }\n\n  // Ordenar por fecha\n  allowed.sort((a, b) => new Date(a.start) - new Date(b.start));\n  allowedSlots.sort((a, b) => new Date(a.start) - new Date(b.start));\n\n  log('SUCCESS', 'Generaci√≥n de slots completada', {\n    totalSlotsGenerated,\n    skipped,\n  });\n\n  return {\n    allowed,\n    allowedSlots,\n    skipped,\n    totalSlotsGenerated,\n    shortNoticeMin,\n  };\n}\n\n// ==================== MAIN ====================\ntry {\n  log('INFO', `SCHEDULE_GATE v${VERSION} iniciando`);\n\n  // (1) Cargar SCHEDULE/HELPERS desde Static Data\n  const store =\n    typeof $getWorkflowStaticData === 'function'\n      ? $getWorkflowStaticData('global')\n      : this.getWorkflowStaticData('global');\n\n  const SCHEDULE = store.SCHEDULE;\n  const HELPERS = store.SCHEDULE_HELPERS;\n\n  if (!SCHEDULE) {\n    const guidance = {\n      tip: 'Ejecute primero CARGAR_HORARIOS en este mismo workflow para poblar Workflow Static Data (global).',\n      expectedKeys: [\n        'SCHEDULE',\n        'SCHEDULE_VERSION',\n        'SCHEDULE_UPDATED_AT',\n        'SCHEDULE_HELPERS (opcional)',\n      ],\n      foundKeys: Object.keys(store || {}),\n    };\n    log('ERROR', 'SCHEDULE ausente en Static Data', guidance);\n    return [\n      {\n        json: {\n          kind: 'error',\n          component: 'SCHEDULE_GATE',\n          version: VERSION,\n          error: 'SCHEDULE_NOT_LOADED',\n          message:\n            'SCHEDULE no cargado. ¬øEjecut√≥ CARGAR_HORARIOS primero?',\n          details: guidance,\n          logs: DEBUG ? LOGS : undefined,\n        },\n      },\n    ];\n  }\n\n  log('INFO', 'SCHEDULE cargado desde Static Data', {\n    version: store.SCHEDULE_VERSION,\n    updatedAt: store.SCHEDULE_UPDATED_AT,\n    tz: SCHEDULE.tz,\n    sedes: Object.keys(SCHEDULE.sedes || {}),\n    hasHelpers: !!HELPERS,\n  });\n\n  // (2) Tomar context del input\n  const input = $input.first();\n  const validation = validateContextFromInput(input);\n  if (!validation.valid) {\n    if (validation.propagateError) {\n      log('INFO', 'Propagando error upstream');\n      return [input];\n    }\n    log('ERROR', 'Entrada inv√°lida', validation);\n    return [\n      {\n        json: {\n          kind: 'error',\n          component: 'SCHEDULE_GATE',\n          version: VERSION,\n          error: validation.error,\n          message: validation.message,\n          details: validation,\n          logs: DEBUG ? LOGS : undefined,\n        },\n      },\n    ];\n  }\n  const ctx = validation.ctx;\n\n  // (3) CFG derivado de SCHEDULE.config + contexto\n  const baseTZ = SCHEDULE.tz || 'America/Mexico_City';\n  const cfgFromSchedule = SCHEDULE.config || {};\n  const CFG = {\n    TZ: ctx.tz || baseTZ,\n    CONSULTATION_DURATION_MIN: cfgFromSchedule.consultationDuration || 30,\n    ANCHORS: cfgFromSchedule.slotAnchors || [0, 30],\n    SHORT_NOTICE_MIN: cfgFromSchedule.shortNoticeMinutes || 120,\n    MAX_SLOTS: cfgFromSchedule.maxSlots || 50,\n  };\n\n  const { DTF_FULL, DTF_DISPLAY, DTF_HM } = getFormatters(CFG.TZ);\n\n  // (4) Generar slots\n  const result = generateSlots(ctx, SCHEDULE, HELPERS, CFG, DTF_FULL, DTF_DISPLAY, DTF_HM);\n\n  // (5) Aplicar caps: ctx.maxResults + SCHEDULE.config.maxSlots\n  const ctxMax = Number.isFinite(Number(ctx.maxResults))\n    ? Number(ctx.maxResults)\n    : Infinity;\n  const scheduleMax = Number.isFinite(Number(CFG.MAX_SLOTS))\n    ? Number(CFG.MAX_SLOTS)\n    : Infinity;\n  const hardCap = Math.min(ctxMax, scheduleMax);\n\n  let prunedAllowed = result.allowed;\n  let prunedAllowedSlots = result.allowedSlots;\n\n  if (Number.isFinite(hardCap) && hardCap > 0 && hardCap !== Infinity) {\n    prunedAllowed = prunedAllowed.slice(0, hardCap);\n    prunedAllowedSlots = prunedAllowedSlots.slice(0, hardCap);\n  }\n\n  // (6) Resumen y respuesta\n  const summaryBySede = prunedAllowedSlots.reduce((acc, slot) => {\n    acc[slot.sede] = (acc[slot.sede] || 0) + 1;\n    return acc;\n  }, {});\n\n  const summaryByDay = prunedAllowedSlots.reduce((acc, s) => {\n    acc[s.dayKey] = (acc[s.dayKey] || 0) + 1;\n    return acc;\n  }, {});\n\n  const response = {\n    kind: 'scheduleGate',\n    version: VERSION,\n    tz: CFG.TZ,\n    request: {\n      windowStart: ctx.windowStart,\n      windowEnd: ctx.windowEnd,\n      sedes: ctx.sedes,\n      sedePreferida: ctx.sedePreferida,\n      timeWindow: ctx.timeWindow || {},\n      includeWeekends: ctx.includeWeekends !== false,\n      onlyMorning: !!ctx.onlyMorning,\n      onlyAfternoon: !!ctx.onlyAfternoon,\n      maxResults: ctx.maxResults,\n      consultationDuration: CFG.CONSULTATION_DURATION_MIN,\n      requestId: ctx.requestId,\n    },\n    decision: {\n      isOpen: prunedAllowedSlots.length > 0,\n      reason: prunedAllowedSlots.length\n        ? `${prunedAllowedSlots.length} opciones disponibles`\n        : 'Sin horarios en el rango solicitado',\n      shortNoticeMinutes: result.shortNoticeMin,\n    },\n    allowed: prunedAllowed,\n    allowedSlots: prunedAllowedSlots, // slots enriquecidos\n    skipped: result.skipped,\n    summary: {\n      totalSlots: prunedAllowedSlots.length,\n      bySede: summaryBySede,\n      byDay: summaryByDay,\n    },\n    meta: {\n      scheduleVersion: store.SCHEDULE_VERSION,\n      scheduleUpdatedAt: store.SCHEDULE_UPDATED_AT,\n      grid: {\n        stepMinutes: CFG.CONSULTATION_DURATION_MIN,\n        anchors: CFG.ANCHORS,\n      },\n    },\n    _logs: DEBUG ? LOGS : undefined,\n  };\n\n  log('SUCCESS', 'SCHEDULE_GATE completado', {\n    total: response.summary.totalSlots,\n    bySede: summaryBySede,\n  });\n\n  return [{ json: response }];\n} catch (error) {\n  log('ERROR', 'Error fatal', { error: error.message, stack: error.stack });\n  return [\n    {\n      json: {\n        kind: 'error',\n        component: 'SCHEDULE_GATE',\n        version: VERSION,\n        error: 'UNEXPECTED_ERROR',\n        message: error.message || String(error),\n        stack: DEBUG ? error.stack : undefined,\n        logs: DEBUG ? LOGS : undefined,\n      },\n    },\n  ];\n}\n"
      },
      "id": "318b3f62-6442-43c7-b97d-593c60aba641",
      "name": "SCHEDULE_GATE1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * NORMALIZE_BUSY v6.1 ‚Äî Mejoras de Integraci√≥n\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * Cambios clave vs v6.0:\n * 1) ‚úÖ Cargar mapping de calendarId ‚á¢ sede desde SCHEDULE (Static Data) con fallback\n * 2) ‚úÖ Usar mapping din√°mico en MAIN (sin hardcoded)\n * 3) ‚úÖ Acceso mejorado al context de SET_DEFAULTS (windowStart/End, tz, requestId)\n * 4) ‚úÖ requestId y metadata de mapping en el output\n * 5) üü° CFG din√°mico desde SCHEDULE.config (slotAnchors)\n */\n\nconst BUILD_VERSION = '6.1.0';\nconst DEFAULT_TZ = 'America/Mexico_City';\nconst DEBUG = true;\n\n// ==================== LOGGING ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = { timestamp: new Date().toISOString(), level: level.toUpperCase(), component: 'NORMALIZE_BUSY', version: BUILD_VERSION, message, ...data };\n  LOGS.push(entry);\n  if (DEBUG) {\n    const emoji = { INFO: '‚ÑπÔ∏è', WARN: '‚ö†Ô∏è', ERROR: '‚ùå', DEBUG: 'üîç', SUCCESS: '‚úÖ' }[level.toUpperCase()] || 'üìù';\n    console.log(`${emoji} [${level.toUpperCase()}] ${message}`, data);\n  }\n}\n\n// ==================== CONFIGURACI√ìN DIN√ÅMICA ====================\nfunction loadConfig() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function') ? $getWorkflowStaticData('global') : this.getWorkflowStaticData('global');\n    const SCHEDULE = store.SCHEDULE;\n    if (SCHEDULE?.config) {\n      return Object.freeze({\n        MAX_BUSY_INTERVALS: 1000,\n        MIN_INTERVAL_MS: 60_000,\n        MAX_INTERVAL_DAYS: 7,\n        ANCHORS: SCHEDULE.config.slotAnchors || [0, 30],\n        SEDE_PRIORITY: Object.keys(SCHEDULE.sedes || {}) || ['POLANCO', 'SATELITE'],\n      });\n    }\n  } catch (e) {\n    log('WARN', 'No se pudo cargar CFG desde SCHEDULE, usando defaults', { error: e.message });\n  }\n  return Object.freeze({\n    MAX_BUSY_INTERVALS: 1000,\n    MIN_INTERVAL_MS: 60_000,\n    MAX_INTERVAL_DAYS: 7,\n    ANCHORS: [0, 30],\n    SEDE_PRIORITY: ['POLANCO', 'SATELITE'],\n  });\n}\n\n// ==================== CARGAR MAPPING DE CALENDARIOS ====================\nfunction loadCalendarMapping() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function') ? $getWorkflowStaticData('global') : this.getWorkflowStaticData('global');\n    const SCHEDULE = store.SCHEDULE;\n\n    // Intento principal: SCHEDULE.meta\n    if (SCHEDULE?.meta) {\n      const mapping = {};\n      for (const [sede, metadata] of Object.entries(SCHEDULE.meta)) {\n        if (metadata && metadata.calendarId) mapping[metadata.calendarId] = sede;\n      }\n      if (Object.keys(mapping).length > 0) {\n        console.log('‚úÖ Calendar mapping cargado desde SCHEDULE.meta', { sedes: Object.keys(SCHEDULE.meta), calendars: Object.keys(mapping).length, version: store.SCHEDULE_VERSION });\n        return { CALENDAR_ID_TO_SEDE: mapping, source: 'schedule', version: store.SCHEDULE_VERSION };\n      }\n      console.warn('‚ö†Ô∏è No se encontraron calendarIds en SCHEDULE.meta');\n    }\n\n    // Compatibilidad: SCHEDULE.metadata\n    if (SCHEDULE?.metadata) {\n      const mappingMeta = {};\n      for (const [sede, metadata] of Object.entries(SCHEDULE.metadata)) {\n        if (metadata && metadata.calendarId) mappingMeta[metadata.calendarId] = sede;\n      }\n      if (Object.keys(mappingMeta).length > 0) {\n        console.log('‚úÖ Calendar mapping cargado desde SCHEDULE.metadata (compat)', { sedes: Object.keys(SCHEDULE.metadata), calendars: Object.keys(mappingMeta).length, version: store.SCHEDULE_VERSION });\n        return { CALENDAR_ID_TO_SEDE: mappingMeta, source: 'schedule_metadata', version: store.SCHEDULE_VERSION };\n      }\n    }\n\n    console.warn('‚ö†Ô∏è SCHEDULE.meta no disponible o vac√≠o, usando fallback');\n    return {\n      CALENDAR_ID_TO_SEDE: {\n        '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com': 'POLANCO',\n        'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com': 'SATELITE',\n      },\n      source: 'fallback',\n    };\n  } catch (error) {\n    console.error('‚ùå Error cargando calendar mapping:', error.message);\n    return {\n      CALENDAR_ID_TO_SEDE: {\n        '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com': 'POLANCO',\n        'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com': 'SATELITE',\n      },\n      source: 'fallback_error',\n      error: error.message,\n    };\n  }\n}\n\n// ==================== TIMEZONE HELPERS (CACHED) ====================\nlet _fmtCache = {};\nfunction getFormatters(tz) {\n  if (!_fmtCache[tz]) {\n    _fmtCache[tz] = {\n      tz,\n      DTF_FULL: new Intl.DateTimeFormat('en-CA', {\n        timeZone: tz, year: 'numeric', month: '2-digit', day: '2-digit',\n        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false,\n      }),\n    };\n  }\n  return _fmtCache[tz];\n}\nfunction dtPartsInTZ(date, DTF_FULL) {\n  const parts = DTF_FULL.formatToParts(date);\n  const obj = {}; for (const p of parts) obj[p.type] = p.value;\n  return { y: +obj.year, m: +obj.month, d: +obj.day, hh: +obj.hour, mm: +obj.minute, ss: +obj.second };\n}\nfunction zonedEpochMs(y, m, d, hh, mm, ss, DTF_FULL) {\n  const naive = Date.UTC(y, m - 1, d, hh || 0, mm || 0, ss || 0);\n  const seen = dtPartsInTZ(new Date(naive), DTF_FULL);\n  const seenMs = Date.UTC(seen.y, seen.m - 1, seen.d, seen.hh, seen.mm, seen.ss);\n  return naive - (seenMs - naive);\n}\nconst toISO = (ms) => new Date(ms).toISOString();\nfunction toMs(v) {\n  if (v == null) return NaN;\n  if (typeof v === 'number') return v;\n  if (v instanceof Date) return v.getTime();\n  const s = String(v).trim();\n  if (s.endsWith('Z') || /[+-]\\d{2}:\\d{2}$/.test(s)) return Date.parse(s);\n  if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(s)) return Date.parse(s + 'Z');\n  return Date.parse(s);\n}\n\n// ==================== VALIDACI√ìN DE RESPUESTA ====================\nfunction validateGoogleCalendarResponse(json) {\n  if (json?.error || json?.__ERROR) return { valid: false, error: 'GCAL_API_ERROR', message: json.error?.message || json.__ERROR?.message || 'Error de Google Calendar API' };\n  if (json == null) return { valid: false, error: 'NULL_RESPONSE', message: 'Google Calendar retorn√≥ null' };\n  if (typeof json !== 'object') return { valid: false, error: 'INVALID_TYPE', message: `Esperaba objeto, recibi√≥ ${typeof json}` };\n  return { valid: true };\n}\n\n// ==================== INTERVAL HELPERS ====================\nfunction clampMs(sMs, eMs, wsMs, weMs, MIN_INTERVAL_MS) {\n  if (!Number.isFinite(sMs) || !Number.isFinite(eMs) || sMs >= eMs) return null;\n  const S = wsMs != null ? Math.max(sMs, wsMs) : sMs;\n  const E = weMs != null ? Math.min(eMs, weMs) : eMs;\n  if (S >= E) return null;\n  if ((E - S) < MIN_INTERVAL_MS) return null;\n  return [S, E];\n}\nfunction validateInterval(interval, source = 'unknown') {\n  if (!interval || typeof interval !== 'object') return { valid: false, error: `Invalid interval object from ${source}` };\n  if (!interval.start || !interval.end) return { valid: false, error: `Missing start/end in interval from ${source}` };\n  const sMs = toMs(interval.start), eMs = toMs(interval.end);\n  if (!Number.isFinite(sMs)) return { valid: false, error: `Invalid start time \"${interval.start}\" from ${source}` };\n  if (!Number.isFinite(eMs)) return { valid: false, error: `Invalid end time \"${interval.end}\" from ${source}` };\n  if (sMs >= eMs) return { valid: false, error: `Start >= end in interval from ${source}: ${interval.start} >= ${interval.end}` };\n  return { valid: true, sMs, eMs };\n}\nfunction splitMultidayInterval(sMs, eMs, DTF_FULL, MAX_INTERVAL_DAYS) {\n  const startP = dtPartsInTZ(new Date(sMs), DTF_FULL);\n  const endP = dtPartsInTZ(new Date(eMs), DTF_FULL);\n  if (startP.y === endP.y && startP.m === endP.m && startP.d === endP.d) return [[sMs, eMs]];\n  const startDayMs = zonedEpochMs(startP.y, startP.m, startP.d, 0, 0, 0, DTF_FULL);\n  const endDayMs = zonedEpochMs(endP.y, endP.m, endP.d, 0, 0, 0, DTF_FULL);\n  const daysDiff = Math.round((endDayMs - startDayMs) / 86_400_000);\n  const out = [];\n  if (daysDiff > MAX_INTERVAL_DAYS) {\n    const endFirst = zonedEpochMs(startP.y, startP.m, startP.d, 23, 59, 59, DTF_FULL);\n    out.push([sMs, endFirst]);\n    const startLast = zonedEpochMs(endP.y, endP.m, endP.d, 0, 0, 0, DTF_FULL);\n    out.push([startLast, eMs]);\n    return out;\n  }\n  let current = startDayMs;\n  for (let i = 0; i <= daysDiff; i++) {\n    const p = dtPartsInTZ(new Date(current), DTF_FULL);\n    const dayStart = zonedEpochMs(p.y, p.m, p.d, 0, 0, 0, DTF_FULL);\n    const dayEnd = zonedEpochMs(p.y, p.m, p.d, 23, 59, 59, DTF_FULL);\n    const S = Math.max(sMs, dayStart), E = Math.min(eMs, dayEnd);\n    if (S < E) out.push([S, E]);\n    current += 86_400_000;\n  }\n  return out;\n}\nfunction mergeExclusiveMs(pairs) {\n  if (!pairs || !pairs.length) return [];\n  pairs.sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]));\n  const out = []; let [s0, e0] = pairs[0];\n  for (let i = 1; i < pairs.length; i++) { const [s, e] = pairs[i]; if (s < e0) { if (e > e0) e0 = e; } else { out.push([s0, e0]); s0 = s; e0 = e; } }\n  out.push([s0, e0]); return out;\n}\nfunction minuteFromMs(ms) { return Math.floor((ms / 60000) % 60); }\nfunction checkOffGrid(mergedPairs, anchors) {\n  const off = [];\n  for (const [S, E] of mergedPairs) {\n    const sOn = anchors.includes(minuteFromMs(S));\n    const eOn = anchors.includes(minuteFromMs(E));\n    if (!sOn || !eOn) off.push({ interval: { start: toISO(S), end: toISO(E) }, startOnGrid: sOn, endOnGrid: eOn });\n  }\n  return off;\n}\n\n// ==================== DETECCI√ìN DE SEDE ====================\nfunction detectSede(calendarIds, explicitSede, CALENDAR_ID_TO_SEDE, SEDE_PRIORITY) {\n  if (explicitSede) {\n    const expected = Object.entries(CALENDAR_ID_TO_SEDE).filter(([, sede]) => sede === explicitSede).map(([cid]) => cid);\n    const allMatch = calendarIds.every(cid => expected.includes(cid));\n    return allMatch ? { sede: explicitSede, source: 'explicit_validated', calendarIds } : { sede: null, source: 'explicit_mismatch', error: `Sede \"${explicitSede}\" no coincide con calendarios: ${calendarIds.join(', ')}`, calendarIds };\n  }\n  if (calendarIds.length === 1) {\n    const sede = CALENDAR_ID_TO_SEDE[calendarIds[0]];\n    return sede ? { sede, source: 'single_calendar', calendarIds } : { sede: null, source: 'unknown_calendar', error: `Calendar ID desconocido: ${calendarIds[0]}`, calendarIds };\n  }\n  const sedesDetected = new Set();\n  for (const cid of calendarIds) { const sede = CALENDAR_ID_TO_SEDE[cid]; if (sede) sedesDetected.add(sede); }\n  if (sedesDetected.size === 1) return { sede: Array.from(sedesDetected)[0], source: 'multiple_calendars_same_sede', calendarIds };\n  if (sedesDetected.size > 1) {\n    const prioritized = (SEDE_PRIORITY || []).find(s => sedesDetected.has(s));\n    if (prioritized) return { sede: prioritized, source: 'multiple_sedes_prioritized', warning: `M√∫ltiples sedes detectadas: ${Array.from(sedesDetected).join(', ')}, usando ${prioritized}`, calendarIds };\n  }\n  return { sede: null, source: 'unable_to_detect', error: 'No se pudo determinar sede', calendarIds };\n}\n\n// ==================== EXTRACCI√ìN DE BUSY ====================\nfunction extractBusyPairs(json, opts) {\n  const { maxIntervals, DTF_FULL, MIN_INTERVAL_MS, MAX_INTERVAL_DAYS, wsMs, weMs } = opts;\n  const pairs = []; const calendarIds = []; const errors = [];\n\n  if (json && json.calendars && typeof json.calendars === 'object') {\n    for (const calId of Object.keys(json.calendars)) {\n      calendarIds.push(calId);\n      const arr = json.calendars[calId]?.busy || [];\n      if (arr.length > maxIntervals) errors.push(`Calendar ${calId} tiene ${arr.length} intervalos, tomando primeros ${maxIntervals}`);\n      const toProcess = arr.slice(0, maxIntervals);\n      for (const it of toProcess) {\n        const v = validateInterval(it, `calendar:${calId}`);\n        if (!v.valid) { errors.push(v.error); continue; }\n        const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n        for (const [s, e] of splits) { const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS); if (cl) pairs.push(cl); }\n      }\n    }\n    return { pairs, calendarIds, errors };\n  }\n\n  if (Array.isArray(json?.busy)) {\n    const arr = json.busy.slice(0, maxIntervals);\n    for (const it of arr) {\n      const v = validateInterval(it, 'direct_busy');\n      if (!v.valid) { errors.push(v.error); continue; }\n      const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n      for (const [s, e] of splits) { const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS); if (cl) pairs.push(cl); }\n    }\n    return { pairs, calendarIds, errors };\n  }\n\n  if (Array.isArray(json)) {\n    const arr = json.slice(0, maxIntervals);\n    for (const it of arr) {\n      const v = validateInterval(it, 'array');\n      if (!v.valid) { errors.push(v.error); continue; }\n      const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n      for (const [s, e] of splits) { const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS); if (cl) pairs.push(cl); }\n    }\n    return { pairs, calendarIds, errors };\n  }\n\n  return { pairs, calendarIds, errors };\n}\n\n// ==================== MAIN ====================\ntry {\n  const startTime = DEBUG ? Date.now() : 0;\n  const items = $input.all();\n\n  // ‚úÖ NUEVO: Cargar mapping de calendarios desde SCHEDULE\n  const calendarMappingData = loadCalendarMapping();\n  const CALENDAR_ID_TO_SEDE = calendarMappingData.CALENDAR_ID_TO_SEDE || {};\n  const SEDE_TO_CALENDAR_IDS = Object.entries(CALENDAR_ID_TO_SEDE).reduce((acc, [calId, sede]) => { (acc[sede] ||= []).push(calId); return acc; }, {});\n  if (DEBUG) {\n    console.log('üìã Calendar mapping:', { source: calendarMappingData.source, sedes: Object.keys(SEDE_TO_CALENDAR_IDS), totalCalendars: Object.keys(CALENDAR_ID_TO_SEDE).length });\n  }\n\n  // 1) Obtener ventana y par√°metros desde SET_DEFAULTS\n  let wsMs = null, weMs = null, slotDefaultMin = 30;\n  let requestId = `normalize-${Date.now()}`;\n  let effectiveTZ = DEFAULT_TZ;\n  let explicitSede = null;\n\n  try {\n    const setDefaultsItems = $('SET_DEFAULTS').all();\n    if (setDefaultsItems && setDefaultsItems.length > 0) {\n      const ctx = setDefaultsItems[0].json;\n      if (ctx?.kind === 'context') {\n        if (ctx.windowStart) wsMs = toMs(ctx.windowStart);\n        if (ctx.windowEnd) weMs = toMs(ctx.windowEnd);\n        if (Number.isFinite(ctx.constraints?.slotMinutes)) {\n          slotDefaultMin = Math.max(10, Math.min(120, ctx.constraints.slotMinutes));\n        }\n        if (ctx.requestId) requestId = ctx.requestId;\n        if (ctx.tz) effectiveTZ = ctx.tz;\n        if (ctx.sedePreferida) explicitSede = String(ctx.sedePreferida).toUpperCase();\n        if (DEBUG) console.log('‚úÖ Context cargado desde SET_DEFAULTS', { windowStart: ctx.windowStart, windowEnd: ctx.windowEnd, tz: effectiveTZ, requestId, explicitSede });\n      } else {\n        console.warn('‚ö†Ô∏è SET_DEFAULTS no retorn√≥ context v√°lido, kind:', ctx?.kind);\n      }\n    } else {\n      console.warn('‚ö†Ô∏è No se encontr√≥ SET_DEFAULTS en items');\n    }\n  } catch (err) {\n    console.warn('‚ö†Ô∏è Error obteniendo context de SET_DEFAULTS:', err.message);\n  }\n\n  // 2) TZ/CFG\n  const { DTF_FULL } = getFormatters(effectiveTZ);\n  const CFG = loadConfig();\n\n  // 3) Procesar entradas\n  const rawPairs = []; const allCalendarIds = new Set(); const errors = [];\n  for (let i = 0; i < items.length; i++) {\n    const json = items[i]?.json || {};\n    const vr = validateGoogleCalendarResponse(json);\n    if (!vr.valid) { errors.push(vr.message); continue; }\n    const ext = extractBusyPairs(json, { maxIntervals: CFG.MAX_BUSY_INTERVALS, DTF_FULL, MIN_INTERVAL_MS: CFG.MIN_INTERVAL_MS, MAX_INTERVAL_DAYS: CFG.MAX_INTERVAL_DAYS, wsMs, weMs });\n    ext.calendarIds.forEach(cid => allCalendarIds.add(cid));\n    rawPairs.push(...ext.pairs);\n    if (ext.errors.length) errors.push(...ext.errors);\n  }\n\n  // 4) Detectar sede autom√°ticamente o validar expl√≠cita\n  const calendarIdsArray = Array.from(allCalendarIds);\n  const sedeDetection = detectSede(calendarIdsArray, explicitSede, CALENDAR_ID_TO_SEDE, CFG.SEDE_PRIORITY);\n  if (!sedeDetection.sede) {\n    return [{\n      json: {\n        kind: 'busy', sede: null, busy: [], busyBySede: {},\n        sourceStatus: {\n          ok: false,\n          sede: null,\n          tz: effectiveTZ,\n          requestId,\n          errors: [sedeDetection.error || 'No se pudo determinar SEDE'],\n          sedeDetection,\n          build: { version: BUILD_VERSION, generatedAt: new Date().toISOString(), scheduleVersion: calendarMappingData.version },\n          calendarMappingSource: calendarMappingData.source,\n        }\n      }\n    }];\n  }\n\n  const SEDE = sedeDetection.sede;\n  if (sedeDetection.warning) errors.push(sedeDetection.warning);\n\n  // 5) Merge + off-grid\n  const mergedPairs = mergeExclusiveMs(rawPairs);\n  const offGridDetails = checkOffGrid(mergedPairs, CFG.ANCHORS);\n\n  // 6) Salida normalizada\n  const busy = mergedPairs.map(([sMs, eMs]) => ({ sede: SEDE, start: toISO(sMs), end: toISO(eMs) }));\n\n  // 7) M√©tricas\n  const metrics = {\n    totalItems: items.length,\n    totalRaw: rawPairs.length,\n    merged: mergedPairs.length,\n    offGridCount: offGridDetails.length,\n    calendarIds: calendarIdsArray,\n    executionTimeMs: DEBUG ? (Date.now() - startTime) : undefined,\n  };\n\n  const status = {\n    ok: errors.length === 0,\n    sede: SEDE,\n    sedeDetection,\n    tz: effectiveTZ,\n    requestId,\n    calendarMappingSource: calendarMappingData.source,\n    window: { start: wsMs != null ? toISO(wsMs) : null, end: weMs != null ? toISO(weMs) : null },\n    policy: { source: 'freebusy', slotDefaultMin, maxIntervals: CFG.MAX_BUSY_INTERVALS, maxIntervalDays: CFG.MAX_INTERVAL_DAYS },\n    metrics,\n    offGridDetails: offGridDetails.length ? offGridDetails : undefined,\n    errors,\n    build: { version: BUILD_VERSION, generatedAt: new Date().toISOString(), scheduleVersion: calendarMappingData.version },\n    _logs: DEBUG ? LOGS : undefined,\n  };\n\n  log('SUCCESS', '‚úÖ NORMALIZE_BUSY completado', { sede: SEDE, totalBusy: busy.length, offGrid: offGridDetails.length });\n\n  return [{\n    json: { kind: 'busy', sede: SEDE, busy, busyBySede: { [SEDE]: busy }, sourceStatus: status },\n    pairedItem: items.map((_, i) => ({ item: i })),\n  }];\n\n} catch (err) {\n  log('ERROR', 'Error fatal', { error: err?.message, stack: err?.stack });\n  return [{ json: { kind: 'busy', sede: null, busy: [], busyBySede: {}, sourceStatus: { ok: false, errors: [String(err?.message || err)], stack: DEBUG ? err?.stack : undefined, build: { version: BUILD_VERSION, generatedAt: new Date().toISOString() } } } }];\n}\n"
      },
      "id": "71a3b9b2-49df-4d69-8bca-2c9fd5d39fec",
      "name": "Normalize Busy POLANCO1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * NORMALIZE_BUSY v6.2 ‚Äî SAT√âLITE (estricto)\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * Cambios clave:\n * 1) ‚úÖ Cargar mapping de calendarId ‚á¢ sede desde SCHEDULE (Static Data) con fallback\n * 2) ‚úÖ CFG din√°mico desde SCHEDULE.config (slotAnchors)\n * 3) ‚úÖ Acceso mejorado al context de SET_DEFAULTS (windowStart/End, tz, requestId)\n * 4) ‚úÖ requestId, scheduleVersion y mappingSource en el output\n * 5) ‚úÖ Modo ESTRICTO por sede: solo procesa calendarios de SAT√âLITE\n */\n\nconst BUILD_VERSION = '6.2.0';\nconst DEFAULT_TZ = 'America/Mexico_City';\nconst DEBUG = true;\nconst EXPECTED_SEDE = 'SATELITE';\n\n// ==================== LOGGING ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = { timestamp: new Date().toISOString(), level: level.toUpperCase(), component: 'NORMALIZE_BUSY_SATELITE', version: BUILD_VERSION, message, ...data };\n  LOGS.push(entry);\n  if (DEBUG) {\n    const emoji = { INFO: '‚ÑπÔ∏è', WARN: '‚ö†Ô∏è', ERROR: '‚ùå', DEBUG: 'üîç', SUCCESS: '‚úÖ' }[level.toUpperCase()] || 'üìù';\n    console.log(`${emoji} [${level.toUpperCase()}] ${message}`, data);\n  }\n}\n\n// ==================== CONFIGURACI√ìN DIN√ÅMICA ====================\nfunction loadConfig() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function')\n      ? $getWorkflowStaticData('global')\n      : this.getWorkflowStaticData('global');\n    const SCHEDULE = store.SCHEDULE;\n    if (SCHEDULE?.config) {\n      return Object.freeze({\n        MAX_BUSY_INTERVALS: 1000,\n        MIN_INTERVAL_MS: 60_000,\n        MAX_INTERVAL_DAYS: 7,\n        ANCHORS: SCHEDULE.config.slotAnchors || [0, 30],\n        SEDE_PRIORITY: Object.keys(SCHEDULE.sedes || {}) || ['POLANCO', 'SATELITE'],\n      });\n    }\n  } catch (e) {\n    log('WARN', 'No se pudo cargar CFG desde SCHEDULE, usando defaults', { error: e.message });\n  }\n  return Object.freeze({\n    MAX_BUSY_INTERVALS: 1000,\n    MIN_INTERVAL_MS: 60_000,\n    MAX_INTERVAL_DAYS: 7,\n    ANCHORS: [0, 30],\n    SEDE_PRIORITY: ['POLANCO', 'SATELITE'],\n  });\n}\n\n// ==================== CARGAR MAPPING DE CALENDARIOS ====================\nfunction loadCalendarMapping() {\n  try {\n    const store = (typeof $getWorkflowStaticData === 'function')\n      ? $getWorkflowStaticData('global')\n      : this.getWorkflowStaticData('global');\n    const SCHEDULE = store.SCHEDULE;\n\n    // Preferido: SCHEDULE.meta\n    if (SCHEDULE?.meta) {\n      const mapping = {};\n      for (const [sede, meta] of Object.entries(SCHEDULE.meta)) {\n        if (meta?.calendarId) mapping[meta.calendarId] = sede;\n      }\n      if (Object.keys(mapping).length > 0) {\n        console.log('‚úÖ Calendar mapping cargado desde SCHEDULE.meta', {\n          sedes: Object.keys(SCHEDULE.meta),\n          calendars: Object.keys(mapping).length,\n          version: store.SCHEDULE_VERSION,\n        });\n        return { CALENDAR_ID_TO_SEDE: mapping, source: 'schedule', version: store.SCHEDULE_VERSION };\n      }\n      console.warn('‚ö†Ô∏è SCHEDULE.meta sin calendarIds; intentando metadata (compat)');\n    }\n\n    // Compatibilidad: SCHEDULE.metadata\n    if (SCHEDULE?.metadata) {\n      const mappingMeta = {};\n      for (const [sede, meta] of Object.entries(SCHEDULE.metadata)) {\n        if (meta?.calendarId) mappingMeta[meta.calendarId] = sede;\n      }\n      if (Object.keys(mappingMeta).length > 0) {\n        console.log('‚úÖ Calendar mapping cargado desde SCHEDULE.metadata (compat)', {\n          sedes: Object.keys(SCHEDULE.metadata),\n          calendars: Object.keys(mappingMeta).length,\n          version: store.SCHEDULE_VERSION,\n        });\n        return { CALENDAR_ID_TO_SEDE: mappingMeta, source: 'schedule_metadata', version: store.SCHEDULE_VERSION };\n      }\n    }\n\n    // Fallback a hardcoded (incluye SAT√âLITE)\n    console.warn('‚ö†Ô∏è SCHEDULE no provee mapping, usando fallback hardcoded');\n    return {\n      CALENDAR_ID_TO_SEDE: {\n        // Polanco:\n        '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com': 'POLANCO',\n        // Sat√©lite:\n        'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com': 'SATELITE',\n      },\n      source: 'fallback',\n      version: 'fallback',\n    };\n  } catch (error) {\n    console.error('‚ùå Error cargando calendar mapping:', error.message);\n    return {\n      CALENDAR_ID_TO_SEDE: {\n        '92dbbeda09a6dfba909c43d9f05553f65309adcb629f35759153e59e3e401fc0@group.calendar.google.com': 'POLANCO',\n        'ecdb381f314048b2662edd2d3169899eaab6e17bbc181151998ce7ad1ac0dabf@group.calendar.google.com': 'SATELITE',\n      },\n      source: 'fallback_error',\n      version: 'fallback_error',\n      error: error.message,\n    };\n  }\n}\n\n// ==================== TIMEZONE HELPERS (CACHED) ====================\nlet _fmtCache = {};\nfunction getFormatters(tz) {\n  if (!_fmtCache[tz]) {\n    _fmtCache[tz] = {\n      tz,\n      DTF_FULL: new Intl.DateTimeFormat('en-CA', {\n        timeZone: tz,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false,\n      }),\n    };\n  }\n  return _fmtCache[tz];\n}\nfunction dtPartsInTZ(date, DTF_FULL) {\n  const parts = DTF_FULL.formatToParts(date);\n  const obj = {};\n  for (const p of parts) obj[p.type] = p.value;\n  return { y: +obj.year, m: +obj.month, d: +obj.day, hh: +obj.hour, mm: +obj.minute, ss: +obj.second };\n}\nfunction zonedEpochMs(y, m, d, hh, mm, ss, DTF_FULL) {\n  const naive = Date.UTC(y, m - 1, d, hh || 0, mm || 0, ss || 0);\n  const seen = dtPartsInTZ(new Date(naive), DTF_FULL);\n  const seenMs = Date.UTC(seen.y, seen.m - 1, seen.d, seen.hh, seen.mm, seen.ss);\n  return naive - (seenMs - naive);\n}\nconst toISO = (ms) => new Date(ms).toISOString();\nfunction toMs(v) {\n  if (v == null) return NaN;\n  if (typeof v === 'number') return v;\n  if (v instanceof Date) return v.getTime();\n  const s = String(v).trim();\n  if (s.endsWith('Z') || /[+-]\\d{2}:\\d{2}$/.test(s)) return Date.parse(s);\n  if (/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/.test(s)) return Date.parse(s + 'Z');\n  return Date.parse(s);\n}\n\n// ==================== VALIDACI√ìN DE RESPUESTA ====================\nfunction validateGoogleCalendarResponse(json) {\n  if (json?.error || json?.__ERROR) return { valid: false, error: 'GCAL_API_ERROR', message: json.error?.message || json.__ERROR?.message || 'Error de Google Calendar API' };\n  if (json == null) return { valid: false, error: 'NULL_RESPONSE', message: 'Google Calendar retorn√≥ null' };\n  if (typeof json !== 'object') return { valid: false, error: 'INVALID_TYPE', message: `Esperaba objeto, recibi√≥ ${typeof json}` };\n  return { valid: true };\n}\n\n// ==================== INTERVAL HELPERS ====================\nfunction clampMs(sMs, eMs, wsMs, weMs, MIN_INTERVAL_MS) {\n  if (!Number.isFinite(sMs) || !Number.isFinite(eMs) || sMs >= eMs) return null;\n  const S = wsMs != null ? Math.max(sMs, wsMs) : sMs;\n  const E = weMs != null ? Math.min(eMs, weMs) : eMs;\n  if (S >= E) return null;\n  if ((E - S) < MIN_INTERVAL_MS) return null;\n  return [S, E];\n}\nfunction validateInterval(interval, source = 'unknown') {\n  if (!interval || typeof interval !== 'object') return { valid: false, error: `Invalid interval object from ${source}` };\n  if (!interval.start || !interval.end) return { valid: false, error: `Missing start/end in interval from ${source}` };\n  const sMs = toMs(interval.start), eMs = toMs(interval.end);\n  if (!Number.isFinite(sMs)) return { valid: false, error: `Invalid start time \"${interval.start}\" from ${source}` };\n  if (!Number.isFinite(eMs)) return { valid: false, error: `Invalid end time \"${interval.end}\" from ${source}` };\n  if (sMs >= eMs) return { valid: false, error: `Start >= end in interval from ${source}: ${interval.start} >= ${interval.end}` };\n  return { valid: true, sMs, eMs };\n}\nfunction splitMultidayInterval(sMs, eMs, DTF_FULL, MAX_INTERVAL_DAYS) {\n  const startP = dtPartsInTZ(new Date(sMs), DTF_FULL);\n  const endP = dtPartsInTZ(new Date(eMs), DTF_FULL);\n  if (startP.y === endP.y && startP.m === endP.m && startP.d === endP.d) return [[sMs, eMs]];\n  const startDayMs = zonedEpochMs(startP.y, startP.m, startP.d, 0, 0, 0, DTF_FULL);\n  const endDayMs = zonedEpochMs(endP.y, endP.m, endP.d, 0, 0, 0, DTF_FULL);\n  const daysDiff = Math.round((endDayMs - startDayMs) / 86_400_000);\n  const out = [];\n  if (daysDiff > MAX_INTERVAL_DAYS) {\n    const endFirst = zonedEpochMs(startP.y, startP.m, startP.d, 23, 59, 59, DTF_FULL);\n    out.push([sMs, endFirst]);\n    const startLast = zonedEpochMs(endP.y, endP.m, endP.d, 0, 0, 0, DTF_FULL);\n    out.push([startLast, eMs]);\n    return out;\n  }\n  let current = startDayMs;\n  for (let i = 0; i <= daysDiff; i++) {\n    const p = dtPartsInTZ(new Date(current), DTF_FULL);\n    const dayStart = zonedEpochMs(p.y, p.m, p.d, 0, 0, 0, DTF_FULL);\n    const dayEnd = zonedEpochMs(p.y, p.m, p.d, 23, 59, 59, DTF_FULL);\n    const S = Math.max(sMs, dayStart), E = Math.min(eMs, dayEnd);\n    if (S < E) out.push([S, E]);\n    current += 86_400_000;\n  }\n  return out;\n}\nfunction mergeExclusiveMs(pairs) {\n  if (!pairs || !pairs.length) return [];\n  pairs.sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]));\n  const out = []; let [s0, e0] = pairs[0];\n  for (let i = 1; i < pairs.length; i++) {\n    const [s, e] = pairs[i];\n    if (s < e0) { if (e > e0) e0 = e; }\n    else { out.push([s0, e0]); s0 = s; e0 = e; }\n  }\n  out.push([s0, e0]);\n  return out;\n}\nconst minuteFromMs = (ms) => Math.floor((ms / 60000) % 60);\nfunction checkOffGrid(mergedPairs, anchors) {\n  const off = [];\n  for (const [S, E] of mergedPairs) {\n    const sOn = anchors.includes(minuteFromMs(S));\n    const eOn = anchors.includes(minuteFromMs(E));\n    if (!sOn || !eOn) off.push({ interval: { start: toISO(S), end: toISO(E) }, startOnGrid: sOn, endOnGrid: eOn });\n  }\n  return off;\n}\n\n// ==================== DETECCI√ìN DE SEDE ====================\nfunction detectSede(calendarIds, explicitSede, CALENDAR_ID_TO_SEDE, SEDE_PRIORITY) {\n  if (explicitSede) {\n    const expected = Object.entries(CALENDAR_ID_TO_SEDE)\n      .filter(([, sede]) => sede === explicitSede)\n      .map(([cid]) => cid);\n    const allMatch = calendarIds.every(cid => expected.includes(cid));\n    return allMatch\n      ? { sede: explicitSede, source: 'explicit_validated', calendarIds }\n      : { sede: null, source: 'explicit_mismatch', error: `Sede \"${explicitSede}\" no coincide con calendarios: ${calendarIds.join(', ')}`, calendarIds };\n  }\n  if (calendarIds.length === 1) {\n    const sede = CALENDAR_ID_TO_SEDE[calendarIds[0]];\n    return sede\n      ? { sede, source: 'single_calendar', calendarIds }\n      : { sede: null, source: 'unknown_calendar', error: `Calendar ID desconocido: ${calendarIds[0]}`, calendarIds };\n  }\n  const sedesDetected = new Set();\n  for (const cid of calendarIds) { const sede = CALENDAR_ID_TO_SEDE[cid]; if (sede) sedesDetected.add(sede); }\n  if (sedesDetected.size === 1) return { sede: Array.from(sedesDetected)[0], source: 'multiple_calendars_same_sede', calendarIds };\n  if (sedesDetected.size > 1) {\n    const prioritized = (SEDE_PRIORITY || []).find(s => sedesDetected.has(s));\n    if (prioritized) return { sede: prioritized, source: 'multiple_sedes_prioritized', warning: `M√∫ltiples sedes detectadas: ${Array.from(sedesDetected).join(', ')}, usando ${prioritized}`, calendarIds };\n  }\n  return { sede: null, source: 'unable_to_detect', error: 'No se pudo determinar sede', calendarIds };\n}\n\n// ==================== EXTRACCI√ìN DE BUSY (con filtro por sede) ====================\nfunction extractBusyPairs(json, opts) {\n  const { maxIntervals, DTF_FULL, MIN_INTERVAL_MS, MAX_INTERVAL_DAYS, wsMs, weMs, allowedCalIds } = opts;\n  const pairs = []; const calendarIds = []; const errors = [];\n  const skippedCalendars = [];\n\n  // Formato 1: { calendars: { calId: { busy: [...] } } }\n  if (json && json.calendars && typeof json.calendars === 'object') {\n    for (const calId of Object.keys(json.calendars)) {\n      if (Array.isArray(allowedCalIds) && allowedCalIds.length && !allowedCalIds.includes(calId)) {\n        skippedCalendars.push(calId);\n        continue; // estricto: solo calendarios de SAT√âLITE\n      }\n      calendarIds.push(calId);\n      const arr = json.calendars[calId]?.busy || [];\n      if (arr.length > maxIntervals) errors.push(`Calendar ${calId} tiene ${arr.length} intervalos, tomando primeros ${maxIntervals}`);\n      const toProcess = arr.slice(0, maxIntervals);\n      for (const it of toProcess) {\n        const v = validateInterval(it, `calendar:${calId}`);\n        if (!v.valid) { errors.push(v.error); continue; }\n        const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n        for (const [s, e] of splits) {\n          const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS);\n          if (cl) pairs.push(cl);\n        }\n      }\n    }\n    return { pairs, calendarIds, errors, skippedCalendars };\n  }\n\n  // Formato 2: { busy: [...] }\n  if (Array.isArray(json?.busy)) {\n    const arr = json.busy.slice(0, maxIntervals);\n    for (const it of arr) {\n      const v = validateInterval(it, 'direct_busy');\n      if (!v.valid) { errors.push(v.error); continue; }\n      const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n      for (const [s, e] of splits) {\n        const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS);\n        if (cl) pairs.push(cl);\n      }\n    }\n    return { pairs, calendarIds, errors, skippedCalendars };\n  }\n\n  // Formato 3: array directo\n  if (Array.isArray(json)) {\n    const arr = json.slice(0, maxIntervals);\n    for (const it of arr) {\n      const v = validateInterval(it, 'array');\n      if (!v.valid) { errors.push(v.error); continue; }\n      const splits = splitMultidayInterval(v.sMs, v.eMs, DTF_FULL, MAX_INTERVAL_DAYS);\n      for (const [s, e] of splits) {\n        const cl = clampMs(s, e, wsMs, weMs, MIN_INTERVAL_MS);\n        if (cl) pairs.push(cl);\n      }\n    }\n    return { pairs, calendarIds, errors, skippedCalendars };\n  }\n\n  return { pairs, calendarIds, errors, skippedCalendars };\n}\n\n// ==================== MAIN ====================\ntry {\n  const startTime = DEBUG ? Date.now() : 0;\n  const items = $input.all();\n\n  // 0) Mapping de calendarios\n  const calendarMappingData = loadCalendarMapping();\n  const CALENDAR_ID_TO_SEDE = calendarMappingData.CALENDAR_ID_TO_SEDE || {};\n  const SEDE_TO_CALENDAR_IDS = Object.entries(CALENDAR_ID_TO_SEDE)\n    .reduce((acc, [calId, sede]) => { (acc[sede] ||= []).push(calId); return acc; }, {});\n  const allowedCalIds = SEDE_TO_CALENDAR_IDS[EXPECTED_SEDE] || [];\n  if (DEBUG) {\n    console.log('üìã Calendar mapping (SAT√âLITE):', {\n      source: calendarMappingData.source,\n      version: calendarMappingData.version,\n      expectedSede: EXPECTED_SEDE,\n      allowedCalIds,\n      totalCalendars: Object.keys(CALENDAR_ID_TO_SEDE).length,\n    });\n  }\n\n  // 1) Context desde SET_DEFAULTS\n  let wsMs = null, weMs = null, slotDefaultMin = 30;\n  let requestId = `normalize-${Date.now()}`;\n  let effectiveTZ = DEFAULT_TZ;\n  let explicitSede = EXPECTED_SEDE; // modo estricto\n\n  try {\n    const setDefaultsItems = $('SET_DEFAULTS').all();\n    if (setDefaultsItems && setDefaultsItems.length > 0) {\n      const ctx = setDefaultsItems[0].json;\n      if (ctx?.kind === 'context') {\n        if (ctx.windowStart) wsMs = toMs(ctx.windowStart);\n        if (ctx.windowEnd) weMs = toMs(ctx.windowEnd);\n        if (Number.isFinite(ctx.constraints?.slotMinutes)) {\n          slotDefaultMin = Math.max(10, Math.min(120, ctx.constraints.slotMinutes));\n        }\n        if (ctx.requestId) requestId = ctx.requestId;\n        if (ctx.tz) effectiveTZ = ctx.tz;\n        // Si vino sedePreferida distinta a SAT√âLITE, lo avisamos pero mantenemos estricto a SAT√âLITE\n        if (ctx.sedePreferida && String(ctx.sedePreferida).toUpperCase() !== EXPECTED_SEDE) {\n          log('WARN', 'sedePreferida distinta al nodo SAT√âLITE; se ignorar√° y se usar√° SAT√âLITE', {\n            sedePreferida: ctx.sedePreferida, expected: EXPECTED_SEDE,\n          });\n        }\n        if (DEBUG) console.log('‚úÖ Context cargado desde SET_DEFAULTS', {\n          windowStart: ctx.windowStart, windowEnd: ctx.windowEnd, tz: effectiveTZ, requestId,\n        });\n      } else {\n        console.warn('‚ö†Ô∏è SET_DEFAULTS no retorn√≥ context v√°lido, kind:', ctx?.kind);\n      }\n    } else {\n      console.warn('‚ö†Ô∏è No se encontr√≥ SET_DEFAULTS en items');\n    }\n  } catch (err) {\n    console.warn('‚ö†Ô∏è Error obteniendo context de SET_DEFAULTS:', err.message);\n  }\n\n  // 2) TZ/CFG\n  const { DTF_FULL } = getFormatters(effectiveTZ);\n  const CFG = loadConfig();\n\n  // 3) Procesar entradas con filtro de calendarios de SAT√âLITE\n  const rawPairs = []; const allCalendarIds = new Set(); const errors = []; const skippedCalGlobal = new Set();\n  for (let i = 0; i < items.length; i++) {\n    const json = items[i]?.json || {};\n    const vr = validateGoogleCalendarResponse(json);\n    if (!vr.valid) { errors.push(vr.message); continue; }\n\n    const ext = extractBusyPairs(json, {\n      maxIntervals: CFG.MAX_BUSY_INTERVALS,\n      DTF_FULL,\n      MIN_INTERVAL_MS: CFG.MIN_INTERVAL_MS,\n      MAX_INTERVAL_DAYS: CFG.MAX_INTERVAL_DAYS,\n      wsMs, weMs,\n      allowedCalIds, // üîí estricto SAT√âLITE\n    });\n\n    ext.calendarIds.forEach(cid => allCalendarIds.add(cid));\n    if (Array.isArray(ext.skippedCalendars) && ext.skippedCalendars.length) {\n      ext.skippedCalendars.forEach(cid => skippedCalGlobal.add(cid));\n    }\n    rawPairs.push(...ext.pairs);\n    if (ext.errors.length) errors.push(...ext.errors);\n  }\n\n  // 4) Detecci√≥n/validaci√≥n de sede (estricto SAT√âLITE)\n  const calendarIdsArray = Array.from(allCalendarIds);\n  const sedeDetection = detectSede(calendarIdsArray, explicitSede, CALENDAR_ID_TO_SEDE, CFG.SEDE_PRIORITY);\n  if (!sedeDetection.sede) {\n    return [{\n      json: {\n        kind: 'busy',\n        sede: null,\n        busy: [],\n        busyBySede: {},\n        sourceStatus: {\n          ok: false,\n          sede: null,\n          tz: effectiveTZ,\n          requestId,\n          errors: [sedeDetection.error || 'No se pudo determinar SEDE'],\n          skippedCalendars: Array.from(skippedCalGlobal),\n          sedeDetection,\n          build: { version: BUILD_VERSION, generatedAt: new Date().toISOString(), scheduleVersion: calendarMappingData.version },\n          calendarMappingSource: calendarMappingData.source,\n        }\n      }\n    }];\n  }\n\n  const SEDE = sedeDetection.sede; // deber√≠a ser SAT√âLITE\n  if (SEDE !== EXPECTED_SEDE) {\n    errors.push(`Detecci√≥n de sede inesperada: ${SEDE} (se esperaba ${EXPECTED_SEDE})`);\n  }\n  if (sedeDetection.warning) errors.push(sedeDetection.warning);\n\n  // 5) Merge + off-grid\n  const mergedPairs = mergeExclusiveMs(rawPairs);\n  const offGridDetails = checkOffGrid(mergedPairs, CFG.ANCHORS);\n\n  // 6) Salida normalizada\n  const busy = mergedPairs.map(([sMs, eMs]) => ({ sede: SEDE, start: toISO(sMs), end: toISO(eMs) }));\n\n  // 7) M√©tricas\n  const metrics = {\n    totalItems: items.length,\n    totalRaw: rawPairs.length,\n    merged: mergedPairs.length,\n    offGridCount: offGridDetails.length,\n    calendarIds: calendarIdsArray,\n    skippedCalendars: Array.from(skippedCalGlobal),\n    executionTimeMs: DEBUG ? (Date.now() - startTime) : undefined,\n  };\n\n  const status = {\n    ok: errors.length === 0,\n    sede: SEDE,\n    sedeDetection,\n    tz: effectiveTZ,\n    requestId,\n    calendarMappingSource: calendarMappingData.source,\n    window: {\n      start: wsMs != null ? toISO(wsMs) : null,\n      end:  weMs != null ? toISO(weMs) : null,\n    },\n    policy: {\n      source: 'freebusy',\n      slotDefaultMin: slotDefaultMin,\n      maxIntervals: CFG.MAX_BUSY_INTERVALS,\n      maxIntervalDays: CFG.MAX_INTERVAL_DAYS,\n      anchors: CFG.ANCHORS,\n    },\n    metrics,\n    offGridDetails: offGridDetails.length ? offGridDetails : undefined,\n    errors,\n    build: { version: BUILD_VERSION, generatedAt: new Date().toISOString(),\n      scheduleVersion: calendarMappingData.version,\n    },\n    _logs: DEBUG ? LOGS : undefined,\n  };\n\n  log('SUCCESS', '‚úÖ NORMALIZE_BUSY (SAT√âLITE) completado', { totalBusy: busy.length, offGrid: offGridDetails.length });\n\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE,\n      busy,\n      busyBySede: { [SEDE]: busy },\n      sourceStatus: status,\n    },\n    pairedItem: items.map((_, i) => ({ item: i })),\n  }];\n\n} catch (err) {\n  log('ERROR', 'Error fatal', { error: err?.message, stack: err?.stack });\n  return [{\n    json: {\n      kind: 'busy',\n      sede: EXPECTED_SEDE,\n      busy: [],\n      busyBySede: {},\n      sourceStatus: {\n        ok: false,\n        sede: EXPECTED_SEDE,\n        errors: [String(err?.message || err)],\n        stack: DEBUG ? err?.stack : undefined,\n        build: { version: BUILD_VERSION, generatedAt: new Date().toISOString() },\n      }\n    }\n  }];\n}\n"
      },
      "id": "507c34ec-8170-4825-8920-3fb6241f83e8",
      "name": "Normalize Busy SATELITE1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        272
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  sede,\n  horario_json,\n  calendar_id,\n  display_name,\n  direccion,\n  maps_url,\n  anchor_date,\n  anchor_week_type\nFROM public.sedes\nWHERE horario_json IS NOT NULL;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1392,
        176
      ],
      "id": "bd19c208-2d3c-4be5-a2e3-dd5f4a447828",
      "name": "VERIFICAR HORARIOS DE SEDES1",
      "credentials": {
        "postgres": {
          "id": "LZyK5sbzVT7Dy3RU",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * CARGAR_HORARIOS v3.0.0\n * ---------------------------------\n * - Recibe filas desde un nodo previo (SELECT sobre public.sedes en Supabase/Postgres)\n * - Construye el objeto SCHEDULE:\n *   - sedes: horarios por sede y d√≠a\n *   - meta: metadatos por sede (nombre, direcci√≥n, calendarId, etc.)\n *   - config: par√°metros globales de agenda\n *   - anchor: semana de referencia\n * - Guarda SCHEDULE y HELPERS en Workflow Static Data (global)\n * - Devuelve un resumen legible para depuraci√≥n\n */\n\nconst VERSION = '3.0.0';\nconst DEFAULT_TZ = 'America/Mexico_City';\nconst LOGS = [];\nconst DEBUG = true;\n\n// ---------- LOGGING ----------\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'CARGAR_HORARIOS',\n    version: VERSION,\n    message,\n    ...data,\n  };\n  LOGS.push(entry);\n  if (DEBUG) {\n    console.log(`[${entry.level}] ${entry.component} :: ${entry.message}`, data);\n  }\n}\n\n// ---------- VALIDACI√ìN DE HORARIOS ----------\nconst isHHMM = (s) => {\n  if (typeof s !== 'string') return false;\n  const m = /^(\\d{2}):(\\d{2})$/.exec(s);\n  if (!m) return false;\n  const hh = +m[1];\n  const mm = +m[2];\n  return hh >= 0 && hh <= 23 && mm >= 0 && mm <= 59;\n};\n\nconst validateShift = (shift, sede, dow, ctx = {}) => {\n  if (!Array.isArray(shift) || shift.length < 2) {\n    log('error', 'Shift inv√°lido (no es array o faltan elementos)', { sede, dow, shift, ctx });\n    return false;\n  }\n  const [start, end, label] = shift;\n\n  if (!isHHMM(start)) {\n    log('error', 'Start time inv√°lido', { sede, dow, start, ctx });\n    return false;\n  }\n  if (!isHHMM(end)) {\n    log('error', 'End time inv√°lido', { sede, dow, end, ctx });\n    return false;\n  }\n\n  const toMin = (s) => {\n    const [h, m] = s.split(':').map(Number);\n    return h * 60 + m;\n  };\n\n  if (toMin(start) >= toMin(end)) {\n    log('error', 'start >= end', { sede, dow, start, end, ctx });\n    return false;\n  }\n\n  if (!label || typeof label !== 'string') {\n    log('warn', 'Label faltante o inv√°lido', { sede, dow, label, ctx });\n  }\n\n  return true;\n};\n\n// ---------- HELPERS PARA SCHEDULE ----------\nfunction getDayOfWeekInTZ(dateISO, tz) {\n  const dayName = new Intl.DateTimeFormat('en-US', {\n    timeZone: tz,\n    weekday: 'short',\n  }).format(new Date(dateISO));\n  const map = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\n  return map[dayName];\n}\n\nfunction sedeHasScheduleOnDay(SCHEDULE, sede, dow) {\n  const sedeSchedule = SCHEDULE.sedes[sede];\n  if (!sedeSchedule) return false;\n  return Object.prototype.hasOwnProperty.call(sedeSchedule, dow);\n}\n\nfunction classifyTimeRange(hhmm) {\n  const hour = Number(hhmm.split(':')[0] || '0');\n  return hour < 14 ? 'morning' : 'afternoon';\n}\n\nfunction getShiftsForSedeAndDay(SCHEDULE, sede, dow, weekType = null) {\n  const sedeSchedule = SCHEDULE.sedes[sede];\n  if (!sedeSchedule) return [];\n  if (!Object.prototype.hasOwnProperty.call(sedeSchedule, dow)) return [];\n\n  const conf = sedeSchedule[dow];\n\n  // Caso simple: array de turnos\n  if (Array.isArray(conf)) return conf;\n\n  // Caso alterno: { A: [...], B: [...] }\n  if (conf && typeof conf === 'object') {\n    if (!weekType) {\n      return Object.values(conf).flat();\n    }\n    return conf[weekType] || [];\n  }\n\n  return [];\n}\n\nfunction getWorkingDays(SCHEDULE, sede) {\n  return SCHEDULE.meta[sede]?.workingDays || [];\n}\n\nfunction isWorkingDay(SCHEDULE, sede, dow) {\n  return getWorkingDays(SCHEDULE, sede).includes(dow);\n}\n\nfunction buildHelpers(SCHEDULE) {\n  return {\n    getDayOfWeekInTZ: (dateISO, tz = SCHEDULE.tz) => getDayOfWeekInTZ(dateISO, tz),\n    sedeHasScheduleOnDay: (sede, dow) => sedeHasScheduleOnDay(SCHEDULE, sede, dow),\n    classifyTimeRange,\n    getShiftsForSedeAndDay: (sede, dow, weekType) =>\n      getShiftsForSedeAndDay(SCHEDULE, sede, dow, weekType),\n    getAllSedes: () => Object.keys(SCHEDULE.sedes),\n    sedeExists: (sede) => Object.prototype.hasOwnProperty.call(SCHEDULE.sedes, sede),\n    normalizeSede: (input) => {\n      if (!input) return null;\n      const lower = String(input).toLowerCase().trim();\n      // Omitimos la clave especial \"sedes\" en meta\n      for (const [sede, meta] of Object.entries(SCHEDULE.meta)) {\n        if (sede === 'sedes') continue;\n        if (\n          meta.aliases &&\n          meta.aliases.some((a) => String(a).toLowerCase().trim() === lower)\n        ) {\n          return sede;\n        }\n      }\n      return null;\n    },\n    getWorkingDays: (sede) => getWorkingDays(SCHEDULE, sede),\n    isWorkingDay: (sede, dow) => isWorkingDay(SCHEDULE, sede, dow),\n  };\n}\n\n// ---------- MAIN ----------\n\nlog('info', `CARGAR_HORARIOS v${VERSION} iniciando`);\n\n// 1) LEER INPUT DEL NODO SQL / HTTP ANTERIOR\nconst rows = $input.all().map((item) => item.json || item);\n\nif (!rows || rows.length === 0) {\n  log('error', 'No se recibieron filas desde el nodo de BD (input vac√≠o)');\n  throw new Error(\n    'CARGAR_HORARIOS: input vac√≠o. Aseg√∫rate de conectar el nodo que hace SELECT/HTTP sobre la tabla \"sedes\".'\n  );\n}\n\nlog('info', 'Filas recibidas desde nodo BD', { count: rows.length });\n\n// 2) CONSTRUIR SCHEDULE\nconst SCHEDULE = {\n  tz: DEFAULT_TZ,\n  version: VERSION,\n  anchor: null,\n  rest: { 0: 'Domingo - Cerrado' },\n  sedes: {},\n  meta: { sedes: {} }, // meta por sede + mapa agrupado en meta.sedes\n  config: {\n    consultationDuration: 30,\n    slotAnchors: [0, 30],\n    shortNoticeMinutes: 120,\n    confirmationBufferMinutes: 15,\n    defaultWindowDays: 14,\n    maxWindowDays: 90,\n    maxSlots: 50,\n    businessDayStart: 8,\n    businessDayEnd: 20,\n  },\n};\n\nlet totalShifts = 0;\nlet validShifts = 0;\nconst errors = [];\n\n// 2.1 Anchor global: tomamos la primera fila con anchor_date\nfor (const row of rows) {\n  if (row.anchor_date) {\n    SCHEDULE.anchor = {\n      date: row.anchor_date,\n      type: row.anchor_week_type || 'A',\n      description: 'Semana de referencia (desde sedes)',\n    };\n    break;\n  }\n}\n\nif (!SCHEDULE.anchor) {\n  SCHEDULE.anchor = {\n    date: '2025-01-06',\n    type: 'A',\n    description: 'Anchor por defecto (no definido en DB)',\n  };\n  log('warn', 'No se encontr√≥ anchor_date en sedes; usando anchor por defecto', {\n    anchor: SCHEDULE.anchor,\n  });\n}\n\n// 2.2 Procesar cada sede\nfor (const row of rows) {\n  const sedeKey = (row.sede || '').toUpperCase().trim();\n  if (!sedeKey) {\n    log('warn', 'Fila sin sede, se omite', { row });\n    continue;\n  }\n\n  let horarioJson = row.horario_json;\n  if (!horarioJson) {\n    log('warn', `Sede ${sedeKey} sin horario_json, se omite`);\n    continue;\n  }\n\n  // Si viene como string, lo parseamos\n  if (typeof horarioJson === 'string') {\n    try {\n      horarioJson = JSON.parse(horarioJson);\n    } catch (e) {\n      log('error', `No se pudo parsear horario_json de sede ${sedeKey}`, {\n        raw: row.horario_json,\n        error: e.message,\n      });\n      continue;\n    }\n  }\n\n  if (typeof horarioJson !== 'object' || Array.isArray(horarioJson)) {\n    log('error', `horario_json de sede ${sedeKey} no es un objeto`, { horarioJson });\n    continue;\n  }\n\n  const sedeSchedule = {};\n\n  for (const [dowStr, conf] of Object.entries(horarioJson)) {\n    const dow = Number(dowStr);\n    if (Number.isNaN(dow) || dow < 0 || dow > 6) {\n      log('warn', `D√≠a de semana inv√°lido ${dowStr} en sede ${sedeKey}, se omite`);\n      continue;\n    }\n\n    // Caso simple: [[\"09:00\",\"13:00\",\"Label\"], ...]\n    if (Array.isArray(conf)) {\n      const validatedShifts = [];\n      for (const shift of conf) {\n        totalShifts++;\n        if (validateShift(shift, sedeKey, dow, { mode: 'simple' })) {\n          validShifts++;\n          validatedShifts.push(shift);\n        } else {\n          errors.push({ sede: sedeKey, dow, shift });\n        }\n      }\n      if (validatedShifts.length > 0) {\n        sedeSchedule[dow] = validatedShifts;\n      }\n      continue;\n    }\n\n    // Caso alterno: { \"A\": [...], \"B\": [...] }\n    if (conf && typeof conf === 'object') {\n      const weekTypeSchedule = {};\n      for (const [weekType, arr] of Object.entries(conf)) {\n        if (!Array.isArray(arr)) {\n          log('warn', `weekType ${weekType} no es array en sede ${sedeKey} dow ${dow}`, {\n            conf,\n          });\n          continue;\n        }\n        const validatedShifts = [];\n        for (const shift of arr) {\n          totalShifts++;\n          if (validateShift(shift, sedeKey, dow, { mode: 'alterno', weekType })) {\n            validShifts++;\n            validatedShifts.push(shift);\n          } else {\n            errors.push({ sede: sedeKey, dow, weekType, shift });\n          }\n        }\n        if (validatedShifts.length > 0) {\n          weekTypeSchedule[weekType] = validatedShifts;\n        }\n      }\n      if (Object.keys(weekTypeSchedule).length > 0) {\n        sedeSchedule[dow] = weekTypeSchedule;\n      }\n      continue;\n    }\n\n    log('warn', `Config de d√≠a ${dowStr} en sede ${sedeKey} no es array ni objeto, se omite`, {\n      conf,\n    });\n  }\n\n  if (Object.keys(sedeSchedule).length === 0) {\n    log('warn', `Sede ${sedeKey} no tiene horarios v√°lidos despu√©s de la validaci√≥n`);\n    continue;\n  }\n\n  // Guardar horarios v√°lidos\n  SCHEDULE.sedes[sedeKey] = sedeSchedule;\n\n  const workingDays = Object.keys(sedeSchedule)\n    .map((d) => Number(d))\n    .filter((d) => !Number.isNaN(d))\n    .sort((a, b) => a - b);\n\n  const metaForSede = {\n    name: row.display_name || sedeKey,\n    fullName: row.display_name || sedeKey,\n    location: row.direccion || '',\n    aliases: [\n      sedeKey,\n      sedeKey.toLowerCase(),\n      ...(row.display_name ? [String(row.display_name).toLowerCase()] : []),\n    ],\n    calendarId: row.calendar_id,\n    workingDays,\n    hasWeekends: workingDays.includes(6),\n    timezone: row.timezone || DEFAULT_TZ,\n    maps_url: row.maps_url || null,\n    telefono: row.telefono || null,\n    whatsapp: row.whatsapp || null,\n  };\n\n  // Meta accesible por clave directa (SCHEDULE.meta['POLANCO'])\n  SCHEDULE.meta[sedeKey] = metaForSede;\n  // Y tambi√©n agrupada bajo meta.sedes['POLANCO'] (para nodos que lean as√≠)\n  SCHEDULE.meta.sedes[sedeKey] = metaForSede;\n}\n\n// Alias de conveniencia\nSCHEDULE.metadata = SCHEDULE.meta;\n\nconst stats = {\n  totalSedes: Object.keys(SCHEDULE.sedes).length,\n  totalShifts,\n  validShifts,\n  sedesWithWeekends: Object.values(SCHEDULE.meta)\n    .filter((m) => m && typeof m === 'object' && m.hasWeekends)\n    .length,\n  errors: errors.length,\n};\n\nlog('info', 'Transformaci√≥n a SCHEDULE completada', stats);\n\nif (stats.totalSedes === 0) {\n  log('error', 'Ninguna sede v√°lida despu√©s de procesar horarios');\n  throw new Error(\n    'CARGAR_HORARIOS: no hay sedes v√°lidas. Revisa horario_json en la tabla \"sedes\".'\n  );\n}\n\n// 3) HELPERS\nconst HELPERS = buildHelpers(SCHEDULE);\n\n// 4) GUARDAR EN WORKFLOW STATIC DATA\nconst store =\n  typeof $getWorkflowStaticData === 'function'\n    ? $getWorkflowStaticData('global')\n    : this.getWorkflowStaticData('global');\n\nstore.SCHEDULE = SCHEDULE;\nstore.SCHEDULE_HELPERS = HELPERS;\nstore.SCHEDULE_VERSION = SCHEDULE.version || VERSION;\nstore.SCHEDULE_SOURCE = 'SUPABASE';\nstore.SCHEDULE_UPDATED_AT = new Date().toISOString();\n\nlog('info', 'SCHEDULE guardado en Workflow Static Data', {\n  version: store.SCHEDULE_VERSION,\n  source: store.SCHEDULE_SOURCE,\n});\n\n// 5) RESUMEN LEGIBLE PARA VER EN LA SALIDA DEL NODO\nconst resume = {};\nfor (const [sede, days] of Object.entries(SCHEDULE.sedes)) {\n  resume[sede] = {};\n  for (const [dow, conf] of Object.entries(days)) {\n    if (Array.isArray(conf)) {\n      resume[sede][dow] = conf.map((s) => `${s[0]}-${s[1]} (${s[2] || ''})`);\n    } else if (conf && typeof conf === 'object') {\n      resume[sede][dow] = {};\n      for (const [wt, arr] of Object.entries(conf)) {\n        resume[sede][dow][wt] = arr.map((s) => `${s[0]}-${s[1]} (${s[2] || ''})`);\n      }\n    }\n  }\n}\n\n// 6) OUTPUT\nreturn [\n  {\n    json: {\n      kind: 'config',\n      component: 'CARGAR_HORARIOS',\n      version: store.SCHEDULE_VERSION,\n      source: 'SUPABASE',\n      dbRowCount: rows.length,\n      updatedAt: store.SCHEDULE_UPDATED_AT,\n      tz: SCHEDULE.tz,\n      anchor: SCHEDULE.anchor,\n      config: SCHEDULE.config,\n      meta: SCHEDULE.meta,\n      sedesMap: SCHEDULE.sedes,\n      stats,\n      resume,\n      sedeKeys: Object.keys(SCHEDULE.sedes),\n      logs: LOGS,\n      success: true,\n      message: `‚úÖ SCHEDULE v${store.SCHEDULE_VERSION} cargado desde BD (${rows.length} filas)`,\n    },\n  },\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        176
      ],
      "id": "cc591c7a-aeac-4ebc-b056-cb92785bb447",
      "name": "CARGAR_HORARIOS"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * SET_DEFAULTS v5.4.0 ‚Äî production ready\n * - Carga SCHEDULE en este orden: input (CARGAR_HORARIOS) ‚Üí nodo CARGAR_HORARIOS ‚Üí WorkflowStaticData\n * - Usa sedesMap (objeto real) y meta (aliases) si est√°n presentes\n * - Config efectiva viene de SCHEDULE.config con fallback a CONFIG local\n * - Soporta ‚Äúpr√≥ximo {d√≠a}‚Äù, ‚Äúeste {d√≠a}‚Äù, d√≠a suelto y relativos (hoy/ma√±ana/pasado ma√±ana)\n * - Limita f√≠sicamente la ventana a maxWindowDays\n * - Normaliza windowDays y maxResults del input\n * - Devuelve windowStart/windowEnd en ISO local 00:00 y llaves YMD para compatibilidad\n */\n\nconst VERSION = '5.4.0';\nconst DEBUG = false;\n\n/* ===================== CONFIG BASE ===================== */\nconst CONFIG = Object.freeze({\n  DEFAULT_WINDOW_DAYS: 14,\n  MAX_WINDOW_DAYS: 90,\n  MAX_INPUT_LENGTH: 500,\n  SLOT_MINUTES: 30,\n  SHORT_NOTICE_MIN: 120,\n  CONFIRMATION_BUFFER_MIN: 15,\n  TZ: 'America/Mexico_City',\n  DAY_NAME_TO_DOW: {\n    'domingo': 0,\n    'lunes': 1,\n    'martes': 2,\n    'miercoles': 3,\n    'mi√©rcoles': 3,\n    'jueves': 4,\n    'viernes': 5,\n    'sabado': 6,\n    's√°bado': 6,\n  },\n  RELATIVE_BASE: ['hoy', 'ma√±ana', 'manana', 'pasado', 'pasado ma√±ana', 'pasado manana'],\n});\n\nconst LOGS = [];\nconst log = (lvl, msg, data = {}) => {\n  if (!DEBUG && lvl === 'DEBUG') return;\n  LOGS.push({\n    timestamp: new Date().toISOString(),\n    level: lvl,\n    component: 'SET_DEFAULTS',\n    version: VERSION,\n    message: msg,\n    ...data,\n  });\n  if (DEBUG) console.log(`[${lvl}] ${msg}`, data);\n};\n\n/* ===================== FECHAS / TZ ===================== */\nfunction dtPartsInTZ(d, tz) {\n  const dtf = new Intl.DateTimeFormat('en-CA', {\n    timeZone: tz,\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n  const p = dtf.formatToParts(d).reduce((A, x) => ((A[x.type] = x.value), A), {});\n  return { y: +p.year, m: +p.month, d: +p.day, hh: +p.hour, mm: +p.minute, ss: +p.second };\n}\nfunction ymdInTZ(d, tz) {\n  const p = dtPartsInTZ(d, tz);\n  return `${p.y}-${String(p.m).padStart(2, '0')}-${String(p.d).padStart(2, '0')}`;\n}\nfunction isoStartOfDayLocal(dateKey, tz) {\n  const [y, m, d] = dateKey.split('-').map(Number);\n  // construir 00:00:00 local en tz (corrigiendo DST)\n  const guess = new Date(Date.UTC(y, m - 1, d, 0, 0, 0));\n  const seen = dtPartsInTZ(guess, tz);\n  // queremos y-m-d 00:00 locales\n  const want = Date.UTC(y, m - 1, d, 0, 0, 0);\n  const seenMs = Date.UTC(seen.y, seen.m - 1, seen.d, seen.hh, seen.mm, seen.ss);\n  const corrected = new Date(guess.getTime() + (want - seenMs));\n  return corrected.toISOString();\n}\nfunction addDaysYMD(dateKey, days) {\n  const [y, m, d] = dateKey.split('-').map(Number);\n  const u = Date.UTC(y, m - 1, d, 12, 0, 0);\n  const n = new Date(u + days * 86400000);\n  return `${n.getUTCFullYear()}-${String(n.getUTCMonth() + 1).padStart(2, '0')}-${String(\n    n.getUTCDate(),\n  ).padStart(2, '0')}`;\n}\nfunction getUTCDayFromYMD(dateKey) {\n  const [y, m, d] = dateKey.split('-').map(Number);\n  return new Date(Date.UTC(y, m - 1, d, 12, 0, 0)).getUTCDay();\n}\nfunction findNextDow(fromYMD, targetDow, strict) {\n  // strict=true: m√≠nimo +1 d√≠a; strict=false: puede ser el mismo d√≠a\n  let cur = fromYMD;\n  for (let i = 0; i < 8; i++) {\n    const dow = getUTCDayFromYMD(cur);\n    if (dow === targetDow && (!strict ? true : i > 0)) return cur;\n    cur = addDaysYMD(cur, 1);\n  }\n  return cur;\n}\n\n/* ===================== SCHEDULE LOADER ===================== */\nfunction pickSedesFromInput(inputJson) {\n  // Preferir sedesMap (objeto real con turnos), nunca resume (strings)\n  if (inputJson?.sedesMap && typeof inputJson.sedesMap === 'object') return inputJson.sedesMap;\n  if (inputJson?.sedes && typeof inputJson.sedes === 'object' && !Array.isArray(inputJson.sedes))\n    return inputJson.sedes;\n  return null;\n}\nfunction loadSchedule(json) {\n  // 1) Input directo del caller (CARGAR_HORARIOS)\n  if (json?.kind === 'config' && json?.component === 'CARGAR_HORARIOS') {\n    const sedes = pickSedesFromInput(json) || {};\n    const schedule = {\n      tz: json.tz || CONFIG.TZ,\n      anchor: json.anchor,\n      rest: json.rest || {},\n      sedes,\n      meta: json.meta || {},\n      config: json.config || {},\n    };\n    log('SUCCESS', 'SCHEDULE desde input', {\n      version: json.version,\n      sedes: Object.keys(schedule.sedes),\n    });\n    return { schedule, version: json.version, updatedAt: json.updatedAt };\n  }\n\n  // 2) Intentar leer la salida del nodo CARGAR_HORARIOS (si existe en el grafo)\n  try {\n    const n = $('CARGAR_HORARIOS').first().json;\n    if (n?.kind === 'config') {\n      const sedes = pickSedesFromInput(n) || {};\n      const schedule = {\n        tz: n.tz || CONFIG.TZ,\n        anchor: n.anchor,\n        rest: n.rest || {},\n        sedes,\n        meta: n.meta || {},\n        config: n.config || {},\n      };\n      log('SUCCESS', 'SCHEDULE desde nodo CARGAR_HORARIOS', {\n        version: n.version,\n        sedes: Object.keys(schedule.sedes),\n      });\n      return { schedule, version: n.version, updatedAt: n.updatedAt };\n    }\n  } catch (e) {\n    /* no-op */\n  }\n\n  // 3) WorkflowStaticData (global)\n  try {\n    const store =\n      typeof $getWorkflowStaticData === 'function'\n        ? $getWorkflowStaticData('global')\n        : this.getWorkflowStaticData('global');\n    if (store?.SCHEDULE?.sedes) {\n      const S = store.SCHEDULE;\n      const schedule = {\n        tz: S.tz || CONFIG.TZ,\n        anchor: S.anchor,\n        rest: S.rest || {},\n        sedes: S.sedes,\n        meta: S.meta || {},\n        config: S.config || {},\n      };\n      log('SUCCESS', 'SCHEDULE desde WorkflowStaticData', {\n        version: store.SCHEDULE_VERSION,\n        sedes: Object.keys(schedule.sedes),\n      });\n      return {\n        schedule,\n        version: store.SCHEDULE_VERSION,\n        updatedAt: store.SCHEDULE_UPDATED_AT,\n      };\n    }\n  } catch (e) {\n    /* no-op */\n  }\n\n  throw new Error('SCHEDULE no disponible. Ejecuta CARGAR_HORARIOS o publica al static data.');\n}\n\n/* ===================== PARSERS ===================== */\nconst norm = (s) =>\n  (s || '')\n    .toLowerCase()\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n\nfunction extractUserText(json) {\n  const raw =\n    json.userText ||\n    json.query ||\n    json.text ||\n    json.message ||\n    json.user_query ||\n    json.content ||\n    (json.__intent && json.__intent.userText) ||\n    '';\n  const t = String(raw).trim();\n  if (!t) return { ok: false, raw: '', normalized: '' };\n  if (t.length > CONFIG.MAX_INPUT_LENGTH) {\n    const cut = t.slice(0, CONFIG.MAX_INPUT_LENGTH);\n    return { ok: true, raw: cut, normalized: norm(cut) };\n  }\n  return { ok: true, raw: t, normalized: norm(t) };\n}\n\nfunction fuzzySedeFromText(text, meta) {\n  if (!text) return { sedePreferida: '', strict: false };\n  const found = [];\n  const metas = meta && typeof meta === 'object' ? meta : {};\n  for (const [sede, m] of Object.entries(metas)) {\n    const aliases = (m.aliases || []).map((a) => String(a).toLowerCase());\n    if (aliases.some((a) => text.includes(a))) found.push(sede);\n  }\n  if (found.length === 1) return { sedePreferida: found[0], strict: true };\n  if (found.length > 1) return { sedePreferida: found[0], strict: false };\n  return { sedePreferida: '', strict: false };\n}\n\nfunction parseDatesFromText(text, tz, referenceYMD, defaultWindowDays, maxWindowDays) {\n  // Detecta ‚Äúpr√≥ximo {d√≠a}‚Äù, ‚Äúsiguiente {d√≠a}‚Äù, ‚Äúeste {d√≠a}‚Äù, o d√≠a suelto\n  // Prioridad: pr√≥ximo/siguiente > este > d√≠a suelto\n  const explicit = [];\n  const lower = text;\n\n  const dowMap = CONFIG.DAY_NAME_TO_DOW;\n  const dowNames = Object.keys(dowMap).sort((a, b) => b.length - a.length); // evita colisiones (mi√© vs miercoles)\n  const findDowIn = (s) => {\n    for (const name of dowNames) if (s.includes(name)) return dowMap[name];\n    return null;\n  };\n\n  // pr√≥ximo/siguiente\n  if (/\\b(prox|proximo|pr√≥ximo|siguiente)\\b/.test(lower)) {\n    const d = findDowIn(lower);\n    if (d != null) {\n      explicit.push(findNextDow(referenceYMD, d, /*strict*/ true));\n    }\n  }\n  // este\n  else if (/\\b(este)\\b/.test(lower)) {\n    const d = findDowIn(lower);\n    if (d != null) {\n      explicit.push(findNextDow(referenceYMD, d, /*strict*/ false));\n    }\n  }\n  // d√≠a suelto\n  else {\n    const d = findDowIn(lower);\n    if (d != null) {\n      explicit.push(findNextDow(referenceYMD, d, /*strict*/ false));\n    }\n  }\n\n  // Relativos base (hoy/ma√±ana/pasado)\n  const rel = [\n    { re: /\\bhoy\\b/, add: 0 },\n    { re: /\\b(ma[√±n]ana)\\b/, add: 1 },\n    { re: /\\b(pasado(\\s+ma[√±n]ana)?)\\b/, add: 2 },\n  ];\n  for (const r of rel) if (r.re.test(lower)) explicit.push(addDaysYMD(referenceYMD, r.add));\n\n  const unique = Array.from(new Set(explicit)).sort();\n\n  // Ventana candidata\n  let windowStartYMD = referenceYMD;\n  let windowEndCandidateYMD = addDaysYMD(referenceYMD, defaultWindowDays);\n\n  if (unique.length > 0) {\n    windowStartYMD = unique[0];\n    windowEndCandidateYMD =\n      unique.length > 1 ? unique[unique.length - 1] : addDaysYMD(unique[0], 1);\n  }\n\n  // Clamp f√≠sico de la ventana a maxWindowDays\n  const maxSpan = Math.max(1, maxWindowDays || defaultWindowDays || 1);\n\n  const [sy, sm, sd] = windowStartYMD.split('-').map(Number);\n  const [ey, em, ed] = windowEndCandidateYMD.split('-').map(Number);\n  const startUTC = Date.UTC(sy, sm - 1, sd, 12, 0, 0);\n  const endUTC = Date.UTC(ey, em - 1, ed, 12, 0, 0);\n\n  let diffDays = Math.round((endUTC - startUTC) / 86400000);\n  if (!Number.isFinite(diffDays) || diffDays < 1) diffDays = 1;\n  if (diffDays > maxSpan) {\n    windowEndCandidateYMD = addDaysYMD(windowStartYMD, maxSpan);\n  }\n\n  const windowEndYMD = windowEndCandidateYMD;\n\n  return {\n    explicitDates: unique,\n    windowStartYMD,\n    windowEndYMD,\n    dateIntent: unique.length > 0 ? 'specific' : 'flexible',\n  };\n}\n\n/* ===================== MAIN ===================== */\ntry {\n  const t0 = Date.now();\n\n  // 1) Cargar schedule\n  const scheduleData = loadSchedule($json);\n  const SCHEDULE = scheduleData.schedule;\n  const TZ = SCHEDULE.tz || CONFIG.TZ;\n\n  // 1.1) Config efectiva tomada de SCHEDULE.config\n  const SCFG = SCHEDULE.config || {};\n  const EFFECTIVE = {\n    windowDefaultDays: SCFG.defaultWindowDays ?? CONFIG.DEFAULT_WINDOW_DAYS,\n    maxWindowDays: SCFG.maxWindowDays ?? CONFIG.MAX_WINDOW_DAYS,\n    slotMinutes: SCFG.consultationDuration ?? CONFIG.SLOT_MINUTES,\n    shortNoticeMin: SCFG.shortNoticeMinutes ?? CONFIG.SHORT_NOTICE_MIN,\n    confirmationBufferMin: SCFG.confirmationBufferMinutes ?? CONFIG.CONFIRMATION_BUFFER_MIN,\n  };\n\n  // 2) ‚ÄúAhora‚Äù en tz\n  const now = new Date();\n  const todayYMD = ymdInTZ(now, TZ);\n\n  // 3) Intento de texto\n  const textInfo = extractUserText($json);\n  const textNorm = textInfo.normalized;\n\n  // 4) Sede fuzzy desde meta\n  const sedeInfo = fuzzySedeFromText(textNorm, SCHEDULE.meta);\n\n  // 5) Punto de referencia para fechas\n  const hasDateWords =\n    CONFIG.RELATIVE_BASE.some((w) => textNorm.includes(w)) ||\n    Object.keys(CONFIG.DAY_NAME_TO_DOW).some((k) => textNorm.includes(k)) ||\n    /\\b(prox|proximo|pr√≥ximo|siguiente|este)\\b/.test(textNorm);\n\n  let referenceYMD = todayYMD;\n  if (!hasDateWords && $json.desiredStart) {\n    const ms = Date.parse($json.desiredStart);\n    if (Number.isFinite(ms)) referenceYMD = ymdInTZ(new Date(ms), TZ);\n  }\n\n  // 6) Parseo de fechas con l√≠mites de ventana\n  const dInfo = parseDatesFromText(\n    textNorm,\n    TZ,\n    referenceYMD,\n    EFFECTIVE.windowDefaultDays,\n    EFFECTIVE.maxWindowDays,\n  );\n\n  // 7) Construir ventana ISO (inicio/fin a medianoche local)\n  const windowStartISO = isoStartOfDayLocal(dInfo.windowStartYMD, TZ);\n  const windowEndISO = isoStartOfDayLocal(dInfo.windowEndYMD, TZ);\n\n  // 8) C√°lculo de d√≠as reales de ventana (clamp contra maxWindowDays)\n  const rawWindowDays = Math.ceil(\n    (new Date(windowEndISO) - new Date(windowStartISO)) / 86400000,\n  );\n  const computedWindowDays = Math.min(\n    Math.max(1, rawWindowDays || 1),\n    EFFECTIVE.maxWindowDays,\n  );\n\n  // 9) Normalizar windowDays y maxResults del input\n  const inWindowDays = Number.parseInt($json.windowDays, 10);\n  const safeWindowDays = Number.isFinite(inWindowDays)\n    ? Math.min(Math.max(1, inWindowDays), EFFECTIVE.maxWindowDays)\n    : EFFECTIVE.windowDefaultDays;\n\n  const inMaxResults = Number.parseInt($json.maxResults, 10);\n  const safeMaxResults = Number.isFinite(inMaxResults)\n    ? Math.min(Math.max(1, inMaxResults), 200)\n    : 50;\n\n  // 10) Sedes\n  let sedePreferida = sedeInfo.sedePreferida;\n  if (sedePreferida && !SCHEDULE.sedes[sedePreferida]) {\n    // defensa extra (en teor√≠a no deber√≠a pasar si CARGAR_HORARIOS valid√≥ bien)\n    log('WARN', 'Sede preferida sin horarios en SCHEDULE.sedes', { sedePreferida });\n    sedePreferida = '';\n  }\n  const sedesDisponibles = Object.keys(SCHEDULE.sedes || {});\n  const sedesFiltro =\n    sedePreferida && sedesDisponibles.includes(sedePreferida)\n      ? [sedePreferida]\n      : sedesDisponibles.length\n      ? sedesDisponibles\n      : [];\n\n  // 11) Contexto final\n  const context = {\n    kind: 'context',\n    version: VERSION,\n\n    originalInput: { raw: textInfo.raw || '', normalized: textNorm || '' },\n    locale: 'es-MX',\n    tz: TZ,\n\n    // Ventana (ISO + YMD para compatibilidad)\n    windowStart: windowStartISO,\n    windowEnd: windowEndISO,\n    windowStartDateKey: dInfo.windowStartYMD,\n    windowEndDateKey: dInfo.windowEndYMD,\n    computedWindowDays,\n\n    // Intenci√≥n y filtros\n    dateIntent: dInfo.dateIntent,\n    explicitDates: dInfo.explicitDates, // YMDs\n    timeWindow: null,\n\n    // Sede\n    sedePreferida,\n    sedes: sedesFiltro,\n    strictSede: !!sedeInfo.strict,\n\n    // L√≠mites operativos (solicitados por el caller)\n    windowDays: safeWindowDays,\n    maxResults: safeMaxResults,\n    includeWeekends: $json.includeWeekends !== false,\n    onlyMorning: !!$json.onlyMorning,\n    onlyAfternoon: !!$json.onlyAfternoon,\n    requestId:\n      $json.requestId || `req-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,\n    source: $json.source || 'unknown',\n\n    // Restricciones derivadas de la configuraci√≥n efectiva\n    constraints: {\n      shortNoticeMin: EFFECTIVE.shortNoticeMin,\n      confirmationBufferMin: EFFECTIVE.confirmationBufferMin,\n      slotMinutes: EFFECTIVE.slotMinutes,\n      maxWindowDays: EFFECTIVE.maxWindowDays,\n    },\n\n    scheduleMetadata: {\n      version: scheduleData.version,\n      updatedAt: scheduleData.updatedAt,\n      anchor: SCHEDULE.anchor,\n      sedes: sedesDisponibles,\n      config: {\n        consultationDuration: SCHEDULE.config?.consultationDuration,\n        slotAnchors: SCHEDULE.config?.slotAnchors,\n        defaultWindowDays: SCHEDULE.config?.defaultWindowDays,\n        maxWindowDays: SCHEDULE.config?.maxWindowDays,\n        maxSlots: SCHEDULE.config?.maxSlots,\n        businessDayStart: SCHEDULE.config?.businessDayStart,\n        businessDayEnd: SCHEDULE.config?.businessDayEnd,\n      },\n    },\n\n    metadata: {\n      executionTimeMs: Date.now() - t0,\n      logsCount: LOGS.length,\n    },\n  };\n\n  if (DEBUG) context._logs = LOGS;\n\n  log('SUCCESS', 'SET_DEFAULTS completado', {\n    dateIntent: context.dateIntent,\n    sede: context.sedePreferida,\n    start: context.windowStart,\n    end: context.windowEnd,\n  });\n\n  return [{ json: context }];\n} catch (error) {\n  log('ERROR', 'Error fatal', { error: error.message, stack: error.stack });\n  return [\n    {\n      json: {\n        kind: 'error',\n        component: 'SET_DEFAULTS',\n        version: VERSION,\n        error: 'UNEXPECTED_ERROR',\n        message: error.message || String(error),\n        timestamp: new Date().toISOString(),\n        logs: DEBUG ? LOGS : undefined,\n      },\n    },\n  ];\n}\n"
      },
      "id": "7b01d2dd-2c49-49e0-a25b-d630c5b46a44",
      "name": "SET_DEFAULTS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        176
      ]
    }
  ],
  "pinData": {
    "When Executed by Another Workflow": [
      {
        "json": {
          "desiredStart": "2025-11-19T06:00:00Z",
          "userText": "me gustaria saber si el doctor mario tiene consultas hoy",
          "sedePreferida": "",
          "timezone": "America/Mexico_City",
          "windowDays": 14,
          "maxResults": 50,
          "includeWeekends": false,
          "onlyMorning": false,
          "onlyAfternoon": false,
          "requestId": "1763659901771-jeey80m8e",
          "source": "urobot_whatsapp"
        }
      }
    ]
  },
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "VERIFICAR HORARIOS DE SEDES1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - POLANCO1": {
      "main": [
        [
          {
            "node": "Normalize Busy POLANCO1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - SATELITE1": {
      "main": [
        [
          {
            "node": "Normalize Busy SATELITE1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Busy (append)": {
      "main": [
        [
          {
            "node": "Combine Busy1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Busy1": {
      "main": [
        [
          {
            "node": "Calc Availability1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calc Availability1": {
      "main": [
        [
          {
            "node": "Build Response1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SCHEDULE_GATE1": {
      "main": [
        [
          {
            "node": "Availability - POLANCO1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Availability - SATELITE1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy POLANCO1": {
      "main": [
        [
          {
            "node": "Merge Busy (append)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy SATELITE1": {
      "main": [
        [
          {
            "node": "Merge Busy (append)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "VERIFICAR HORARIOS DE SEDES1": {
      "main": [
        [
          {
            "node": "CARGAR_HORARIOS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CARGAR_HORARIOS": {
      "main": [
        [
          {
            "node": "SET_DEFAULTS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SET_DEFAULTS": {
      "main": [
        [
          {
            "node": "SCHEDULE_GATE1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/Mexico_City",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "33b791d7-0bfe-4b09-b915-82836c118254",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "8c33c5b047d489bd000bdf4aabe6e4981a2da591f7a11d61031348a2fe3ef66c"
  },
  "id": "9mpErXIgA9uOnzrE",
  "tags": []
}