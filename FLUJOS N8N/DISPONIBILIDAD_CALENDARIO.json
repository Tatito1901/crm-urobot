{
  "name": "DISPONIBILIDAD_CALENDARIO",
  "nodes": [
    {
      "parameters": {
        "inputSource": "jsonExample",
        "jsonExample": "{\n  \"dateIntent\": \"today\",\n  \"specificDate\": \"\",\n  \"sedePreferida\": \"\",\n  \"onlyMorning\": false,\n  \"onlyAfternoon\": false\n}"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1616,
        176
      ],
      "id": "c2799c91-4c27-4fd6-8bef-8bb038b22af0",
      "name": "When Executed by Another Workflow",
      "retryOnFail": true
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "c_d699350899d8518308a1887dd162323d055657efd88be2a13a76ba7c44af16dd@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "HOSPITAL ANGELES POLANCO"
        },
        "timeMin": "={{$('SET_DEFAULTS').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "fdf87251-eeab-4f0a-8d40-4701f44416e4",
      "name": "Availability - POLANCO1",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -496,
        80
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "retryOnFail": false,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "Hm8ggB0P1TTFp0A0",
          "name": "GOOGLE UROBOT"
        }
      },
      "notes": "Fallback: Continue On Fail activo. Si falla, Normalize generar√° sourceStatus=error."
    },
    {
      "parameters": {
        "resource": "calendar",
        "calendar": {
          "__rl": true,
          "value": "c_a78a512ef554a6b130c5475ac2f3ad8dc335b2c57b37004ac4ca3764f29ffd3f@group.calendar.google.com",
          "mode": "list",
          "cachedResultName": "SAN ANGEL INN SATELITE"
        },
        "timeMin": "={{$('SET_DEFAULTS').first().json.windowStart}}",
        "timeMax": "={{$('SET_DEFAULTS').first().json.windowEnd}}",
        "options": {
          "outputFormat": "raw",
          "timezone": {
            "__rl": true,
            "value": "America/Mexico_City",
            "mode": "list",
            "cachedResultName": "America/Mexico_City"
          }
        }
      },
      "id": "be0a82b0-1bd9-4e51-b848-2513c26f112a",
      "name": "Availability - SATELITE1",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        -496,
        272
      ],
      "notesInFlow": true,
      "settings": {
        "continueOnFail": true
      },
      "alwaysOutputData": true,
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "Hm8ggB0P1TTFp0A0",
          "name": "GOOGLE UROBOT"
        }
      },
      "notes": "Fallback: Continue On Fail activo."
    },
    {
      "parameters": {},
      "id": "89d6106b-3e48-4687-9bb2-647b48ae697e",
      "name": "Merge Busy (append)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [
        -48,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * COMBINE_BUSY v5.2.0 ‚Äî ULTRA DEFENSIVE\n */\n\nconst VERSION = '5.2.0-ULTRA-DEFENSIVE';\nconst DEBUG = false;\n\nconst LIMITS = Object.freeze({\n  MAX_SLOTS_PER_DAY: 20,\n  MAX_TOTAL_SLOTS: 100,\n});\n\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = { timestamp: new Date().toISOString(), level: level.toUpperCase(), component: 'COMBINE_BUSY', version: VERSION, message, ...data };\n  LOGS.push(entry);\n  if (DEBUG) console.log(`[${level.toUpperCase()}] ${message}`, data);\n}\n\nconst _formattersCache = new Map();\nfunction getCachedFormatter(options, tz) {\n  const key = JSON.stringify({ ...options, tz });\n  let formatter = _formattersCache.get(key);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat('es-MX', { timeZone: tz, ...options });\n    _formattersCache.set(key, formatter);\n  }\n  return formatter;\n}\n\nfunction formatLocal(iso, tz) {\n  try {\n    const formatter = getCachedFormatter({ hour12: false, year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }, tz);\n    return formatter.format(new Date(iso));\n  } catch {\n    return iso;\n  }\n}\n\nfunction cropToWindow(interval, startISO, endISO) {\n  try {\n    const s = (startISO && interval.start < startISO) ? startISO : interval.start;\n    const e = (endISO && interval.end > endISO) ? endISO : interval.end;\n    return (s < e) ? { start: s, end: e } : null;\n  } catch {\n    return null;\n  }\n}\n\nfunction mergeExclusive(list) {\n  if (!list || !list.length) return [];\n  try {\n    const sorted = [...list].sort((a, b) => a.start.localeCompare(b.start));\n    const merged = [{ start: sorted[0].start, end: sorted[0].end }];\n    \n    for (let i = 1; i < sorted.length; i++) {\n      const last = merged[merged.length - 1];\n      const current = sorted[i];\n      if (current.start < last.end) {\n        if (current.end > last.end) last.end = current.end;\n      } else {\n        merged.push({ start: current.start, end: current.end });\n      }\n    }\n    return merged;\n  } catch {\n    return [];\n  }\n}\n\nfunction filterBusySlots(slots, busyBySede) {\n  if (!slots || !Array.isArray(slots)) return [];\n  \n  return slots.filter(slot => {\n    try {\n      const busyList = busyBySede[slot.sede];\n      if (!busyList || !busyList.length) return true;\n\n      for (const busy of busyList) {\n        if (slot.start < busy.end && slot.end > busy.start) {\n          return false;\n        }\n      }\n      return true;\n    } catch {\n      return true; // En caso de error, permitir el slot\n    }\n  });\n}\n\nfunction loadContext() {\n  let ctx = {}, requestId = `combine-${Date.now()}`;\n  \n  // Intento 1: SET_DEFAULTS\n  try {\n    const setDefaultsItems = $('SET_DEFAULTS').all();\n    if (setDefaultsItems.length > 0) {\n      ctx = setDefaultsItems[0].json || {};\n      if (ctx.requestId) requestId = ctx.requestId;\n      return { ctx, requestId, source: 'SET_DEFAULTS' };\n    }\n  } catch (err) {}\n  \n  // Intento 2: Input directo\n  try {\n    const items = $input.all();\n    for (const item of items) {\n      if (item.json?.kind === 'context') {\n        ctx = item.json;\n        if (ctx.requestId) requestId = ctx.requestId;\n        return { ctx, requestId, source: 'input_context' };\n      }\n    }\n  } catch {}\n  \n  // Fallback\n  return { \n    ctx: { \n      tz: 'America/Mexico_City',\n      windowStart: new Date().toISOString(),\n      windowEnd: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString()\n    }, \n    requestId, \n    source: 'fallback' \n  };\n}\n\nfunction loadSedes() {\n  try {\n    const store = $getWorkflowStaticData('global');\n    if (store?.SCHEDULE?.sedes) return Object.keys(store.SCHEDULE.sedes);\n  } catch {}\n  return ['POLANCO', 'SATELITE'];\n}\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// MAIN\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\ntry {\n  const startTime = Date.now();\n  \n  const rawItems = $input.all().map(x => x.json);\n  const { ctx, requestId, source: ctxSource } = loadContext();\n  const SEDES = loadSedes();\n  const TZ = ctx.tz || 'America/Mexico_City';\n  const windowStartISO = ctx.windowStart || null;\n  const windowEndISO = ctx.windowEnd || null;\n\n  // Extraer Busy Intervals\n  const groups = Object.fromEntries(SEDES.map(s => [s, []]));\n  \n  for (const item of rawItems) {\n    if (!item || item.kind !== 'busy') continue;\n    \n    if (item.sede && groups[item.sede]) {\n      (item.busy || []).forEach(slot => {\n        const clipped = cropToWindow(slot, windowStartISO, windowEndISO);\n        if (clipped) groups[item.sede].push(clipped);\n      });\n    }\n    else if (item.busyBySede) {\n      for (const [s, list] of Object.entries(item.busyBySede)) {\n        if (groups[s] && Array.isArray(list)) {\n          list.forEach(slot => {\n            const clipped = cropToWindow(slot, windowStartISO, windowEndISO);\n            if (clipped) groups[s].push(clipped);\n          });\n        }\n      }\n    }\n  }\n\n  const busyBySede = Object.fromEntries(SEDES.map(s => [s, mergeExclusive(groups[s])]));\n  \n  // Obtener Allowed Slots\n  let allowedSlots = [];\n  try {\n    const gate = $('SCHEDULE_GATE1').first()?.json;\n    if (gate?.allowedSlots && Array.isArray(gate.allowedSlots)) {\n      allowedSlots = gate.allowedSlots;\n    }\n  } catch {}\n\n  const preFilterCount = allowedSlots.length;\n  allowedSlots = allowedSlots.filter(s => s && SEDES.includes(s.sede));\n\n  // Aplicar filtro de ocupaci√≥n\n  let finalSlots = filterBusySlots(allowedSlots, busyBySede);\n\n  // Aplicar l√≠mite\n  if (ctx.maxResults && ctx.maxResults > 0) {\n    finalSlots = finalSlots.slice(0, ctx.maxResults);\n  }\n\n  const busyBySedeLocal = Object.fromEntries(\n    SEDES.map(s => [s, (busyBySede[s] || []).map(iv => ({ \n      ...iv, \n      startLocal: formatLocal(iv.start, TZ), \n      endLocal: formatLocal(iv.end, TZ) \n    }))])\n  );\n  \n  const result = {\n    kind: 'busy_combined',\n    build: { version: VERSION, generatedAt: new Date().toISOString() },\n    requestId,\n    ctx,\n    \n    scheduleGate: {\n      allowedSlots: finalSlots \n    },\n    \n    busyBySede,\n    busyBySedeLocal,\n    \n    metrics: {\n      totalInputSlots: preFilterCount,\n      totalBusyBlocks: Object.values(busyBySede).flat().length,\n      filteredByBusy: allowedSlots.length - finalSlots.length,\n      finalOutput: finalSlots.length,\n      ctxSource\n    },\n    \n    debugLocal: { tz: TZ, sedes: SEDES }\n  };\n  \n  log('SUCCESS', `Finalizado. Slots entregados: ${finalSlots.length}`);\n  \n  return [{\n    json: result,\n    pairedItem: $input.all().map((_, i) => ({ item: i }))\n  }];\n\n} catch (err) {\n  log('ERROR', err.message);\n  return [{ \n    json: { \n      kind: 'busy_combined',\n      build: { version: VERSION },\n      scheduleGate: { allowedSlots: [] },\n      busyBySede: {},\n      metrics: { error: err.message },\n      error: 'COMBINE_FAIL', \n      message: err.message \n    } \n  }];\n}"
      },
      "id": "e6fa56b2-5bd8-408a-af8c-80bafe6aa130",
      "name": "Combine Busy1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * CALC_AVAILABILITY v12.1.0 ‚Äî FLEXIBLE INPUT\n */\n\nconst VERSION = '12.1.0-FLEXIBLE';\nconst DEFAULT_TZ = 'America/Mexico_City';\n\nfunction getLocalTime(iso, tz) {\n  try {\n    return new Intl.DateTimeFormat('es-MX', {\n      timeZone: tz, hour: '2-digit', minute: '2-digit', hour12: false\n    }).format(new Date(iso));\n  } catch (e) { \n    return iso?.split('T')[1]?.substring(0, 5) || '00:00'; \n  }\n}\n\nfunction getDateKey(iso) {\n  return iso?.split('T')[0] || '';\n}\n\ntry {\n  const startTime = Date.now();\n  \n  const items = $input.all();\n  const inputData = items[0]?.json || {};\n  \n  // ‚ïê‚ïê‚ïê VALIDACI√ìN FLEXIBLE ‚ïê‚ïê‚ïê\n  // Acepta 'busy_combined' o cualquier cosa con allowedSlots\n  let rawSlots = [];\n  let requestId = inputData.requestId || `calc-${Date.now()}`;\n  let TZ = DEFAULT_TZ;\n  \n  if (inputData.kind === 'busy_combined') {\n    rawSlots = inputData.scheduleGate?.allowedSlots || [];\n    TZ = inputData.ctx?.tz || inputData.debugLocal?.tz || DEFAULT_TZ;\n  } \n  else if (inputData.allowedSlots) {\n    rawSlots = inputData.allowedSlots;\n    TZ = inputData.tz || DEFAULT_TZ;\n  }\n  else if (inputData.scheduleGate?.allowedSlots) {\n    rawSlots = inputData.scheduleGate.allowedSlots;\n    TZ = inputData.tz || DEFAULT_TZ;\n  }\n  else if (Array.isArray(inputData)) {\n    rawSlots = inputData;\n  }\n\n  // Si sigue vac√≠o, devolver respuesta vac√≠a (no error)\n  if (!rawSlots || rawSlots.length === 0) {\n    return [{\n      json: {\n        kind: 'avail',\n        version: VERSION,\n        requestId,\n        tz: TZ,\n        allowedSlots: [],\n        summary: { totalAvailable: 0, returned: 0, daysWithSlots: 0 },\n        timestamp: new Date().toISOString(),\n        _note: 'No slots received from previous node'\n      }\n    }];\n  }\n\n  // Enriquecer slots\n  const enrichedSlots = rawSlots.map(slot => {\n    if (!slot || !slot.start) return null;\n    \n    const localTime = getLocalTime(slot.start, TZ);\n    const hour = parseInt(localTime.split(':')[0]) || 0;\n    \n    return {\n      ...slot,\n      startHM: localTime,\n      shiftLabel: hour < 12 ? 'Ma√±ana' : 'Tarde',\n      dayKey: getDateKey(slot.start)\n    };\n  }).filter(Boolean);\n\n  // Ordenar cronol√≥gicamente\n  enrichedSlots.sort((a, b) => new Date(a.start) - new Date(b.start));\n\n  const limit = 50;\n  const limitedSlots = enrichedSlots.slice(0, limit);\n\n  // Generar resumen\n  const slotsByDay = {};\n  for (const slot of limitedSlots) {\n    if (!slotsByDay[slot.dayKey]) slotsByDay[slot.dayKey] = [];\n    slotsByDay[slot.dayKey].push(slot);\n  }\n\n  const summary = {\n    totalAvailable: rawSlots.length,\n    returned: limitedSlots.length,\n    firstSlot: limitedSlots.length > 0 ? limitedSlots[0].start : null,\n    lastSlot: limitedSlots.length > 0 ? limitedSlots[limitedSlots.length - 1].start : null,\n    daysWithSlots: Object.keys(slotsByDay).length\n  };\n\n  return [{\n    json: {\n      kind: 'avail',\n      version: VERSION,\n      requestId,\n      tz: TZ,\n      \n      allowedSlots: limitedSlots,\n      summary,\n      \n      dayAnalysis: Object.entries(slotsByDay).map(([date, slots]) => ({\n        date,\n        slotsCount: slots.length,\n        sedes: [...new Set(slots.map(s => s.sede))]\n      })),\n      \n      timestamp: new Date().toISOString(),\n      executionMs: Date.now() - startTime\n    }\n  }];\n\n} catch (error) {\n  return [{\n    json: {\n      kind: 'avail',\n      version: VERSION,\n      status: 'error',\n      error: error.message,\n      allowedSlots: [],\n      summary: { totalAvailable: 0 },\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "id": "aa8ee999-c536-4e2f-a0ac-73db937b4a9e",
      "name": "Calc Availability1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * SCHEDULE_GATE v16.0.0 ‚Äî BUGFIX EDITION\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n *\n * CAMBIOS vs 15.3.0:\n * \n * üî¥ FIX #1: Mejor manejo de sedePreferida\n *    - Antes: Si normalizeSede fallaba, usaba TODAS las sedes\n *    - Ahora: Usa ctx.sedes directamente (ya viene filtrado de SET_DEFAULTS)\n * \n * üî¥ FIX #2: Validaci√≥n m√°s estricta de sede\n *    - Si ctx.sedePreferida existe, SOLO esa sede se procesa\n *    - No depende de HELPERS.normalizeSede\n * \n * üü° MEJORA: Mejor logging para debug de filtros\n * \n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n */\n\nconst VERSION = '16.0.0-BUGFIX';\nconst DEBUG = true; // Activar para diagn√≥stico\n\n// ==================== LOGGING ====================\nconst LOGS = [];\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'SCHEDULE_GATE',\n    version: VERSION,\n    message,\n    ...data,\n  };\n  LOGS.push(entry);\n  if (DEBUG) {\n    const emoji = {\n      INFO: '‚ÑπÔ∏è',\n      WARN: '‚ö†Ô∏è',\n      ERROR: '‚ùå',\n      DEBUG: 'üîç',\n      SUCCESS: '‚úÖ',\n    }[level.toUpperCase()] || 'üìù';\n    console.log(`${emoji} [${level.toUpperCase()}] ${message}`, data);\n  }\n}\n\n// ==================== TIMEZONE / DATE HELPERS ====================\nlet _formattersCache = {};\nfunction getFormatters(tz) {\n  if (!_formattersCache[tz]) {\n    _formattersCache[tz] = {\n      tz,\n      DTF_FULL: new Intl.DateTimeFormat('en-CA', {\n        timeZone: tz,\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hour12: false,\n      }),\n      DTF_DISPLAY: new Intl.DateTimeFormat('es-MX', {\n        timeZone: tz,\n        weekday: 'long',\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      }),\n      DTF_HM: new Intl.DateTimeFormat('en-US', {\n        timeZone: tz,\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      }),\n    };\n  }\n  return _formattersCache[tz];\n}\n\nfunction getLocalParts(date, DTF_FULL) {\n  const parts = DTF_FULL.formatToParts(date);\n  const obj = {};\n  for (const p of parts) obj[p.type] = p.value;\n  return {\n    y: +obj.year,\n    m: +obj.month,\n    d: +obj.day,\n    hh: +obj.hour,\n    mm: +obj.minute,\n    ss: +obj.second,\n  };\n}\n\nfunction localToUTC(y, m, d, hh = 0, mm = 0, ss = 0, DTF_FULL) {\n  const naive = Date.UTC(y, m - 1, d, hh, mm, ss);\n  const asLocal = getLocalParts(new Date(naive), DTF_FULL);\n  const localEpoch = Date.UTC(\n    asLocal.y,\n    asLocal.m - 1,\n    asLocal.d,\n    asLocal.hh,\n    asLocal.mm,\n    asLocal.ss,\n  );\n  return naive - (localEpoch - naive);\n}\n\nfunction timeAtDay(date, hhmm, DTF_FULL) {\n  const [hh, mm] = hhmm.split(':').map(Number);\n  const p = getLocalParts(date, DTF_FULL);\n  return new Date(localToUTC(p.y, p.m, p.d, hh, mm, 0, DTF_FULL)).toISOString();\n}\n\nfunction formatLocal(iso, DTF_DISPLAY) {\n  return DTF_DISPLAY.format(new Date(iso));\n}\n\nfunction hhmmToMinutes(hhmm) {\n  const [h, m] = hhmm.split(':').map(Number);\n  return h * 60 + m;\n}\n\nfunction minutesToHHMM(mins) {\n  const h = Math.floor(mins / 60);\n  const m = mins % 60;\n  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;\n}\n\nfunction formatHHMM(iso, DTF_HM) {\n  const parts = DTF_HM.formatToParts(new Date(iso));\n  const hh = parts.find((p) => p.type === 'hour')?.value || '00';\n  const mm = parts.find((p) => p.type === 'minute')?.value || '00';\n  return `${hh}:${mm}`;\n}\n\n// ==================== VALIDACI√ìN & CONTEXT ====================\nfunction validateContextFromInput(item) {\n  if (!item?.json) {\n    return {\n      valid: false,\n      error: 'EMPTY_INPUT',\n      message: 'Entrada vac√≠a en SCHEDULE_GATE',\n    };\n  }\n  const ctx = item.json;\n  if (ctx.kind === 'error') {\n    return { valid: false, propagateError: true, originalError: ctx };\n  }\n  if (ctx.kind !== 'context') {\n    return {\n      valid: false,\n      error: 'INVALID_INPUT_KIND',\n      message: `Esperado kind='context', recibi√≥ '${ctx.kind || 'undefined'}'`,\n    };\n  }\n\n  const required = ['windowStart', 'windowEnd', 'tz'];\n  const missing = required.filter((f) => !ctx[f]);\n  if (missing.length) {\n    return {\n      valid: false,\n      error: 'MISSING_REQUIRED_FIELDS',\n      message: `Faltan campos: ${missing.join(', ')}`,\n    };\n  }\n\n  const startMs = new Date(ctx.windowStart).getTime();\n  const endMs = new Date(ctx.windowEnd).getTime();\n  if (isNaN(startMs) || isNaN(endMs) || startMs >= endMs) {\n    return {\n      valid: false,\n      error: 'INVALID_WINDOW',\n      message: 'windowStart/windowEnd inv√°lidos',\n    };\n  }\n\n  return { valid: true, ctx };\n}\n\n// ==================== FALLBACKS ====================\nfunction computeWeekTypeFallback(dateKey, anchor) {\n  try {\n    const anchorDate = new Date(\n      anchor?.date ? `${anchor.date}T00:00:00Z` : '2025-01-06T00:00:00Z',\n    );\n    const d = new Date(`${dateKey}T00:00:00Z`);\n    const MS_PER_DAY = 86400000;\n    const days = Math.floor((d - anchorDate) / MS_PER_DAY);\n    const weeks = Math.floor(days / 7);\n    const anchorType = anchor?.type || 'A';\n    const isEven = weeks % 2 === 0;\n    return isEven ? anchorType : anchorType === 'A' ? 'B' : 'A';\n  } catch (e) {\n    log('WARN', 'computeWeekTypeFallback error', { dateKey, error: e.message });\n    return 'A';\n  }\n}\n\n// ==================== GENERACI√ìN DE SLOTS ====================\nfunction generateSlots(ctx, SCHEDULE, HELPERS, CFG, DTF_FULL, DTF_DISPLAY, DTF_HM) {\n  log('INFO', 'üöÄ Iniciando generaci√≥n de slots', {\n    sedePreferida: ctx.sedePreferida,\n    sedesFromContext: ctx.sedes,\n    windowStart: ctx.windowStart,\n    windowEnd: ctx.windowEnd\n  });\n\n  const windowStartMs = new Date(ctx.windowStart).getTime();\n  const windowEndMs = new Date(ctx.windowEnd).getTime();\n  const now = Date.now();\n\n  const shortNoticeMin =\n    (ctx.constraints && ctx.constraints.shortNoticeMin) ?? CFG.SHORT_NOTICE_MIN;\n  const shortNoticeBuffer = now + shortNoticeMin * 60000;\n\n  const slotDurationMin =\n    (ctx.constraints && ctx.constraints.slotMinutes) ?? CFG.CONSULTATION_DURATION_MIN;\n  const slotDurationMs = slotDurationMin * 60000;\n  const anchors = CFG.ANCHORS;\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // üî¥ FIX #1: Usar ctx.sedes directamente (ya viene filtrado de SET_DEFAULTS)\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  \n  // ctx.sedes YA viene correctamente filtrado desde SET_DEFAULTS\n  // Si hay sedePreferida, ctx.sedes = [sedePreferida]\n  // Si no hay sedePreferida, ctx.sedes = todas las sedes disponibles\n  \n  let sedesToCheck = [];\n  \n  // Opci√≥n 1: Usar ctx.sedes si viene como array v√°lido\n  if (Array.isArray(ctx.sedes) && ctx.sedes.length > 0) {\n    sedesToCheck = ctx.sedes.slice();\n    log('INFO', 'üè• Usando sedes del contexto', { sedesToCheck });\n  }\n  // Opci√≥n 2: Si hay sedePreferida pero ctx.sedes no vino bien, usar sedePreferida\n  else if (ctx.sedePreferida) {\n    const sedeNorm = ctx.sedePreferida.toUpperCase().trim();\n    if (SCHEDULE.sedes[sedeNorm]) {\n      sedesToCheck = [sedeNorm];\n      log('INFO', 'üè• Usando sedePreferida directamente', { sedesToCheck });\n    } else {\n      log('WARN', '‚ö†Ô∏è sedePreferida no existe en SCHEDULE, usando todas', { \n        sedePreferida: ctx.sedePreferida,\n        sedesDisponibles: Object.keys(SCHEDULE.sedes)\n      });\n      sedesToCheck = Object.keys(SCHEDULE.sedes);\n    }\n  }\n  // Opci√≥n 3: Fallback a todas las sedes\n  else {\n    sedesToCheck = Object.keys(SCHEDULE.sedes || {});\n    log('INFO', 'üè• Sin filtro de sede, usando todas', { sedesToCheck });\n  }\n\n  // Validar que las sedes existan en SCHEDULE\n  sedesToCheck = sedesToCheck.filter(sede => {\n    const exists = !!SCHEDULE.sedes[sede];\n    if (!exists) {\n      log('WARN', `‚ö†Ô∏è Sede ${sede} no existe en SCHEDULE.sedes, ignorando`);\n    }\n    return exists;\n  });\n\n  if (sedesToCheck.length === 0) {\n    log('ERROR', '‚ùå No hay sedes v√°lidas para procesar', {\n      sedePreferida: ctx.sedePreferida,\n      sedesFromContext: ctx.sedes,\n      sedesEnSchedule: Object.keys(SCHEDULE.sedes)\n    });\n    return {\n      allowed: [],\n      allowedSlots: [],\n      skipped: { noValidSedes: 1 },\n      totalSlotsGenerated: 0,\n      shortNoticeMin,\n    };\n  }\n\n  log('SUCCESS', '‚úÖ Sedes a procesar', { sedesToCheck });\n\n  const includeWeekends = ctx.includeWeekends !== false;\n  const onlyMorning = !!ctx.onlyMorning;\n  const onlyAfternoon = !!ctx.onlyAfternoon;\n  const tw = ctx.timeWindow || null;\n\n  const allowed = [];\n  const allowedSlots = [];\n  const skipped = {\n    weekends: 0,\n    restDay: 0,\n    noSchedule: 0,\n    wrongWeekType: 0,\n    morningFilter: 0,\n    afternoonFilter: 0,\n    timeWindow: 0,\n    shortNotice: 0,\n    outsideWindow: 0,\n    partialSlot: 0,\n    invalidGrid: 0,\n  };\n\n  const MS_PER_DAY = 86400000;\n  let totalSlotsGenerated = 0;\n\n  for (const sede of sedesToCheck) {\n    const sedeSchedule = (SCHEDULE.sedes || {})[sede];\n    if (!sedeSchedule) {\n      log('WARN', 'Sede no encontrada en SCHEDULE', { sede });\n      continue;\n    }\n\n    log('DEBUG', `üìÖ Procesando sede: ${sede}`, {\n      diasConfigurados: Object.keys(sedeSchedule)\n    });\n\n    // Recorrer d√≠as: [windowStart, windowEnd)\n    for (\n      let currentMs = windowStartMs;\n      currentMs < windowEndMs;\n      currentMs += MS_PER_DAY\n    ) {\n      const currentDate = new Date(currentMs);\n      const p = getLocalParts(currentDate, DTF_FULL);\n      const localDate = new Date(Date.UTC(p.y, p.m - 1, p.d));\n      const dowLocal = localDate.getUTCDay();\n      const dateKey = `${p.y}-${String(p.m).padStart(2, '0')}-${String(\n        p.d,\n      ).padStart(2, '0')}`;\n\n      // 1) Fines de semana\n      if (!includeWeekends && (dowLocal === 0 || dowLocal === 6)) {\n        skipped.weekends++;\n        continue;\n      }\n\n      // 2) D√≠a de descanso general\n      if (SCHEDULE.rest && SCHEDULE.rest[dowLocal]) {\n        skipped.restDay++;\n        continue;\n      }\n\n      // 3) D√≠a laborable por sede\n      if (HELPERS?.isWorkingDay && !HELPERS.isWorkingDay(sede, dowLocal)) {\n        skipped.noSchedule++;\n        continue;\n      }\n\n      // Week type\n      const weekType = HELPERS?.getWeekType\n        ? HELPERS.getWeekType(dateKey, SCHEDULE.anchor)\n        : computeWeekTypeFallback(dateKey, SCHEDULE.anchor);\n\n      // Turnos del d√≠a\n      let shifts = HELPERS?.getShiftsForSedeAndDay\n        ? HELPERS.getShiftsForSedeAndDay(sede, dowLocal, weekType)\n        : null;\n      \n      // Fallback si no hay HELPERS\n      if (!shifts || !shifts.length) {\n        const dayConf = sedeSchedule[dowLocal];\n        if (Array.isArray(dayConf)) {\n          shifts = dayConf;\n        } else if (dayConf && typeof dayConf === 'object') {\n          shifts = dayConf[weekType] || Object.values(dayConf).flat();\n        }\n      }\n      \n      if (!shifts || !shifts.length) {\n        skipped.noSchedule++;\n        continue;\n      }\n\n      // Normalizar a objetos {start,end,label,weekType}\n      let normalizedShifts = shifts.map((s) =>\n        Array.isArray(s)\n          ? {\n              start: s[0],\n              end: s[1],\n              label: s[2] || `${s[0]}-${s[1]}`,\n              weekType,\n            }\n          : {\n              start: s.start,\n              end: s.end,\n              label: s.label || `${s.start}-${s.end}`,\n              weekType: s.weekType || weekType,\n            },\n      );\n\n      // 4) Filtro morning / afternoon\n      if (onlyMorning) {\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter(\n          (sh) => parseInt(sh.start.split(':')[0], 10) < 14,\n        );\n        skipped.morningFilter += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n      if (onlyAfternoon) {\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter(\n          (sh) => parseInt(sh.start.split(':')[0], 10) >= 14,\n        );\n        skipped.afternoonFilter += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n\n      // 5) Filtro por ventana horaria (overlap)\n      if (tw && (typeof tw.startMin === 'number' || typeof tw.endMin === 'number')) {\n        const reqStart = typeof tw.startMin === 'number' ? tw.startMin : 0;\n        const reqEnd = typeof tw.endMin === 'number' ? tw.endMin : 24 * 60;\n        const before = normalizedShifts.length;\n        normalizedShifts = normalizedShifts.filter((sh) => {\n          const sMin = hhmmToMinutes(sh.start);\n          const eMin = hhmmToMinutes(sh.end);\n          return sMin < reqEnd && eMin > reqStart;\n        });\n        skipped.timeWindow += Math.max(0, before - normalizedShifts.length);\n        if (!normalizedShifts.length) continue;\n      }\n\n      // 6) Generaci√≥n de slots\n      for (const sh of normalizedShifts) {\n        const shiftStartMs = new Date(timeAtDay(currentDate, sh.start, DTF_FULL)).getTime();\n        const shiftEndMs = new Date(timeAtDay(currentDate, sh.end, DTF_FULL)).getTime();\n\n        for (let cursor = shiftStartMs; cursor < shiftEndMs; cursor += slotDurationMs) {\n          const slotStartMs = cursor;\n          const slotEndMs = cursor + slotDurationMs;\n\n          if (slotEndMs > shiftEndMs) {\n            skipped.partialSlot++;\n            break;\n          }\n\n          // anclajes (:00/:30)\n          const mins = new Date(slotStartMs).getUTCMinutes();\n          if (!anchors.includes(mins)) {\n            skipped.invalidGrid++;\n            continue;\n          }\n\n          // short notice\n          if (slotStartMs < shortNoticeBuffer) {\n            skipped.shortNotice++;\n            continue;\n          }\n\n          // ventana global [windowStart, windowEnd)\n          if (slotStartMs < windowStartMs || slotStartMs >= windowEndMs) {\n            skipped.outsideWindow++;\n            continue;\n          }\n\n          const startIso = new Date(slotStartMs).toISOString();\n          const endIso = new Date(slotEndMs).toISOString();\n\n          allowed.push({ start: startIso, end: endIso });\n\n          allowedSlots.push({\n            sede,\n            start: startIso,\n            end: endIso,\n            durationMinutes: slotDurationMin,\n            label: sh.label,\n            weekType: sh.weekType || weekType || null,\n            startLocal: formatLocal(startIso, DTF_DISPLAY),\n            endLocal: formatLocal(endIso, DTF_DISPLAY),\n            startHM: formatHHMM(startIso, DTF_HM),\n            dayKey: dateKey,\n            dow: dowLocal,\n          });\n\n          totalSlotsGenerated++;\n        }\n      }\n    }\n  }\n\n  // Ordenar por fecha\n  allowed.sort((a, b) => new Date(a.start) - new Date(b.start));\n  allowedSlots.sort((a, b) => new Date(a.start) - new Date(b.start));\n\n  log('SUCCESS', '‚úÖ Generaci√≥n de slots completada', {\n    totalSlotsGenerated,\n    sedesProcesadas: sedesToCheck,\n    skipped,\n  });\n\n  return {\n    allowed,\n    allowedSlots,\n    skipped,\n    totalSlotsGenerated,\n    shortNoticeMin,\n  };\n}\n\n// ==================== MAIN ====================\ntry {\n  log('INFO', `üöÄ SCHEDULE_GATE v${VERSION} iniciando`);\n\n  // (1) Cargar SCHEDULE/HELPERS desde Static Data\n  const store =\n    typeof $getWorkflowStaticData === 'function'\n      ? $getWorkflowStaticData('global')\n      : this.getWorkflowStaticData('global');\n\n  const SCHEDULE = store.SCHEDULE;\n  const HELPERS = store.SCHEDULE_HELPERS;\n\n  if (!SCHEDULE) {\n    const guidance = {\n      tip: 'Ejecute primero CARGAR_HORARIOS en este mismo workflow para poblar Workflow Static Data (global).',\n      expectedKeys: [\n        'SCHEDULE',\n        'SCHEDULE_VERSION',\n        'SCHEDULE_UPDATED_AT',\n        'SCHEDULE_HELPERS (opcional)',\n      ],\n      foundKeys: Object.keys(store || {}),\n    };\n    log('ERROR', 'SCHEDULE ausente en Static Data', guidance);\n    return [\n      {\n        json: {\n          kind: 'error',\n          component: 'SCHEDULE_GATE',\n          version: VERSION,\n          error: 'SCHEDULE_NOT_LOADED',\n          message:\n            'SCHEDULE no cargado. ¬øEjecut√≥ CARGAR_HORARIOS primero?',\n          details: guidance,\n          logs: LOGS,\n        },\n      },\n    ];\n  }\n\n  log('INFO', '‚úÖ SCHEDULE cargado desde Static Data', {\n    version: store.SCHEDULE_VERSION,\n    updatedAt: store.SCHEDULE_UPDATED_AT,\n    tz: SCHEDULE.tz,\n    sedes: Object.keys(SCHEDULE.sedes || {}),\n    hasHelpers: !!HELPERS,\n  });\n\n  // (2) Tomar context del input\n  const input = $input.first();\n  const validation = validateContextFromInput(input);\n  if (!validation.valid) {\n    if (validation.propagateError) {\n      log('INFO', 'Propagando error upstream');\n      return [input];\n    }\n    log('ERROR', 'Entrada inv√°lida', validation);\n    return [\n      {\n        json: {\n          kind: 'error',\n          component: 'SCHEDULE_GATE',\n          version: VERSION,\n          error: validation.error,\n          message: validation.message,\n          details: validation,\n          logs: LOGS,\n        },\n      },\n    ];\n  }\n  const ctx = validation.ctx;\n\n  // Log del contexto recibido para debug\n  log('DEBUG', 'üì• Contexto recibido de SET_DEFAULTS', {\n    sedePreferida: ctx.sedePreferida,\n    sedes: ctx.sedes,\n    windowStart: ctx.windowStart,\n    windowEnd: ctx.windowEnd,\n    dateIntent: ctx.dateIntent,\n    detectedPattern: ctx.detectedPattern,\n    referenceInfo: ctx.referenceInfo\n  });\n\n  // (3) CFG derivado de SCHEDULE.config + contexto\n  const baseTZ = SCHEDULE.tz || 'America/Mexico_City';\n  const cfgFromSchedule = SCHEDULE.config || {};\n  const CFG = {\n    TZ: ctx.tz || baseTZ,\n    CONSULTATION_DURATION_MIN: cfgFromSchedule.consultationDuration || 30,\n    ANCHORS: cfgFromSchedule.slotAnchors || [0, 30],\n    SHORT_NOTICE_MIN: cfgFromSchedule.shortNoticeMinutes || 120,\n    MAX_SLOTS: cfgFromSchedule.maxSlots || 50,\n  };\n\n  const { DTF_FULL, DTF_DISPLAY, DTF_HM } = getFormatters(CFG.TZ);\n\n  // (4) Generar slots\n  const result = generateSlots(ctx, SCHEDULE, HELPERS, CFG, DTF_FULL, DTF_DISPLAY, DTF_HM);\n\n  // (5) Aplicar caps: ctx.maxResults + SCHEDULE.config.maxSlots\n  const ctxMax = Number.isFinite(Number(ctx.maxResults))\n    ? Number(ctx.maxResults)\n    : Infinity;\n  const scheduleMax = Number.isFinite(Number(CFG.MAX_SLOTS))\n    ? Number(CFG.MAX_SLOTS)\n    : Infinity;\n  const hardCap = Math.min(ctxMax, scheduleMax);\n\n  let prunedAllowed = result.allowed;\n  let prunedAllowedSlots = result.allowedSlots;\n\n  if (Number.isFinite(hardCap) && hardCap > 0 && hardCap !== Infinity) {\n    prunedAllowed = prunedAllowed.slice(0, hardCap);\n    prunedAllowedSlots = prunedAllowedSlots.slice(0, hardCap);\n  }\n\n  // (6) Resumen y respuesta\n  const summaryBySede = prunedAllowedSlots.reduce((acc, slot) => {\n    acc[slot.sede] = (acc[slot.sede] || 0) + 1;\n    return acc;\n  }, {});\n\n  const summaryByDay = prunedAllowedSlots.reduce((acc, s) => {\n    acc[s.dayKey] = (acc[s.dayKey] || 0) + 1;\n    return acc;\n  }, {});\n\n  const response = {\n    kind: 'scheduleGate',\n    version: VERSION,\n    tz: CFG.TZ,\n    request: {\n      windowStart: ctx.windowStart,\n      windowEnd: ctx.windowEnd,\n      sedes: ctx.sedes,\n      sedePreferida: ctx.sedePreferida,\n      timeWindow: ctx.timeWindow || {},\n      includeWeekends: ctx.includeWeekends !== false,\n      onlyMorning: !!ctx.onlyMorning,\n      onlyAfternoon: !!ctx.onlyAfternoon,\n      maxResults: ctx.maxResults,\n      consultationDuration: CFG.CONSULTATION_DURATION_MIN,\n      requestId: ctx.requestId,\n      // üî¥ NUEVO: Info de debug\n      referenceInfo: ctx.referenceInfo,\n      dateIntent: ctx.dateIntent,\n      detectedPattern: ctx.detectedPattern\n    },\n    decision: {\n      isOpen: prunedAllowedSlots.length > 0,\n      reason: prunedAllowedSlots.length\n        ? `${prunedAllowedSlots.length} opciones disponibles`\n        : 'Sin horarios en el rango solicitado',\n      shortNoticeMinutes: result.shortNoticeMin,\n    },\n    allowed: prunedAllowed,\n    allowedSlots: prunedAllowedSlots,\n    skipped: result.skipped,\n    summary: {\n      totalSlots: prunedAllowedSlots.length,\n      bySede: summaryBySede,\n      byDay: summaryByDay,\n    },\n    meta: {\n      scheduleVersion: store.SCHEDULE_VERSION,\n      scheduleUpdatedAt: store.SCHEDULE_UPDATED_AT,\n      grid: {\n        stepMinutes: CFG.CONSULTATION_DURATION_MIN,\n        anchors: CFG.ANCHORS,\n      },\n    },\n    _logs: LOGS,\n  };\n\n  log('SUCCESS', '‚úÖ SCHEDULE_GATE completado', {\n    total: response.summary.totalSlots,\n    bySede: summaryBySede,\n    sedePreferida: ctx.sedePreferida,\n    sedesProcesadas: ctx.sedes\n  });\n\n  return [{ json: response }];\n} catch (error) {\n  log('ERROR', '‚ùå Error fatal', { error: error.message, stack: error.stack });\n  return [\n    {\n      json: {\n        kind: 'error',\n        component: 'SCHEDULE_GATE',\n        version: VERSION,\n        error: 'UNEXPECTED_ERROR',\n        message: error.message || String(error),\n        stack: error.stack,\n        logs: LOGS,\n      },\n    },\n  ];\n}"
      },
      "id": "318b3f62-6442-43c7-b97d-593c60aba641",
      "name": "SCHEDULE_GATE1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -720,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * NORMALIZE_BUSY v2.0 ‚Äî DEFENSIVE MODE\n * Sede: POLANCO\n */\n\nconst SEDE_OBJETIVO = 'POLANCO';\nconst DEFAULT_TZ = 'America/Mexico_City';\n\nconst toMs = (v) => {\n  try {\n    return new Date(v).getTime();\n  } catch {\n    return 0;\n  }\n};\n\nconst toISO = (ms) => {\n  try {\n    return new Date(ms).toISOString();\n  } catch {\n    return null;\n  }\n};\n\ntry {\n  const items = $input.all();\n  const rawPairs = [];\n  let sourceInfo = { type: 'unknown', calendarIds: [] };\n\n  // 1. Extraer intervalos busy\n  for (const item of items) {\n    const json = item.json;\n    \n    if (!json) continue;\n    \n    // Detectar si Google Calendar fall√≥\n    if (json.error || json.code) {\n      sourceInfo.type = 'google_error';\n      sourceInfo.error = json.error || json.message || 'Unknown error';\n      continue;\n    }\n    \n    // Estructura Raw de Google Calendar\n    if (json.calendars) {\n      sourceInfo.type = 'google_raw';\n      for (const calId of Object.keys(json.calendars)) {\n        sourceInfo.calendarIds.push(calId);\n        const busyList = json.calendars[calId]?.busy || [];\n        for (const slot of busyList) {\n          if (slot.start && slot.end) {\n            const startMs = toMs(slot.start);\n            const endMs = toMs(slot.end);\n            if (startMs > 0 && endMs > startMs) {\n              rawPairs.push([startMs, endMs]);\n            }\n          }\n        }\n      }\n    }\n    // Estructura simple\n    else if (Array.isArray(json.busy)) {\n      sourceInfo.type = 'simple_array';\n      for (const slot of json.busy) {\n        if (slot.start && slot.end) {\n          const startMs = toMs(slot.start);\n          const endMs = toMs(slot.end);\n          if (startMs > 0 && endMs > startMs) {\n            rawPairs.push([startMs, endMs]);\n          }\n        }\n      }\n    }\n    // FreeBusy response format\n    else if (json.timeMin && json.timeMax) {\n      sourceInfo.type = 'freebusy_empty';\n      // No hay busy, calendario libre\n    }\n  }\n\n  // 2. Merge overlapping intervals\n  rawPairs.sort((a, b) => a[0] - b[0]);\n  const merged = [];\n  \n  if (rawPairs.length > 0) {\n    let [currStart, currEnd] = rawPairs[0];\n    \n    for (let i = 1; i < rawPairs.length; i++) {\n      const [nextStart, nextEnd] = rawPairs[i];\n      if (nextStart <= currEnd) {\n        currEnd = Math.max(currEnd, nextEnd);\n      } else {\n        const startISO = toISO(currStart);\n        const endISO = toISO(currEnd);\n        if (startISO && endISO) {\n          merged.push({ sede: SEDE_OBJETIVO, start: startISO, end: endISO });\n        }\n        currStart = nextStart;\n        currEnd = nextEnd;\n      }\n    }\n    \n    // √öltimo intervalo\n    const startISO = toISO(currStart);\n    const endISO = toISO(currEnd);\n    if (startISO && endISO) {\n      merged.push({ sede: SEDE_OBJETIVO, start: startISO, end: endISO });\n    }\n  }\n\n  // 3. Output\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE_OBJETIVO,\n      busy: merged,\n      busyBySede: { [SEDE_OBJETIVO]: merged },\n      sourceStatus: { \n        ok: true, \n        source: sourceInfo.type,\n        busyCount: merged.length,\n        rawPairsFound: rawPairs.length\n      },\n      _meta: {\n        version: '2.0-DEFENSIVE',\n        processedAt: new Date().toISOString()\n      }\n    }\n  }];\n\n} catch (err) {\n  // Error handling completo\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE_OBJETIVO,\n      busy: [],\n      busyBySede: { [SEDE_OBJETIVO]: [] },\n      sourceStatus: { \n        ok: false, \n        source: 'error_caught',\n        error: err.message,\n        stack: err.stack?.split('\\n').slice(0, 3)\n      },\n      _meta: {\n        version: '2.0-DEFENSIVE',\n        processedAt: new Date().toISOString(),\n        errorMode: true\n      }\n    }\n  }];\n}"
      },
      "id": "71a3b9b2-49df-4d69-8bca-2c9fd5d39fec",
      "name": "Normalize Busy POLANCO1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        80
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * NORMALIZE_BUSY v2.0 ‚Äî DEFENSIVE MODE\n * Sede: SATELITE\n */\n\nconst SEDE_OBJETIVO = 'SATELITE';\nconst DEFAULT_TZ = 'America/Mexico_City';\n\nconst toMs = (v) => {\n  try {\n    return new Date(v).getTime();\n  } catch {\n    return 0;\n  }\n};\n\nconst toISO = (ms) => {\n  try {\n    return new Date(ms).toISOString();\n  } catch {\n    return null;\n  }\n};\n\ntry {\n  const items = $input.all();\n  const rawPairs = [];\n  let sourceInfo = { type: 'unknown', calendarIds: [] };\n\n  for (const item of items) {\n    const json = item.json;\n    \n    if (!json) continue;\n    \n    if (json.error || json.code) {\n      sourceInfo.type = 'google_error';\n      sourceInfo.error = json.error || json.message || 'Unknown error';\n      continue;\n    }\n    \n    if (json.calendars) {\n      sourceInfo.type = 'google_raw';\n      for (const calId of Object.keys(json.calendars)) {\n        sourceInfo.calendarIds.push(calId);\n        const busyList = json.calendars[calId]?.busy || [];\n        for (const slot of busyList) {\n          if (slot.start && slot.end) {\n            const startMs = toMs(slot.start);\n            const endMs = toMs(slot.end);\n            if (startMs > 0 && endMs > startMs) {\n              rawPairs.push([startMs, endMs]);\n            }\n          }\n        }\n      }\n    }\n    else if (Array.isArray(json.busy)) {\n      sourceInfo.type = 'simple_array';\n      for (const slot of json.busy) {\n        if (slot.start && slot.end) {\n          const startMs = toMs(slot.start);\n          const endMs = toMs(slot.end);\n          if (startMs > 0 && endMs > startMs) {\n            rawPairs.push([startMs, endMs]);\n          }\n        }\n      }\n    }\n    else if (json.timeMin && json.timeMax) {\n      sourceInfo.type = 'freebusy_empty';\n    }\n  }\n\n  rawPairs.sort((a, b) => a[0] - b[0]);\n  const merged = [];\n  \n  if (rawPairs.length > 0) {\n    let [currStart, currEnd] = rawPairs[0];\n    \n    for (let i = 1; i < rawPairs.length; i++) {\n      const [nextStart, nextEnd] = rawPairs[i];\n      if (nextStart <= currEnd) {\n        currEnd = Math.max(currEnd, nextEnd);\n      } else {\n        const startISO = toISO(currStart);\n        const endISO = toISO(currEnd);\n        if (startISO && endISO) {\n          merged.push({ sede: SEDE_OBJETIVO, start: startISO, end: endISO });\n        }\n        currStart = nextStart;\n        currEnd = nextEnd;\n      }\n    }\n    \n    const startISO = toISO(currStart);\n    const endISO = toISO(currEnd);\n    if (startISO && endISO) {\n      merged.push({ sede: SEDE_OBJETIVO, start: startISO, end: endISO });\n    }\n  }\n\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE_OBJETIVO,\n      busy: merged,\n      busyBySede: { [SEDE_OBJETIVO]: merged },\n      sourceStatus: { \n        ok: true, \n        source: sourceInfo.type,\n        busyCount: merged.length,\n        rawPairsFound: rawPairs.length\n      },\n      _meta: {\n        version: '2.0-DEFENSIVE',\n        processedAt: new Date().toISOString()\n      }\n    }\n  }];\n\n} catch (err) {\n  return [{\n    json: {\n      kind: 'busy',\n      sede: SEDE_OBJETIVO,\n      busy: [],\n      busyBySede: { [SEDE_OBJETIVO]: [] },\n      sourceStatus: { \n        ok: false, \n        source: 'error_caught',\n        error: err.message\n      },\n      _meta: {\n        version: '2.0-DEFENSIVE',\n        processedAt: new Date().toISOString(),\n        errorMode: true\n      }\n    }\n  }];\n}"
      },
      "id": "507c34ec-8170-4825-8920-3fb6241f83e8",
      "name": "Normalize Busy SATELITE1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        272
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  sede,\n  horario_json,\n  calendar_id,\n  display_name,\n  direccion,\n  maps_url,\n  anchor_date,\n  anchor_week_type\nFROM public.sedes\nWHERE horario_json IS NOT NULL;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1392,
        176
      ],
      "id": "bd19c208-2d3c-4be5-a2e3-dd5f4a447828",
      "name": "VERIFICAR HORARIOS DE SEDES1",
      "credentials": {
        "postgres": {
          "id": "LZyK5sbzVT7Dy3RU",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * CARGAR_HORARIOS v3.1.0 ‚Äî PRESERVA PARAMS DEL TRIGGER\n * Cambio principal: Al final, pasamos los par√°metros originales\n */\n\nconst VERSION = '3.1.0';\nconst DEFAULT_TZ = 'America/Mexico_City';\nconst LOGS = [];\nconst DEBUG = true;\n\nfunction log(level, message, data = {}) {\n  const entry = {\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    component: 'CARGAR_HORARIOS',\n    version: VERSION,\n    message,\n    ...data,\n  };\n  LOGS.push(entry);\n  if (DEBUG) {\n    console.log(`[${entry.level}] ${entry.component} :: ${entry.message}`, data);\n  }\n}\n\nconst isHHMM = (s) => {\n  if (typeof s !== 'string') return false;\n  const m = /^(\\d{2}):(\\d{2})$/.exec(s);\n  if (!m) return false;\n  const hh = +m[1];\n  const mm = +m[2];\n  return hh >= 0 && hh <= 23 && mm >= 0 && mm <= 59;\n};\n\nconst validateShift = (shift, sede, dow, ctx = {}) => {\n  if (!Array.isArray(shift) || shift.length < 2) {\n    log('error', 'Shift inv√°lido', { sede, dow, shift, ctx });\n    return false;\n  }\n  const [start, end, label] = shift;\n  if (!isHHMM(start) || !isHHMM(end)) return false;\n  \n  const toMin = (s) => {\n    const [h, m] = s.split(':').map(Number);\n    return h * 60 + m;\n  };\n  \n  return toMin(start) < toMin(end);\n};\n\nfunction getDayOfWeekInTZ(dateISO, tz) {\n  const dayName = new Intl.DateTimeFormat('en-US', {\n    timeZone: tz,\n    weekday: 'short',\n  }).format(new Date(dateISO));\n  const map = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\n  return map[dayName];\n}\n\nfunction sedeHasScheduleOnDay(SCHEDULE, sede, dow) {\n  const sedeSchedule = SCHEDULE.sedes[sede];\n  if (!sedeSchedule) return false;\n  return Object.prototype.hasOwnProperty.call(sedeSchedule, dow);\n}\n\nfunction classifyTimeRange(hhmm) {\n  const hour = Number(hhmm.split(':')[0] || '0');\n  return hour < 14 ? 'morning' : 'afternoon';\n}\n\nfunction getShiftsForSedeAndDay(SCHEDULE, sede, dow, weekType = null) {\n  const sedeSchedule = SCHEDULE.sedes[sede];\n  if (!sedeSchedule) return [];\n  if (!Object.prototype.hasOwnProperty.call(sedeSchedule, dow)) return [];\n  const conf = sedeSchedule[dow];\n  if (Array.isArray(conf)) return conf;\n  if (conf && typeof conf === 'object') {\n    if (!weekType) return Object.values(conf).flat();\n    return conf[weekType] || [];\n  }\n  return [];\n}\n\nfunction getWorkingDays(SCHEDULE, sede) {\n  return SCHEDULE.meta[sede]?.workingDays || [];\n}\n\nfunction isWorkingDay(SCHEDULE, sede, dow) {\n  return getWorkingDays(SCHEDULE, sede).includes(dow);\n}\n\nfunction buildHelpers(SCHEDULE) {\n  return {\n    getDayOfWeekInTZ: (dateISO, tz = SCHEDULE.tz) => getDayOfWeekInTZ(dateISO, tz),\n    sedeHasScheduleOnDay: (sede, dow) => sedeHasScheduleOnDay(SCHEDULE, sede, dow),\n    classifyTimeRange,\n    getShiftsForSedeAndDay: (sede, dow, weekType) => getShiftsForSedeAndDay(SCHEDULE, sede, dow, weekType),\n    getAllSedes: () => Object.keys(SCHEDULE.sedes),\n    sedeExists: (sede) => Object.prototype.hasOwnProperty.call(SCHEDULE.sedes, sede),\n    normalizeSede: (input) => {\n      if (!input) return null;\n      const lower = String(input).toLowerCase().trim();\n      for (const [sede, meta] of Object.entries(SCHEDULE.meta)) {\n        if (sede === 'sedes') continue;\n        if (meta.aliases && meta.aliases.some((a) => String(a).toLowerCase().trim() === lower)) {\n          return sede;\n        }\n      }\n      return null;\n    },\n    getWorkingDays: (sede) => getWorkingDays(SCHEDULE, sede),\n    isWorkingDay: (sede, dow) => isWorkingDay(SCHEDULE, sede, dow),\n  };\n}\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// CARGAR PAR√ÅMETROS ORIGINALES DEL TRIGGER (NUEVA FUNCI√ìN)\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nfunction loadOriginalTriggerParams() {\n  const triggerNames = [\n    'When Executed by Another Workflow',\n    'Execute Workflow Trigger',\n    'Trigger'\n  ];\n  \n  for (const name of triggerNames) {\n    try {\n      const node = $(name);\n      if (node && node.first()) {\n        const data = node.first().json;\n        if (data) {\n          return {\n            dateIntent: data.dateIntent || null,\n            specificDate: data.specificDate || null,\n            desiredStart: data.desiredStart || null,\n            sedePreferida: data.sedePreferida || null,\n            onlyMorning: data.onlyMorning || false,\n            onlyAfternoon: data.onlyAfternoon || false,\n            _triggerSource: name\n          };\n        }\n      }\n    } catch (e) {}\n  }\n  \n  return {\n    dateIntent: null,\n    specificDate: null,\n    desiredStart: null,\n    sedePreferida: null,\n    onlyMorning: false,\n    onlyAfternoon: false,\n    _triggerSource: 'not_found'\n  };\n}\n\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n// MAIN\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nlog('info', `CARGAR_HORARIOS v${VERSION} iniciando`);\n\n// Cargar par√°metros originales ANTES de procesar\nconst originalParams = loadOriginalTriggerParams();\nlog('info', 'Par√°metros del trigger capturados', originalParams);\n\nconst rows = $input.all().map((item) => item.json || item);\n\n// FALLBACK: Si no hay filas de DB, crear estructura m√≠nima\nif (!rows || rows.length === 0) {\n  log('warn', 'No se recibieron filas desde BD, usando fallback');\n  \n  const fallbackSchedule = {\n    sedes: {\n      'POLANCO': { 1: [['09:00', '14:00', 'Ma√±ana'], ['16:00', '20:00', 'Tarde']] },\n      'SATELITE': { 3: [['09:00', '14:00', 'Ma√±ana'], ['16:00', '20:00', 'Tarde']] }\n    },\n    meta: {\n      'POLANCO': { name: 'Polanco', workingDays: [1, 2, 3, 4, 5] },\n      'SATELITE': { name: 'Sat√©lite', workingDays: [1, 2, 3, 4, 5] }\n    },\n    tz: DEFAULT_TZ\n  };\n  \n  const store = typeof $getWorkflowStaticData === 'function'\n    ? $getWorkflowStaticData('global')\n    : this.getWorkflowStaticData('global');\n    \n  store.SCHEDULE = fallbackSchedule;\n  store.SCHEDULE_VERSION = VERSION + '-FALLBACK';\n  \n  return [{\n    json: {\n      kind: 'config',\n      component: 'CARGAR_HORARIOS',\n      version: VERSION + '-FALLBACK',\n      source: 'FALLBACK',\n      dbRowCount: 0,\n      tz: DEFAULT_TZ,\n      sedes: fallbackSchedule.sedes,\n      meta: fallbackSchedule.meta,\n      sedeKeys: ['POLANCO', 'SATELITE'],\n      // ‚ïê‚ïê‚ïê PRESERVAR PARAMS DEL TRIGGER ‚ïê‚ïê‚ïê\n      ...originalParams,\n      success: true,\n      warning: 'Usando schedule de fallback, DB no disponible'\n    }\n  }];\n}\n\nlog('info', 'Filas recibidas desde nodo BD', { count: rows.length });\n\nconst SCHEDULE = {\n  tz: DEFAULT_TZ,\n  version: VERSION,\n  anchor: null,\n  rest: { 0: 'Domingo - Cerrado' },\n  sedes: {},\n  meta: { sedes: {} },\n  config: {\n    consultationDuration: 30,\n    slotAnchors: [0, 30],\n    shortNoticeMinutes: 120,\n    confirmationBufferMinutes: 15,\n    defaultWindowDays: 14,\n    maxWindowDays: 90,\n    maxSlots: 50,\n    businessDayStart: 8,\n    businessDayEnd: 20,\n  },\n};\n\nlet totalShifts = 0;\nlet validShifts = 0;\nconst errors = [];\n\n// Anchor\nfor (const row of rows) {\n  if (row.anchor_date) {\n    SCHEDULE.anchor = {\n      date: row.anchor_date,\n      type: row.anchor_week_type || 'A',\n      description: 'Semana de referencia (desde sedes)',\n    };\n    break;\n  }\n}\n\nif (!SCHEDULE.anchor) {\n  SCHEDULE.anchor = {\n    date: '2025-01-06',\n    type: 'A',\n    description: 'Anchor por defecto',\n  };\n}\n\n// Procesar sedes\nfor (const row of rows) {\n  const sedeKey = (row.sede || '').toUpperCase().trim();\n  if (!sedeKey) continue;\n\n  let horarioJson = row.horario_json;\n  if (!horarioJson) continue;\n\n  if (typeof horarioJson === 'string') {\n    try {\n      horarioJson = JSON.parse(horarioJson);\n    } catch (e) {\n      log('error', `No se pudo parsear horario_json de sede ${sedeKey}`);\n      continue;\n    }\n  }\n\n  if (typeof horarioJson !== 'object' || Array.isArray(horarioJson)) continue;\n\n  const sedeSchedule = {};\n\n  for (const [dowStr, conf] of Object.entries(horarioJson)) {\n    const dow = Number(dowStr);\n    if (Number.isNaN(dow) || dow < 0 || dow > 6) continue;\n\n    if (Array.isArray(conf)) {\n      const validatedShifts = [];\n      for (const shift of conf) {\n        totalShifts++;\n        if (validateShift(shift, sedeKey, dow)) {\n          validShifts++;\n          validatedShifts.push(shift);\n        } else {\n          errors.push({ sede: sedeKey, dow, shift });\n        }\n      }\n      if (validatedShifts.length > 0) {\n        sedeSchedule[dow] = validatedShifts;\n      }\n    } else if (conf && typeof conf === 'object') {\n      const weekTypeSchedule = {};\n      for (const [weekType, arr] of Object.entries(conf)) {\n        if (!Array.isArray(arr)) continue;\n        const validatedShifts = [];\n        for (const shift of arr) {\n          totalShifts++;\n          if (validateShift(shift, sedeKey, dow, { mode: 'alterno', weekType })) {\n            validShifts++;\n            validatedShifts.push(shift);\n          }\n        }\n        if (validatedShifts.length > 0) {\n          weekTypeSchedule[weekType] = validatedShifts;\n        }\n      }\n      if (Object.keys(weekTypeSchedule).length > 0) {\n        sedeSchedule[dow] = weekTypeSchedule;\n      }\n    }\n  }\n\n  if (Object.keys(sedeSchedule).length === 0) continue;\n\n  SCHEDULE.sedes[sedeKey] = sedeSchedule;\n\n  const workingDays = Object.keys(sedeSchedule)\n    .map((d) => Number(d))\n    .filter((d) => !Number.isNaN(d))\n    .sort((a, b) => a - b);\n\n  const metaForSede = {\n    name: row.display_name || sedeKey,\n    fullName: row.display_name || sedeKey,\n    location: row.direccion || '',\n    aliases: [sedeKey, sedeKey.toLowerCase(), ...(row.display_name ? [String(row.display_name).toLowerCase()] : [])],\n    calendarId: row.calendar_id,\n    workingDays,\n    hasWeekends: workingDays.includes(6),\n    timezone: row.timezone || DEFAULT_TZ,\n    maps_url: row.maps_url || null,\n  };\n\n  SCHEDULE.meta[sedeKey] = metaForSede;\n  SCHEDULE.meta.sedes[sedeKey] = metaForSede;\n}\n\nSCHEDULE.metadata = SCHEDULE.meta;\n\nconst stats = {\n  totalSedes: Object.keys(SCHEDULE.sedes).length,\n  totalShifts,\n  validShifts,\n  errors: errors.length,\n};\n\n// Si no hay sedes v√°lidas, usar fallback\nif (stats.totalSedes === 0) {\n  log('warn', 'Ninguna sede v√°lida, usando fallback m√≠nimo');\n  SCHEDULE.sedes = {\n    'POLANCO': { 1: [['09:00', '14:00', 'Ma√±ana']] },\n    'SATELITE': { 3: [['09:00', '14:00', 'Ma√±ana']] }\n  };\n}\n\nconst HELPERS = buildHelpers(SCHEDULE);\n\nconst store = typeof $getWorkflowStaticData === 'function'\n  ? $getWorkflowStaticData('global')\n  : this.getWorkflowStaticData('global');\n\nstore.SCHEDULE = SCHEDULE;\nstore.SCHEDULE_HELPERS = HELPERS;\nstore.SCHEDULE_VERSION = SCHEDULE.version || VERSION;\nstore.SCHEDULE_SOURCE = 'SUPABASE';\nstore.SCHEDULE_UPDATED_AT = new Date().toISOString();\n\nreturn [{\n  json: {\n    kind: 'config',\n    component: 'CARGAR_HORARIOS',\n    version: store.SCHEDULE_VERSION,\n    source: 'SUPABASE',\n    dbRowCount: rows.length,\n    updatedAt: store.SCHEDULE_UPDATED_AT,\n    tz: SCHEDULE.tz,\n    anchor: SCHEDULE.anchor,\n    config: SCHEDULE.config,\n    meta: SCHEDULE.meta,\n    sedes: SCHEDULE.sedes,\n    sedesMap: SCHEDULE.sedes,\n    stats,\n    sedeKeys: Object.keys(SCHEDULE.sedes),\n    \n    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n    // CR√çTICO: PRESERVAR PAR√ÅMETROS DEL TRIGGER PARA SET_DEFAULTS\n    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n    dateIntent: originalParams.dateIntent,\n    specificDate: originalParams.specificDate,\n    desiredStart: originalParams.desiredStart,\n    sedePreferida: originalParams.sedePreferida,\n    onlyMorning: originalParams.onlyMorning,\n    onlyAfternoon: originalParams.onlyAfternoon,\n    _triggerParams: originalParams,\n    \n    success: true,\n    message: `‚úÖ SCHEDULE v${store.SCHEDULE_VERSION} cargado (${rows.length} filas)`\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1168,
        176
      ],
      "id": "cc591c7a-aeac-4ebc-b056-cb92785bb447",
      "name": "CARGAR_HORARIOS"
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * SET_DEFAULTS v10.0.0 ‚Äî DEFENSIVE MULTI-SOURCE FALLBACK\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * \n * CAMBIOS v10:\n * - Sistema de fallback multi-fuente para par√°metros\n * - Validaci√≥n de datos m√°s estricta\n * - Mejor logging para debugging\n * - Protecci√≥n contra nodos renombrados\n * \n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n */\n\nconst VERSION = '10.0.0-DEFENSIVE';\n\n/* ===================== CONFIG ===================== */\nconst CONFIG = Object.freeze({\n  TZ: 'America/Mexico_City',\n  DEFAULT_WINDOW_DAYS: 14,\n  MAX_WINDOW_DAYS: 30,\n  MAX_RESULTS: 50,\n  INCLUDE_WEEKENDS: false,\n  SLOT_MINUTES: 30,\n  SHORT_NOTICE_MIN: 120,\n  SOURCE: 'urobot_whatsapp',\n  VALID_SEDES: ['POLANCO', 'SATELITE'],\n  \n  // Nombres posibles del nodo trigger (por si lo renombran)\n  TRIGGER_NODE_NAMES: [\n    'When Executed by Another Workflow',\n    'Execute Workflow Trigger',\n    'Trigger',\n    'Start'\n  ]\n});\n\n/* ===================== DATE HELPERS ===================== */\n\nconst DAY_MAP = {\n  'sunday': 0, 'domingo': 0, 'dom': 0,\n  'monday': 1, 'lunes': 1, 'lun': 1,\n  'tuesday': 2, 'martes': 2, 'mar': 2,\n  'wednesday': 3, 'miercoles': 3, 'mi√©rcoles': 3, 'mie': 3,\n  'thursday': 4, 'jueves': 4, 'jue': 4,\n  'friday': 5, 'viernes': 5, 'vie': 5,\n  'saturday': 6, 'sabado': 6, 's√°bado': 6, 'sab': 6,\n};\n\nfunction getLocalParts(date, tz) {\n  try {\n    const formatter = new Intl.DateTimeFormat('en-CA', {\n      timeZone: tz,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      hour12: false,\n    });\n    const parts = formatter.formatToParts(date);\n    const obj = {};\n    for (const p of parts) obj[p.type] = p.value;\n    return {\n      y: +obj.year,\n      m: +obj.month,\n      d: +obj.day,\n      hh: +obj.hour,\n      mm: +obj.minute,\n    };\n  } catch (e) {\n    // Fallback si falla Intl\n    const d = new Date(date);\n    return {\n      y: d.getFullYear(),\n      m: d.getMonth() + 1,\n      d: d.getDate(),\n      hh: d.getHours(),\n      mm: d.getMinutes(),\n    };\n  }\n}\n\nfunction getTodayYMD(tz) {\n  const p = getLocalParts(new Date(), tz);\n  return `${p.y}-${String(p.m).padStart(2, '0')}-${String(p.d).padStart(2, '0')}`;\n}\n\nfunction getTodayDOW(tz) {\n  const p = getLocalParts(new Date(), tz);\n  const d = new Date(Date.UTC(p.y, p.m - 1, p.d, 12, 0, 0));\n  return d.getUTCDay();\n}\n\nfunction getCurrentHour(tz) {\n  const p = getLocalParts(new Date(), tz);\n  return p.hh;\n}\n\nfunction ymdToDate(ymd) {\n  const [y, m, d] = ymd.split('-').map(Number);\n  return new Date(Date.UTC(y, m - 1, d, 12, 0, 0));\n}\n\nfunction dateToYMD(date) {\n  return `${date.getUTCFullYear()}-${String(date.getUTCMonth() + 1).padStart(2, '0')}-${String(date.getUTCDate()).padStart(2, '0')}`;\n}\n\nfunction addDaysToYMD(ymd, days) {\n  const d = ymdToDate(ymd);\n  d.setUTCDate(d.getUTCDate() + days);\n  return dateToYMD(d);\n}\n\nfunction ymdToISOStart(ymd, tz) {\n  const [y, m, d] = ymd.split('-').map(Number);\n  // 6am UTC ‚âà medianoche CDMX\n  const date = new Date(Date.UTC(y, m - 1, d, 6, 0, 0));\n  return date.toISOString();\n}\n\nfunction ymdToISOEnd(ymd, tz) {\n  const [y, m, d] = ymd.split('-').map(Number);\n  // 29 = 23 + 6 offset para fin de d√≠a CDMX\n  const date = new Date(Date.UTC(y, m - 1, d, 29, 59, 59));\n  return date.toISOString();\n}\n\nfunction getNextDayOfWeek(fromYMD, targetDOW, includeToday = false) {\n  const d = ymdToDate(fromYMD);\n  const currentDOW = d.getUTCDay();\n  \n  let daysToAdd;\n  if (includeToday && currentDOW === targetDOW) {\n    daysToAdd = 0;\n  } else if (currentDOW < targetDOW) {\n    daysToAdd = targetDOW - currentDOW;\n  } else {\n    daysToAdd = 7 - currentDOW + targetDOW;\n  }\n  \n  return addDaysToYMD(fromYMD, daysToAdd);\n}\n\nfunction getNextWeekMonday(fromYMD) {\n  const d = ymdToDate(fromYMD);\n  const currentDOW = d.getUTCDay();\n  \n  let daysToAdd;\n  if (currentDOW === 0) { // Domingo\n    daysToAdd = 1;\n  } else if (currentDOW === 1) { // Lunes\n    daysToAdd = 7;\n  } else {\n    daysToAdd = 8 - currentDOW;\n  }\n  \n  return addDaysToYMD(fromYMD, daysToAdd);\n}\n\nfunction getNextWeekSunday(fromYMD) {\n  const monday = getNextWeekMonday(fromYMD);\n  return addDaysToYMD(monday, 6);\n}\n\nfunction getThisWeekSunday(fromYMD) {\n  const d = ymdToDate(fromYMD);\n  const currentDOW = d.getUTCDay();\n  const daysToSunday = currentDOW === 0 ? 0 : 7 - currentDOW;\n  return addDaysToYMD(fromYMD, daysToSunday);\n}\n\nfunction sanitizeSede(input) {\n  if (!input) return '';\n  const clean = String(input)\n    .toUpperCase()\n    .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '')\n    .replace(/[^A-Z]/g, '')\n    .replace('POLNACO', 'POLANCO')\n    .replace('SATELLITE', 'SATELITE')\n    .replace('SAT√âLITE', 'SATELITE');\n  \n  return CONFIG.VALID_SEDES.includes(clean) ? clean : '';\n}\n\nfunction generateRequestId() {\n  return `req-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;\n}\n\n/* ===================== SAFE PARAM LOADING (MULTI-SOURCE FALLBACK) ===================== */\n\nfunction loadInputParams() {\n  const defaultParams = {\n    dateIntent: null,\n    specificDate: null,\n    desiredStart: null,\n    sedePreferida: null,\n    onlyMorning: false,\n    onlyAfternoon: false,\n    _source: 'none',\n    _attempts: []\n  };\n\n  let params = { ...defaultParams };\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // INTENTO 1: Buscar el nodo trigger por diferentes nombres posibles\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  for (const nodeName of CONFIG.TRIGGER_NODE_NAMES) {\n    try {\n      const triggerNode = $(nodeName);\n      if (triggerNode && triggerNode.first()) {\n        const trigger = triggerNode.first().json;\n        if (trigger && (trigger.dateIntent || trigger.sedePreferida || trigger.specificDate || trigger.desiredStart)) {\n          params = {\n            dateIntent: trigger.dateIntent || null,\n            specificDate: trigger.specificDate || null,\n            desiredStart: trigger.desiredStart || null,\n            sedePreferida: trigger.sedePreferida || null,\n            onlyMorning: trigger.onlyMorning === true,\n            onlyAfternoon: trigger.onlyAfternoon === true,\n            _source: `trigger_node:${nodeName}`,\n            _attempts: [...params._attempts, `‚úÖ ${nodeName}`]\n          };\n          return params;\n        }\n        params._attempts.push(`‚ö†Ô∏è ${nodeName} (vac√≠o)`);\n      }\n    } catch (e) {\n      params._attempts.push(`‚ùå ${nodeName} (${e.message?.slice(0, 30) || 'error'})`);\n    }\n  }\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // INTENTO 2: Leer del $json actual (nodo anterior directo)\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  try {\n    if ($json && typeof $json === 'object') {\n      const hasData = $json.dateIntent || $json.sedePreferida || $json.specificDate || $json.desiredStart;\n      if (hasData) {\n        params = {\n          dateIntent: $json.dateIntent || null,\n          specificDate: $json.specificDate || null,\n          desiredStart: $json.desiredStart || null,\n          sedePreferida: $json.sedePreferida || null,\n          onlyMorning: $json.onlyMorning === true,\n          onlyAfternoon: $json.onlyAfternoon === true,\n          _source: 'json_direct',\n          _attempts: [...params._attempts, '‚úÖ $json directo']\n        };\n        return params;\n      }\n      params._attempts.push('‚ö†Ô∏è $json (sin params relevantes)');\n    }\n  } catch (e) {\n    params._attempts.push(`‚ùå $json (${e.message?.slice(0, 30) || 'error'})`);\n  }\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // INTENTO 3: Escanear todos los items de input\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  try {\n    const allItems = $input.all();\n    for (let i = 0; i < allItems.length; i++) {\n      const data = allItems[i]?.json;\n      if (data && (data.dateIntent || data.sedePreferida || data.specificDate || data.desiredStart)) {\n        params = {\n          dateIntent: data.dateIntent || null,\n          specificDate: data.specificDate || null,\n          desiredStart: data.desiredStart || null,\n          sedePreferida: data.sedePreferida || null,\n          onlyMorning: data.onlyMorning === true,\n          onlyAfternoon: data.onlyAfternoon === true,\n          _source: `input_scan:item[${i}]`,\n          _attempts: [...params._attempts, `‚úÖ $input.all()[${i}]`]\n        };\n        return params;\n      }\n    }\n    params._attempts.push(`‚ö†Ô∏è $input.all() (${allItems.length} items, ninguno con params)`);\n  } catch (e) {\n    params._attempts.push(`‚ùå $input.all() (${e.message?.slice(0, 30) || 'error'})`);\n  }\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // INTENTO 4: Buscar en nodos espec√≠ficos del workflow\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  const otherNodes = ['VERIFICAR HORARIOS DE SEDES1', 'CARGAR_HORARIOS'];\n  for (const nodeName of otherNodes) {\n    try {\n      const node = $(nodeName);\n      if (node && node.first()) {\n        const data = node.first().json;\n        if (data && (data.dateIntent || data.sedePreferida)) {\n          params = {\n            dateIntent: data.dateIntent || null,\n            specificDate: data.specificDate || null,\n            desiredStart: data.desiredStart || null,\n            sedePreferida: data.sedePreferida || null,\n            onlyMorning: data.onlyMorning === true,\n            onlyAfternoon: data.onlyAfternoon === true,\n            _source: `other_node:${nodeName}`,\n            _attempts: [...params._attempts, `‚úÖ ${nodeName}`]\n          };\n          return params;\n        }\n      }\n    } catch (e) {\n      // Silenciar\n    }\n  }\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // FALLBACK FINAL: Valores por defecto\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  params._source = 'fallback_defaults';\n  params._attempts.push('‚ö†Ô∏è FALLBACK: usando defaults (today)');\n  \n  return params;\n}\n\n/* ===================== INTENT PROCESSOR ===================== */\n\nfunction processDateIntent(dateIntent, specificDate, todayYMD, todayDOW, tz) {\n  const intent = String(dateIntent || '').toLowerCase().trim();\n  \n  // CASO 1: HOY (o vac√≠o)\n  if (!intent || intent === 'today' || intent === 'hoy') {\n    return {\n      startYMD: todayYMD,\n      endYMD: addDaysToYMD(todayYMD, CONFIG.DEFAULT_WINDOW_DAYS),\n      windowDays: CONFIG.DEFAULT_WINDOW_DAYS,\n      pattern: 'TODAY',\n      description: `Desde hoy (${todayYMD})`\n    };\n  }\n  \n  // CASO 2: MA√ëANA\n  if (intent === 'tomorrow' || intent === 'ma√±ana' || intent === 'manana') {\n    const tomorrow = addDaysToYMD(todayYMD, 1);\n    return {\n      startYMD: tomorrow,\n      endYMD: addDaysToYMD(tomorrow, CONFIG.DEFAULT_WINDOW_DAYS),\n      windowDays: CONFIG.DEFAULT_WINDOW_DAYS,\n      pattern: 'TOMORROW',\n      description: `Desde ma√±ana (${tomorrow})`\n    };\n  }\n  \n  // CASO 3: PASADO MA√ëANA\n  if (intent === 'day_after_tomorrow' || intent === 'pasado_ma√±ana' || \n      intent === 'pasado ma√±ana' || intent === 'pasado' || intent === 'pasado_manana') {\n    const dayAfter = addDaysToYMD(todayYMD, 2);\n    return {\n      startYMD: dayAfter,\n      endYMD: addDaysToYMD(dayAfter, CONFIG.DEFAULT_WINDOW_DAYS),\n      windowDays: CONFIG.DEFAULT_WINDOW_DAYS,\n      pattern: 'DAY_AFTER_TOMORROW',\n      description: `Desde pasado ma√±ana (${dayAfter})`\n    };\n  }\n  \n  // CASO 4: ESTA SEMANA\n  if (intent === 'this_week' || intent === 'esta_semana' || intent === 'esta semana') {\n    const endOfWeek = getThisWeekSunday(todayYMD);\n    return {\n      startYMD: todayYMD,\n      endYMD: endOfWeek,\n      windowDays: 7,\n      pattern: 'THIS_WEEK',\n      description: `Esta semana (${todayYMD} ‚Üí ${endOfWeek})`\n    };\n  }\n  \n  // CASO 5: SIGUIENTE SEMANA / PR√ìXIMA SEMANA\n  if (intent === 'next_week' || intent === 'siguiente_semana' || intent === 'proxima_semana' || \n      intent === 'siguiente semana' || intent === 'proxima semana' || intent === 'pr√≥xima semana' ||\n      intent === 'la siguiente' || intent === 'la proxima' || intent === 'semana que viene' ||\n      intent === 'la pr√≥xima' || intent === 'siguiente' || intent === 'proxima') {\n    const nextMonday = getNextWeekMonday(todayYMD);\n    const nextSunday = getNextWeekSunday(todayYMD);\n    return {\n      startYMD: nextMonday,\n      endYMD: nextSunday,\n      windowDays: 7,\n      pattern: 'NEXT_WEEK',\n      description: `Siguiente semana (Lun ${nextMonday} ‚Üí Dom ${nextSunday})`\n    };\n  }\n  \n  // CASO 6: D√çA ESPEC√çFICO DE LA SEMANA (lunes, martes, etc.)\n  const dayNumber = DAY_MAP[intent];\n  if (dayNumber !== undefined) {\n    const targetDate = getNextDayOfWeek(todayYMD, dayNumber, true);\n    \n    // Si el d√≠a ya pas√≥ esta semana Y es fin de semana sin incluir weekends, \n    // buscar el de la pr√≥xima semana\n    const targetDOW = ymdToDate(targetDate).getUTCDay();\n    const isWeekend = targetDOW === 0 || targetDOW === 6;\n    \n    if (!CONFIG.INCLUDE_WEEKENDS && isWeekend) {\n      // Usuario pidi√≥ un fin de semana pero no incluimos weekends\n      // Buscar el siguiente d√≠a h√°bil\n      const nextMonday = getNextDayOfWeek(targetDate, 1, false);\n      return {\n        startYMD: nextMonday,\n        endYMD: addDaysToYMD(nextMonday, 7),\n        windowDays: 7,\n        pattern: 'WEEKEND_REDIRECT',\n        description: `${intent} es fin de semana ‚Üí desde Lun ${nextMonday}`\n      };\n    }\n    \n    return {\n      startYMD: targetDate,\n      endYMD: addDaysToYMD(targetDate, 1),\n      windowDays: 1,\n      pattern: 'SPECIFIC_DAY',\n      description: `El ${intent} (${targetDate})`\n    };\n  }\n  \n  // CASO 7: \"EL PR√ìXIMO [D√çA]\" (next_monday, proximo_lunes, etc.)\n  const nextDayMatch = intent.match(/^(next_|proximo_|pr√≥ximo_|el_proximo_|el_pr√≥ximo_)?(lunes|martes|miercoles|mi√©rcoles|jueves|viernes|sabado|s√°bado|domingo|monday|tuesday|wednesday|thursday|friday|saturday|sunday)$/);\n  if (nextDayMatch) {\n    const dayName = nextDayMatch[2];\n    const targetDOW = DAY_MAP[dayName];\n    if (targetDOW !== undefined) {\n      const includeToday = !nextDayMatch[1];\n      const targetDate = getNextDayOfWeek(todayYMD, targetDOW, includeToday);\n      return {\n        startYMD: targetDate,\n        endYMD: addDaysToYMD(targetDate, 1),\n        windowDays: 1,\n        pattern: 'NEXT_SPECIFIC_DAY',\n        description: `Pr√≥ximo ${dayName} (${targetDate})`\n      };\n    }\n  }\n  \n  // CASO 8: FECHA ESPEC√çFICA\n  if (intent === 'specific' || intent === 'fecha_especifica' || intent === 'specific_date' || intent === 'fecha') {\n    if (specificDate) {\n      let targetYMD = null;\n      \n      // Formato YYYY-MM-DD\n      if (/^\\d{4}-\\d{2}-\\d{2}$/.test(specificDate)) {\n        targetYMD = specificDate;\n      }\n      // Formato ISO\n      else if (specificDate.includes('T')) {\n        try {\n          const d = new Date(specificDate);\n          if (!isNaN(d.getTime())) {\n            const p = getLocalParts(d, tz);\n            targetYMD = `${p.y}-${String(p.m).padStart(2, '0')}-${String(p.d).padStart(2, '0')}`;\n          }\n        } catch {}\n      }\n      // Intentar parsear otros formatos\n      else {\n        try {\n          const d = new Date(specificDate);\n          if (!isNaN(d.getTime())) {\n            const p = getLocalParts(d, tz);\n            targetYMD = `${p.y}-${String(p.m).padStart(2, '0')}-${String(p.d).padStart(2, '0')}`;\n          }\n        } catch {}\n      }\n      \n      if (targetYMD) {\n        // Verificar que no sea fecha pasada\n        if (targetYMD < todayYMD) {\n          return {\n            startYMD: todayYMD,\n            endYMD: addDaysToYMD(todayYMD, CONFIG.DEFAULT_WINDOW_DAYS),\n            windowDays: CONFIG.DEFAULT_WINDOW_DAYS,\n            pattern: 'PAST_DATE_REDIRECT',\n            description: `Fecha ${targetYMD} ya pas√≥ ‚Üí desde hoy`\n          };\n        }\n        \n        return {\n          startYMD: targetYMD,\n          endYMD: addDaysToYMD(targetYMD, 1),\n          windowDays: 1,\n          pattern: 'SPECIFIC_DATE',\n          description: `Fecha espec√≠fica (${targetYMD})`\n        };\n      }\n    }\n  }\n  \n  // FALLBACK: Intent no reconocido\n  return {\n    startYMD: todayYMD,\n    endYMD: addDaysToYMD(todayYMD, CONFIG.DEFAULT_WINDOW_DAYS),\n    windowDays: CONFIG.DEFAULT_WINDOW_DAYS,\n    pattern: 'FALLBACK_DEFAULT',\n    description: `Intent no reconocido (\"${intent}\"), usando desde hoy`\n  };\n}\n\n/* ===================== LOAD SCHEDULE ===================== */\n\nfunction loadSchedule() {\n  // Intento 1: Desde nodo CARGAR_HORARIOS\n  try {\n    const n = $('CARGAR_HORARIOS').first()?.json;\n    if (n?.kind === 'config' && (n?.sedes || n?.sedesMap)) {\n      return {\n        sedes: n.sedes || n.sedesMap || {},\n        tz: n.tz || CONFIG.TZ,\n        config: n.config || {},\n        meta: n.meta || {},\n        version: n.version,\n        _source: 'CARGAR_HORARIOS'\n      };\n    }\n  } catch {}\n\n  // Intento 2: Desde static data\n  try {\n    const store = $getWorkflowStaticData('global');\n    if (store?.SCHEDULE?.sedes) {\n      return {\n        sedes: store.SCHEDULE.sedes,\n        tz: store.SCHEDULE.tz || CONFIG.TZ,\n        config: store.SCHEDULE.config || {},\n        meta: store.SCHEDULE.meta || {},\n        version: store.SCHEDULE_VERSION,\n        _source: 'static_data'\n      };\n    }\n  } catch {}\n\n  // Fallback: Config por defecto\n  return {\n    sedes: {\n      'POLANCO': { enabled: true },\n      'SATELITE': { enabled: true }\n    },\n    tz: CONFIG.TZ,\n    config: {},\n    meta: {},\n    version: 'fallback',\n    _source: 'fallback_default'\n  };\n}\n\n/* ===================== MAIN ===================== */\n\ntry {\n  const t0 = Date.now();\n  const TZ = CONFIG.TZ;\n  const todayYMD = getTodayYMD(TZ);\n  const todayDOW = getTodayDOW(TZ);\n  const currentHour = getCurrentHour(TZ);\n\n  // 1. Cargar schedule\n  const schedule = loadSchedule();\n  const sedesDisponibles = Object.keys(schedule.sedes || {});\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // 2. CARGAR PAR√ÅMETROS CON FALLBACK ROBUSTO\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  \n  const inputParams = loadInputParams();\n  \n  const dateIntent = inputParams.dateIntent;\n  const specificDate = inputParams.specificDate || inputParams.desiredStart;\n  \n  const dateResult = processDateIntent(dateIntent, specificDate, todayYMD, todayDOW, TZ);\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // 3. PROCESAR SEDE Y FILTROS\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  \n  const sedePreferida = sanitizeSede(inputParams.sedePreferida);\n  const sedesFiltro = sedePreferida ? [sedePreferida] : sedesDisponibles;\n\n  const onlyMorning = inputParams.onlyMorning === true;\n  const onlyAfternoon = inputParams.onlyAfternoon === true;\n  \n  // Si pide ambos o ninguno, no filtrar\n  const timeFilter = (onlyMorning && onlyAfternoon) || (!onlyMorning && !onlyAfternoon)\n    ? { morning: false, afternoon: false, active: false }\n    : { morning: onlyMorning, afternoon: onlyAfternoon, active: true };\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // 4. VALIDACIONES ADICIONALES\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  \n  const warnings = [];\n  \n  // Warning: Es muy tarde en el d√≠a para buscar \"hoy\"\n  if (dateResult.pattern === 'TODAY' && currentHour >= 19) {\n    warnings.push(`B√∫squeda desde hoy pero ya son las ${currentHour}:00 hrs`);\n  }\n  \n  // Warning: Sede no reconocida\n  if (inputParams.sedePreferida && !sedePreferida) {\n    warnings.push(`Sede \"${inputParams.sedePreferida}\" no reconocida, buscando en todas`);\n  }\n  \n  // Warning: Par√°metros vinieron de fallback\n  if (inputParams._source === 'fallback_defaults') {\n    warnings.push('Par√°metros no encontrados, usando defaults');\n  }\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // 5. CONSTRUIR OUTPUT\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n  const context = {\n    kind: 'context',\n    version: VERSION,\n    tz: TZ,\n\n    // Ventana de b√∫squeda (CALCULADA POR ESTE NODO)\n    windowStart: ymdToISOStart(dateResult.startYMD, TZ),\n    windowEnd: ymdToISOStart(dateResult.endYMD, TZ),\n    windowStartYMD: dateResult.startYMD,\n    windowEndYMD: dateResult.endYMD,\n    windowDays: dateResult.windowDays,\n\n    // Info de interpretaci√≥n\n    dateIntent: dateIntent,\n    detectedPattern: dateResult.pattern,\n    referenceInfo: dateResult.description,\n\n    // Filtros\n    sedePreferida,\n    sedes: sedesFiltro,\n    onlyMorning: timeFilter.morning,\n    onlyAfternoon: timeFilter.afternoon,\n    timeFilterActive: timeFilter.active,\n    includeWeekends: CONFIG.INCLUDE_WEEKENDS,\n\n    // L√≠mites\n    maxResults: CONFIG.MAX_RESULTS,\n    \n    // Metadata\n    requestId: generateRequestId(),\n    source: CONFIG.SOURCE,\n    warnings: warnings.length > 0 ? warnings : undefined,\n\n    // Configuraci√≥n de slots\n    constraints: {\n      slotMinutes: CONFIG.SLOT_MINUTES,\n      shortNoticeMin: CONFIG.SHORT_NOTICE_MIN,\n      maxWindowDays: CONFIG.MAX_WINDOW_DAYS,\n    },\n\n    // Info del schedule\n    scheduleInfo: {\n      version: schedule.version,\n      scheduleSource: schedule._source,\n      sedesDisponibles,\n    },\n\n    // Debug completo\n    _debug: {\n      inputReceived: {\n        dateIntent: inputParams.dateIntent,\n        specificDate: inputParams.specificDate,\n        desiredStart: inputParams.desiredStart,\n        sedePreferida: inputParams.sedePreferida,\n        onlyMorning: inputParams.onlyMorning,\n        onlyAfternoon: inputParams.onlyAfternoon,\n        _paramSource: inputParams._source,\n        _loadAttempts: inputParams._attempts,\n      },\n      dateProcessing: dateResult,\n      todayInfo: {\n        ymd: todayYMD,\n        dow: todayDOW,\n        dowName: ['Domingo','Lunes','Martes','Mi√©rcoles','Jueves','Viernes','S√°bado'][todayDOW],\n        currentHour,\n      },\n      executionMs: Date.now() - t0,\n    },\n  };\n\n  return [{ json: context }];\n\n} catch (error) {\n  return [{\n    json: {\n      kind: 'error',\n      version: VERSION,\n      error: error.message,\n      stack: error.stack?.split('\\n').slice(0, 5),\n      timestamp: new Date().toISOString(),\n    },\n  }];\n}"
      },
      "id": "7b01d2dd-2c49-49e0-a25b-d630c5b46a44",
      "name": "SET_DEFAULTS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        176
      ]
    },
    {
      "parameters": {
        "jsCode": "'use strict';\n\n/**\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * BUILD_RESPONSE v26.0.0 ‚Äî ULTRA DEFENSIVE + AGENT OPTIMIZED\n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n * \n * CAMBIOS vs v25:\n * \n * üî¥ FIX #1: Input flexible (acepta m√∫ltiples formatos)\n * üî¥ FIX #2: Validaci√≥n de slots corruptos antes de procesar\n * üî¥ FIX #3: Preserva contexto original para debugging\n * üü° MEJORA #1: Respuestas m√°s naturales y variadas\n * üü° MEJORA #2: Mejor agrupaci√≥n por sede cuando hay preferencia\n * üü° MEJORA #3: Warnings claros para el agente\n * üü° MEJORA #4: Metadata enriquecida para AGENDAR_CONSULTA\n * üü° MEJORA #5: Soporte para horarios de ma√±ana/tarde\n * \n * ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n */\n\nconst VERSION = '26.0.0-ULTRA-DEFENSIVE';\n\n/* ===================== CONFIGURACI√ìN ===================== */\n\nconst CONFIG = {\n  MAX_SLOTS_TO_SHOW: 8,        // M√°ximo horarios en texto resumido\n  MAX_DAYS_TO_SHOW: 4,         // M√°ximo d√≠as en texto resumido\n  MAX_TIMES_PER_DAY: 4,        // M√°ximo horarios por d√≠a en resumen\n  TZ_DEFAULT: 'America/Mexico_City',\n  \n  // Mensajes variados para respuestas m√°s naturales\n  MESSAGES: {\n    NO_AVAILABILITY: [\n      \"No encontr√© horarios disponibles para esa fecha. ¬øTe busco en otra sede o prefieres otra fecha?\",\n      \"Por el momento no hay espacios para ese d√≠a. ¬øQuieres que busque en otra fecha o sede?\",\n      \"Ese d√≠a est√° lleno. ¬øTe parece si buscamos otra opci√≥n?\"\n    ],\n    SINGLE_DAY_INTRO: [\n      \"Para {date} en {sede} tengo:\",\n      \"Estos son los horarios para {date} en {sede}:\",\n      \"En {sede} el {date} tengo disponible:\"\n    ],\n    MULTI_DAY_INTRO: [\n      \"Tengo estos horarios disponibles:\",\n      \"Encontr√© estas opciones:\",\n      \"Estos son los espacios que tengo:\"\n    ],\n    ASK_PREFERENCE: [\n      \"¬øCu√°l te funciona mejor?\",\n      \"¬øQu√© horario prefieres?\",\n      \"¬øCu√°l te queda bien?\"\n    ],\n    ASK_DAY_AND_TIME: [\n      \"¬øQu√© d√≠a y horario prefieres?\",\n      \"¬øCu√°l d√≠a y hora te funcionan?\",\n      \"¬øQu√© opci√≥n te acomoda mejor?\"\n    ]\n  }\n};\n\n/* ===================== UTILIDADES ===================== */\n\nfunction randomChoice(arr) {\n  return arr[Math.floor(Math.random() * arr.length)];\n}\n\nfunction formatTimeFromISO(isoDate, tz) {\n  try {\n    return new Intl.DateTimeFormat('en-US', {\n      timeZone: tz,\n      hour: 'numeric',\n      minute: '2-digit',\n      hour12: true\n    }).format(new Date(isoDate));\n  } catch (e) {\n    // Fallback manual\n    try {\n      const d = new Date(isoDate);\n      let h = d.getUTCHours() - 6; // Aproximaci√≥n CDMX\n      if (h < 0) h += 24;\n      const m = d.getUTCMinutes();\n      const ampm = h >= 12 ? 'PM' : 'AM';\n      const h12 = h % 12 || 12;\n      return `${h12}:${String(m).padStart(2, '0')} ${ampm}`;\n    } catch {\n      return '';\n    }\n  }\n}\n\nfunction formatDateSpanish(isoDate, tz) {\n  try {\n    const d = new Date(isoDate);\n    const dayName = new Intl.DateTimeFormat('es-MX', { \n      weekday: 'long', \n      timeZone: tz \n    }).format(d);\n    const dayNum = new Intl.DateTimeFormat('es-MX', { \n      day: 'numeric', \n      month: 'long',\n      timeZone: tz \n    }).format(d);\n    return {\n      dayName: dayName.charAt(0).toUpperCase() + dayName.slice(1),\n      full: `${dayName.charAt(0).toUpperCase() + dayName.slice(1)} ${dayNum}`,\n      short: dayNum\n    };\n  } catch (e) {\n    const datePart = isoDate?.split('T')[0] || 'Fecha';\n    return { dayName: 'D√≠a', full: datePart, short: datePart };\n  }\n}\n\nfunction getSedeReadable(sedeKey) {\n  const map = {\n    'POLANCO': 'Polanco',\n    'SATELITE': 'Sat√©lite',\n    'SATELLITE': 'Sat√©lite'\n  };\n  return map[sedeKey?.toUpperCase()] || sedeKey || 'Consultorio';\n}\n\nfunction getHourFromISO(isoDate, tz) {\n  try {\n    const timeStr = new Intl.DateTimeFormat('en-US', {\n      timeZone: tz,\n      hour: 'numeric',\n      hour12: false\n    }).format(new Date(isoDate));\n    return parseInt(timeStr) || 12;\n  } catch {\n    return 12;\n  }\n}\n\nfunction classifyShift(hour) {\n  if (hour < 12) return 'ma√±ana';\n  if (hour < 14) return 'mediod√≠a';\n  return 'tarde';\n}\n\n/* ===================== VALIDACI√ìN DE SLOTS ===================== */\n\nfunction validateSlot(slot) {\n  if (!slot || typeof slot !== 'object') return false;\n  if (!slot.start || typeof slot.start !== 'string') return false;\n  if (!slot.end || typeof slot.end !== 'string') return false;\n  if (!slot.sede || typeof slot.sede !== 'string') return false;\n  \n  // Validar que las fechas sean parseables\n  try {\n    const startDate = new Date(slot.start);\n    const endDate = new Date(slot.end);\n    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return false;\n    if (startDate >= endDate) return false;\n  } catch {\n    return false;\n  }\n  \n  return true;\n}\n\nfunction sanitizeSlots(slots) {\n  if (!Array.isArray(slots)) return [];\n  return slots.filter(validateSlot);\n}\n\n/* ===================== CARGA DE INPUT FLEXIBLE ===================== */\n\nfunction loadInputData() {\n  const result = {\n    slots: [],\n    tz: CONFIG.TZ_DEFAULT,\n    requestId: `build-${Date.now()}`,\n    source: 'unknown',\n    originalQuery: {},\n    warnings: []\n  };\n  \n  try {\n    const items = $input.all();\n    const firstItem = items[0]?.json;\n    \n    if (!firstItem) {\n      result.warnings.push('No se recibi√≥ input');\n      return result;\n    }\n    \n    // Extraer requestId\n    result.requestId = firstItem.requestId || result.requestId;\n    \n    // Extraer timezone\n    result.tz = firstItem.tz || firstItem.ctx?.tz || firstItem.debugLocal?.tz || CONFIG.TZ_DEFAULT;\n    \n    // ‚ïê‚ïê‚ïê CASO 1: kind='avail' (formato est√°ndar de Calc Availability) ‚ïê‚ïê‚ïê\n    if (firstItem.kind === 'avail') {\n      result.slots = firstItem.allowedSlots || [];\n      result.source = 'calc_availability';\n      result.originalQuery = firstItem.query || {};\n    }\n    // ‚ïê‚ïê‚ïê CASO 2: kind='busy_combined' (salt√≥ Calc Availability) ‚ïê‚ïê‚ïê\n    else if (firstItem.kind === 'busy_combined') {\n      result.slots = firstItem.scheduleGate?.allowedSlots || [];\n      result.source = 'combine_busy_direct';\n      result.warnings.push('Input vino de Combine Busy, no de Calc Availability');\n    }\n    // ‚ïê‚ïê‚ïê CASO 3: Array directo de slots ‚ïê‚ïê‚ïê\n    else if (Array.isArray(firstItem.allowedSlots)) {\n      result.slots = firstItem.allowedSlots;\n      result.source = 'direct_array';\n    }\n    // ‚ïê‚ïê‚ïê CASO 4: El item ES un array ‚ïê‚ïê‚ïê\n    else if (Array.isArray(firstItem)) {\n      result.slots = firstItem;\n      result.source = 'raw_array';\n    }\n    // ‚ïê‚ïê‚ïê CASO 5: Tiene scheduleGate ‚ïê‚ïê‚ïê\n    else if (firstItem.scheduleGate?.allowedSlots) {\n      result.slots = firstItem.scheduleGate.allowedSlots;\n      result.source = 'schedule_gate';\n    }\n    // ‚ïê‚ïê‚ïê CASO 6: Error previo ‚ïê‚ïê‚ïê\n    else if (firstItem.status === 'error' || firstItem.error) {\n      result.source = 'error_input';\n      result.warnings.push(`Error previo: ${firstItem.error || firstItem.message || 'desconocido'}`);\n    }\n    // ‚ïê‚ïê‚ïê CASO 7: Formato no reconocido ‚ïê‚ïê‚ïê\n    else {\n      result.source = 'unrecognized';\n      result.warnings.push(`Formato de input no reconocido: kind=${firstItem.kind}`);\n    }\n    \n  } catch (e) {\n    result.warnings.push(`Error cargando input: ${e.message}`);\n  }\n  \n  // Sanitizar slots\n  const originalCount = result.slots.length;\n  result.slots = sanitizeSlots(result.slots);\n  \n  if (result.slots.length < originalCount) {\n    result.warnings.push(`${originalCount - result.slots.length} slots inv√°lidos fueron filtrados`);\n  }\n  \n  return result;\n}\n\n/* ===================== CONSTRUCCI√ìN DE ALLOWED TIMES ===================== */\n\nfunction buildAllowedTimes(slots, tz) {\n  return slots.map((slot, index) => {\n    const time = formatTimeFromISO(slot.start, tz);\n    const dateInfo = formatDateSpanish(slot.start, tz);\n    const sede = getSedeReadable(slot.sede);\n    const hour = getHourFromISO(slot.start, tz);\n    \n    return {\n      // ID √∫nico para referencia\n      id: `${slot.start}|${slot.sede}`,\n      index,\n      \n      // Texto completo para el agente\n      text: `${time} - ${dateInfo.full} - ${sede}`,\n      \n      // Componentes separados\n      time,\n      date: dateInfo.full,\n      dateShort: dateInfo.short,\n      dayName: dateInfo.dayName,\n      sede,\n      sedeKey: slot.sede,\n      \n      // Clasificaci√≥n\n      shift: classifyShift(hour),\n      hour,\n      \n      // Datos crudos para AGENDAR_CONSULTA\n      slotData: {\n        start: slot.start,\n        end: slot.end,\n        sede: slot.sede,\n        slotId: `${slot.start}|${slot.sede}`\n      }\n    };\n  });\n}\n\n/* ===================== CONSTRUCCI√ìN DE RESPUESTA SUGERIDA ===================== */\n\nfunction buildSuggestedResponse(slots, tz, context = {}) {\n  if (!slots || slots.length === 0) {\n    return randomChoice(CONFIG.MESSAGES.NO_AVAILABILITY);\n  }\n\n  // Agrupar por fecha + sede\n  const groups = {};\n  for (const slot of slots) {\n    const dateKey = slot.start.split('T')[0];\n    const key = `${dateKey}|${slot.sede}`;\n    \n    if (!groups[key]) {\n      const dateInfo = formatDateSpanish(slot.start, tz);\n      groups[key] = {\n        date: dateKey,\n        dateLabel: dateInfo.full,\n        dayName: dateInfo.dayName,\n        sede: slot.sede,\n        sedeLabel: getSedeReadable(slot.sede),\n        times: [],\n        shifts: { ma√±ana: [], tarde: [] }\n      };\n    }\n    \n    const time = formatTimeFromISO(slot.start, tz);\n    const hour = getHourFromISO(slot.start, tz);\n    \n    groups[key].times.push(time);\n    \n    if (hour < 14) {\n      groups[key].shifts.ma√±ana.push(time);\n    } else {\n      groups[key].shifts.tarde.push(time);\n    }\n  }\n\n  // Ordenar grupos por fecha\n  const sortedGroups = Object.values(groups).sort((a, b) => \n    a.date.localeCompare(b.date)\n  );\n\n  // ‚ïê‚ïê‚ïê CASO 1: Un solo grupo (un d√≠a, una sede) ‚ïê‚ïê‚ïê\n  if (sortedGroups.length === 1) {\n    const g = sortedGroups[0];\n    const timesToShow = g.times.slice(0, CONFIG.MAX_SLOTS_TO_SHOW);\n    \n    let intro = randomChoice(CONFIG.MESSAGES.SINGLE_DAY_INTRO)\n      .replace('{date}', g.dateLabel)\n      .replace('{sede}', g.sedeLabel);\n    \n    let message = `${intro}\\n\\n`;\n    \n    // Si hay muchos horarios, agrupar por turno\n    if (g.times.length > 6 && g.shifts.ma√±ana.length > 0 && g.shifts.tarde.length > 0) {\n      if (g.shifts.ma√±ana.length > 0) {\n        message += `üåÖ Ma√±ana: ${g.shifts.ma√±ana.slice(0, 4).join(', ')}`;\n        if (g.shifts.ma√±ana.length > 4) message += ` (+${g.shifts.ma√±ana.length - 4} m√°s)`;\n        message += '\\n';\n      }\n      if (g.shifts.tarde.length > 0) {\n        message += `üåÜ Tarde: ${g.shifts.tarde.slice(0, 4).join(', ')}`;\n        if (g.shifts.tarde.length > 4) message += ` (+${g.shifts.tarde.length - 4} m√°s)`;\n        message += '\\n';\n      }\n    } else {\n      message += timesToShow.map(t => `‚Ä¢ ${t}`).join('\\n');\n      if (g.times.length > CONFIG.MAX_SLOTS_TO_SHOW) {\n        message += `\\n‚Ä¢ (+${g.times.length - CONFIG.MAX_SLOTS_TO_SHOW} horarios m√°s)`;\n      }\n    }\n    \n    message += `\\n\\n${randomChoice(CONFIG.MESSAGES.ASK_PREFERENCE)}`;\n    return message;\n  }\n\n  // ‚ïê‚ïê‚ïê CASO 2: M√∫ltiples grupos ‚ïê‚ïê‚ïê\n  const groupsToShow = sortedGroups.slice(0, CONFIG.MAX_DAYS_TO_SHOW);\n  \n  let message = `${randomChoice(CONFIG.MESSAGES.MULTI_DAY_INTRO)}\\n\\n`;\n  \n  for (const g of groupsToShow) {\n    const timesToShow = g.times.slice(0, CONFIG.MAX_TIMES_PER_DAY);\n    message += `üìÖ ${g.dateLabel} (${g.sedeLabel}):\\n`;\n    message += timesToShow.join(', ');\n    if (g.times.length > CONFIG.MAX_TIMES_PER_DAY) {\n      message += ` (+${g.times.length - CONFIG.MAX_TIMES_PER_DAY} m√°s)`;\n    }\n    message += '\\n\\n';\n  }\n  \n  if (sortedGroups.length > CONFIG.MAX_DAYS_TO_SHOW) {\n    message += `_(+${sortedGroups.length - CONFIG.MAX_DAYS_TO_SHOW} d√≠as m√°s disponibles)_\\n\\n`;\n  }\n  \n  message += randomChoice(CONFIG.MESSAGES.ASK_DAY_AND_TIME);\n  return message;\n}\n\n/* ===================== CONSTRUCCI√ìN DE RESUMEN POR SEDE ===================== */\n\nfunction buildSedeSummary(slots, tz) {\n  const bySede = {};\n  \n  for (const slot of slots) {\n    const sede = slot.sede;\n    if (!bySede[sede]) {\n      bySede[sede] = {\n        sede,\n        sedeLabel: getSedeReadable(sede),\n        totalSlots: 0,\n        days: new Set(),\n        firstSlot: null,\n        lastSlot: null,\n        morningSlots: 0,\n        afternoonSlots: 0\n      };\n    }\n    \n    bySede[sede].totalSlots++;\n    bySede[sede].days.add(slot.start.split('T')[0]);\n    \n    if (!bySede[sede].firstSlot || slot.start < bySede[sede].firstSlot) {\n      bySede[sede].firstSlot = slot.start;\n    }\n    if (!bySede[sede].lastSlot || slot.start > bySede[sede].lastSlot) {\n      bySede[sede].lastSlot = slot.start;\n    }\n    \n    const hour = getHourFromISO(slot.start, tz);\n    if (hour < 14) {\n      bySede[sede].morningSlots++;\n    } else {\n      bySede[sede].afternoonSlots++;\n    }\n  }\n  \n  // Convertir Set a array\n  for (const sede of Object.keys(bySede)) {\n    bySede[sede].days = Array.from(bySede[sede].days).sort();\n    bySede[sede].daysCount = bySede[sede].days.length;\n  }\n  \n  return bySede;\n}\n\n/* ===================== EJECUCI√ìN PRINCIPAL ===================== */\n\ntry {\n  const startTime = Date.now();\n  \n  // 1. Cargar input de forma flexible\n  const input = loadInputData();\n  const { slots: rawSlots, tz: TZ, requestId, source, warnings } = input;\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // ESCENARIO 1: SIN DISPONIBILIDAD\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  if (rawSlots.length === 0) {\n    return [{\n      json: {\n        kind: 'availability_response',\n        version: VERSION,\n        requestId,\n        status: 'no_availability',\n        \n        suggestedResponse: randomChoice(CONFIG.MESSAGES.NO_AVAILABILITY),\n        \n        allowedTimes: [],\n        fullDetails: [],\n        slotsForBooking: [],\n        \n        rules: {\n          canMentionTimes: false,\n          onlyFromList: true,\n          mustAskAlternative: true,\n          instruction: \"NO hay horarios. Pregunta si quiere otra fecha o sede.\"\n        },\n        \n        meta: {\n          totalSlots: 0,\n          timezone: TZ,\n          generatedAt: new Date().toISOString(),\n          inputSource: source,\n          executionMs: Date.now() - startTime\n        },\n        \n        warnings: warnings.length > 0 ? warnings : undefined,\n        \n        _debug: {\n          inputSource: source,\n          originalWarnings: warnings\n        }\n      }\n    }];\n  }\n\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  // ESCENARIO 2: HAY DISPONIBILIDAD\n  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n  \n  // 2. Construir objetos enriquecidos\n  const allowedTimesObjects = buildAllowedTimes(rawSlots, TZ);\n  \n  // 3. Construir texto sugerido\n  const suggestedResponse = buildSuggestedResponse(rawSlots, TZ);\n  \n  // 4. Lista simple de strings para el LLM\n  const allowedTimesList = allowedTimesObjects.map(x => x.text);\n  \n  // 5. Resumen por sede\n  const sedeSummary = buildSedeSummary(rawSlots, TZ);\n  \n  // 6. Detectar caracter√≠sticas de los slots\n  const hasMultipleSedes = Object.keys(sedeSummary).length > 1;\n  const hasMultipleDays = new Set(rawSlots.map(s => s.start.split('T')[0])).size > 1;\n  const hasMorningSlots = allowedTimesObjects.some(s => s.shift === 'ma√±ana');\n  const hasAfternoonSlots = allowedTimesObjects.some(s => s.shift === 'tarde');\n\n  return [{\n    json: {\n      kind: 'availability_response',\n      version: VERSION,\n      requestId,\n      status: 'success',\n      \n      // ‚ïê‚ïê‚ïê A) TEXTO PARA EL CHAT ‚ïê‚ïê‚ïê\n      suggestedResponse,\n      \n      // ‚ïê‚ïê‚ïê B) LISTA COMPLETA PARA EL AGENTE ‚ïê‚ïê‚ïê\n      allowedTimes: allowedTimesList,\n      \n      // ‚ïê‚ïê‚ïê C) DATOS DETALLADOS ‚ïê‚ïê‚ïê\n      fullDetails: allowedTimesObjects,\n      \n      // ‚ïê‚ïê‚ïê D) REGLAS DE COMPORTAMIENTO ‚ïê‚ïê‚ïê\n      rules: {\n        canMentionTimes: true,\n        onlyFromList: true,\n        instruction: \"Usa 'suggestedResponse' como base. Si piden m√°s opciones, consulta 'allowedTimes'. NUNCA inventes horarios.\",\n        \n        // Reglas espec√≠ficas seg√∫n contexto\n        hasMultipleSedes,\n        hasMultipleDays,\n        hasMorningSlots,\n        hasAfternoonSlots,\n        \n        // Instrucciones condicionales\n        ifAsksForMorning: hasMorningSlots \n          ? \"Filtra de allowedTimes los que tengan shift='ma√±ana'\" \n          : \"Indica que no hay horarios de ma√±ana disponibles\",\n        ifAsksForAfternoon: hasAfternoonSlots \n          ? \"Filtra de allowedTimes los que tengan shift='tarde'\" \n          : \"Indica que no hay horarios de tarde disponibles\",\n        ifAsksForOtherSede: hasMultipleSedes \n          ? \"Hay horarios en m√∫ltiples sedes, puedes ofrecer alternativas\"\n          : \"Solo hay una sede disponible\"\n      },\n      \n      // ‚ïê‚ïê‚ïê E) DATOS PARA AGENDAR_CONSULTA ‚ïê‚ïê‚ïê\n      slotsForBooking: allowedTimesObjects.map(t => ({\n        id: t.id,\n        label: t.text,\n        time: t.time,\n        date: t.date,\n        sede: t.sedeKey,\n        ...t.slotData\n      })),\n      \n      // ‚ïê‚ïê‚ïê F) RESUMEN POR SEDE ‚ïê‚ïê‚ïê\n      sedeSummary,\n      \n      // ‚ïê‚ïê‚ïê G) METADATA ‚ïê‚ïê‚ïê\n      meta: {\n        totalSlots: rawSlots.length,\n        uniqueDays: new Set(rawSlots.map(s => s.start.split('T')[0])).size,\n        uniqueSedes: Object.keys(sedeSummary),\n        timezone: TZ,\n        generatedAt: new Date().toISOString(),\n        inputSource: source,\n        executionMs: Date.now() - startTime\n      },\n      \n      // ‚ïê‚ïê‚ïê H) WARNINGS (si hay) ‚ïê‚ïê‚ïê\n      warnings: warnings.length > 0 ? warnings : undefined,\n      \n      // ‚ïê‚ïê‚ïê I) DEBUG ‚ïê‚ïê‚ïê\n      _debug: {\n        inputSource: source,\n        slotsReceived: rawSlots.length,\n        slotsAfterValidation: allowedTimesObjects.length,\n        originalWarnings: warnings\n      }\n    }\n  }];\n\n} catch (err) {\n  // Error handling robusto\n  return [{\n    json: {\n      kind: 'availability_response',\n      version: VERSION,\n      status: 'error',\n      error: err.message,\n      \n      suggestedResponse: \"Tuve un problema t√©cnico al consultar la agenda. ¬øMe repites qu√© fecha buscas?\",\n      \n      allowedTimes: [],\n      fullDetails: [],\n      slotsForBooking: [],\n      \n      rules: {\n        canMentionTimes: false,\n        onlyFromList: true,\n        mustRetry: true,\n        instruction: \"Hubo un error. Pide al usuario que repita su solicitud.\"\n      },\n      \n      meta: {\n        timezone: CONFIG.TZ_DEFAULT,\n        generatedAt: new Date().toISOString(),\n        errorDetails: {\n          message: err.message,\n          stack: err.stack?.split('\\n').slice(0, 3)\n        }\n      }\n    }\n  }];\n}"
      },
      "id": "e7f44ed3-e1c6-4973-9adf-695f6a67c185",
      "name": "Build Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        624,
        176
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "VERIFICAR HORARIOS DE SEDES1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - POLANCO1": {
      "main": [
        [
          {
            "node": "Normalize Busy POLANCO1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Availability - SATELITE1": {
      "main": [
        [
          {
            "node": "Normalize Busy SATELITE1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Busy (append)": {
      "main": [
        [
          {
            "node": "Combine Busy1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Busy1": {
      "main": [
        [
          {
            "node": "Calc Availability1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calc Availability1": {
      "main": [
        [
          {
            "node": "Build Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SCHEDULE_GATE1": {
      "main": [
        [
          {
            "node": "Availability - POLANCO1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Availability - SATELITE1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy POLANCO1": {
      "main": [
        [
          {
            "node": "Merge Busy (append)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Busy SATELITE1": {
      "main": [
        [
          {
            "node": "Merge Busy (append)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "VERIFICAR HORARIOS DE SEDES1": {
      "main": [
        [
          {
            "node": "CARGAR_HORARIOS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CARGAR_HORARIOS": {
      "main": [
        [
          {
            "node": "SET_DEFAULTS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SET_DEFAULTS": {
      "main": [
        [
          {
            "node": "SCHEDULE_GATE1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "timezone": "America/Mexico_City",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "4068841c-cdc2-4db8-b0b2-f36066566f04",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "8c33c5b047d489bd000bdf4aabe6e4981a2da591f7a11d61031348a2fe3ef66c"
  },
  "id": "9mpErXIgA9uOnzrE",
  "tags": []
}